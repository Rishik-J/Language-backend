{
  "LanguageRecursiveTextSplitter": {
    "template": {
      "_type": "Component",
      "data_input": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "trace_as_input": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "data_input",
        "value": "",
        "display_name": "Input",
        "advanced": false,
        "input_types": [
          "Document",
          "Data"
        ],
        "dynamic": false,
        "info": "The texts to split.",
        "title_case": false,
        "type": "other",
        "_input_type": "DataInput"
      },
      "chunk_overlap": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "chunk_overlap",
        "value": 200,
        "display_name": "Chunk Overlap",
        "advanced": false,
        "dynamic": false,
        "info": "The amount of overlap between chunks.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "chunk_size": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "chunk_size",
        "value": 1000,
        "display_name": "Chunk Size",
        "advanced": false,
        "dynamic": false,
        "info": "The maximum length of each chunk.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from typing import Any\n\nfrom langchain_text_splitters import Language, RecursiveCharacterTextSplitter, TextSplitter\n\nfrom langflow.base.textsplitters.model import LCTextSplitterComponent\nfrom langflow.inputs import DataInput, DropdownInput, IntInput\n\n\nclass LanguageRecursiveTextSplitterComponent(LCTextSplitterComponent):\n    display_name: str = \"Language Recursive Text Splitter\"\n    description: str = \"Split text into chunks of a specified length based on language.\"\n    documentation: str = \"https://docs.langflow.org/components/text-splitters#languagerecursivetextsplitter\"\n    name = \"LanguageRecursiveTextSplitter\"\n    icon = \"LangChain\"\n\n    inputs = [\n        IntInput(\n            name=\"chunk_size\",\n            display_name=\"Chunk Size\",\n            info=\"The maximum length of each chunk.\",\n            value=1000,\n        ),\n        IntInput(\n            name=\"chunk_overlap\",\n            display_name=\"Chunk Overlap\",\n            info=\"The amount of overlap between chunks.\",\n            value=200,\n        ),\n        DataInput(\n            name=\"data_input\",\n            display_name=\"Input\",\n            info=\"The texts to split.\",\n            input_types=[\"Document\", \"Data\"],\n            required=True,\n        ),\n        DropdownInput(\n            name=\"code_language\", display_name=\"Code Language\", options=[x.value for x in Language], value=\"python\"\n        ),\n    ]\n\n    def get_data_input(self) -> Any:\n        return self.data_input\n\n    def build_text_splitter(self) -> TextSplitter:\n        return RecursiveCharacterTextSplitter.from_language(\n            language=Language(self.code_language),\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n        )\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "code_language": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "cpp",
          "go",
          "java",
          "kotlin",
          "js",
          "ts",
          "php",
          "proto",
          "python",
          "rst",
          "ruby",
          "rust",
          "scala",
          "swift",
          "markdown",
          "latex",
          "html",
          "sol",
          "csharp",
          "cobol",
          "c",
          "lua",
          "perl",
          "haskell",
          "elixir",
          "powershell"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "code_language",
        "value": "python",
        "display_name": "Code Language",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      }
    },
    "description": "Split text into chunks of a specified length based on language.",
    "icon": "LangChain",
    "base_classes": [
      "Data"
    ],
    "display_name": "Language Recursive Text Splitter",
    "documentation": "https://docs.langflow.org/components/text-splitters#languagerecursivetextsplitter",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "data",
        "display_name": "Data",
        "method": "transform_data",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "chunk_size",
      "chunk_overlap",
      "data_input",
      "code_language"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "LLMMathChain": {
    "template": {
      "_type": "Component",
      "llm": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "llm",
        "value": "",
        "display_name": "Language Model",
        "advanced": false,
        "input_types": [
          "LanguageModel"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain.chains import LLMMathChain\n\nfrom langflow.base.chains.model import LCChainComponent\nfrom langflow.field_typing import Message\nfrom langflow.inputs import HandleInput, MultilineInput\nfrom langflow.template import Output\n\n\nclass LLMMathChainComponent(LCChainComponent):\n    display_name = \"LLMMathChain\"\n    description = \"Chain that interprets a prompt and executes python code to do math.\"\n    documentation = \"https://python.langchain.com/docs/modules/chains/additional/llm_math\"\n    name = \"LLMMathChain\"\n    legacy: bool = True\n    icon = \"LangChain\"\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input\",\n            info=\"The input value to pass to the chain.\",\n            required=True,\n        ),\n        HandleInput(\n            name=\"llm\",\n            display_name=\"Language Model\",\n            input_types=[\"LanguageModel\"],\n            required=True,\n        ),\n    ]\n\n    outputs = [Output(display_name=\"Message\", name=\"text\", method=\"invoke_chain\")]\n\n    def invoke_chain(self) -> Message:\n        chain = LLMMathChain.from_llm(llm=self.llm)\n        response = chain.invoke(\n            {chain.input_key: self.input_value},\n            config={\"callbacks\": self.get_langchain_callbacks()},\n        )\n        result = response.get(chain.output_key, \"\")\n        result = str(result)\n        self.status = result\n        return Message(text=result)\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "input_value": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "input_value",
        "value": "",
        "display_name": "Input",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The input value to pass to the chain.",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      }
    },
    "description": "Chain that interprets a prompt and executes python code to do math.",
    "icon": "LangChain",
    "base_classes": [
      "Message"
    ],
    "display_name": "LLMMathChain",
    "documentation": "https://python.langchain.com/docs/modules/chains/additional/llm_math",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Message"
        ],
        "selected": "Message",
        "name": "text",
        "display_name": "Message",
        "method": "invoke_chain",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "input_value",
      "llm"
    ],
    "beta": false,
    "legacy": true,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "VectorStoreRetriever": {
    "template": {
      "_type": "CustomComponent",
      "vectorstore": {
        "type": "VectorStore",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": false,
        "fileTypes": [],
        "file_path": "",
        "name": "vectorstore",
        "display_name": "Vector Store",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain_core.vectorstores import VectorStoreRetriever\n\nfrom langflow.custom import CustomComponent\nfrom langflow.field_typing import VectorStore\n\n\nclass VectoStoreRetrieverComponent(CustomComponent):\n    display_name = \"VectorStore Retriever\"\n    description = \"A vector store retriever\"\n    name = \"VectorStoreRetriever\"\n    legacy: bool = True\n    icon = \"LangChain\"\n\n    def build_config(self):\n        return {\n            \"vectorstore\": {\"display_name\": \"Vector Store\", \"type\": VectorStore},\n        }\n\n    def build(self, vectorstore: VectorStore) -> VectorStoreRetriever:\n        return vectorstore.as_retriever()\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      }
    },
    "description": "A vector store retriever",
    "icon": "LangChain",
    "base_classes": [
      "BaseRetriever",
      "Generic",
      "object",
      "Runnable",
      "RunnableSerializable",
      "RunnableSerializable[str, list[Document]]",
      "Serializable",
      "VectorStoreRetriever"
    ],
    "display_name": "VectorStore Retriever",
    "documentation": "",
    "minimized": false,
    "custom_fields": {
      "vectorstore": null
    },
    "output_types": [
      "VectorStoreRetriever"
    ],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "VectorStoreRetriever"
        ],
        "selected": "VectorStoreRetriever",
        "name": "vectorstoreretriever",
        "hidden": null,
        "display_name": "VectorStoreRetriever",
        "method": null,
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": null,
        "allows_loop": false,
        "options": null,
        "tool_mode": true
      }
    ],
    "field_order": [],
    "beta": false,
    "legacy": true,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "ConversationChain": {
    "template": {
      "_type": "Component",
      "llm": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "llm",
        "value": "",
        "display_name": "Language Model",
        "advanced": false,
        "input_types": [
          "LanguageModel"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "memory": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "memory",
        "value": "",
        "display_name": "Memory",
        "advanced": false,
        "input_types": [
          "BaseChatMemory"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain.chains import ConversationChain\n\nfrom langflow.base.chains.model import LCChainComponent\nfrom langflow.field_typing import Message\nfrom langflow.inputs import HandleInput, MultilineInput\n\n\nclass ConversationChainComponent(LCChainComponent):\n    display_name = \"ConversationChain\"\n    description = \"Chain to have a conversation and load context from memory.\"\n    name = \"ConversationChain\"\n    legacy: bool = True\n    icon = \"LangChain\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input\",\n            info=\"The input value to pass to the chain.\",\n            required=True,\n        ),\n        HandleInput(\n            name=\"llm\",\n            display_name=\"Language Model\",\n            input_types=[\"LanguageModel\"],\n            required=True,\n        ),\n        HandleInput(\n            name=\"memory\",\n            display_name=\"Memory\",\n            input_types=[\"BaseChatMemory\"],\n        ),\n    ]\n\n    def invoke_chain(self) -> Message:\n        if not self.memory:\n            chain = ConversationChain(llm=self.llm)\n        else:\n            chain = ConversationChain(llm=self.llm, memory=self.memory)\n\n        result = chain.invoke(\n            {\"input\": self.input_value},\n            config={\"callbacks\": self.get_langchain_callbacks()},\n        )\n        if isinstance(result, dict):\n            result = result.get(chain.output_key, \"\")\n\n        elif not isinstance(result, str):\n            result = result.get(\"response\")\n        result = str(result)\n        self.status = result\n        return Message(text=result)\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "input_value": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "input_value",
        "value": "",
        "display_name": "Input",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The input value to pass to the chain.",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      }
    },
    "description": "Chain to have a conversation and load context from memory.",
    "icon": "LangChain",
    "base_classes": [
      "Message"
    ],
    "display_name": "ConversationChain",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Message"
        ],
        "selected": "Message",
        "name": "text",
        "display_name": "Text",
        "method": "invoke_chain",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "input_value",
          "llm"
        ],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "input_value",
      "llm",
      "memory"
    ],
    "beta": false,
    "legacy": true,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "OpenAPIAgent": {
    "template": {
      "_type": "Component",
      "llm": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "llm",
        "value": "",
        "display_name": "Language Model",
        "advanced": false,
        "input_types": [
          "LanguageModel"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "path": {
        "trace_as_metadata": true,
        "file_path": "",
        "fileTypes": [
          "json",
          "yaml",
          "yml"
        ],
        "temp_file": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "path",
        "value": "",
        "display_name": "File Path",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "file",
        "_input_type": "FileInput"
      },
      "agent_description": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "agent_description",
        "value": "A helpful assistant with access to the following tools:",
        "display_name": "Agent Description [Deprecated]",
        "advanced": true,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The description of the agent. This is only used when in Tool Mode. Defaults to 'A helpful assistant with access to the following tools:' and tools are added dynamically. This feature is deprecated and will be removed in future versions.",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "allow_dangerous_requests": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "allow_dangerous_requests",
        "value": false,
        "display_name": "Allow Dangerous Requests",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from pathlib import Path\n\nimport yaml\nfrom langchain.agents import AgentExecutor\nfrom langchain_community.agent_toolkits import create_openapi_agent\nfrom langchain_community.agent_toolkits.openapi.toolkit import OpenAPIToolkit\nfrom langchain_community.tools.json.tool import JsonSpec\nfrom langchain_community.utilities.requests import TextRequestsWrapper\n\nfrom langflow.base.agents.agent import LCAgentComponent\nfrom langflow.inputs import BoolInput, FileInput, HandleInput\n\n\nclass OpenAPIAgentComponent(LCAgentComponent):\n    display_name = \"OpenAPI Agent\"\n    description = \"Agent to interact with OpenAPI API.\"\n    name = \"OpenAPIAgent\"\n    icon = \"LangChain\"\n    inputs = [\n        *LCAgentComponent._base_inputs,\n        HandleInput(name=\"llm\", display_name=\"Language Model\", input_types=[\"LanguageModel\"], required=True),\n        FileInput(name=\"path\", display_name=\"File Path\", file_types=[\"json\", \"yaml\", \"yml\"], required=True),\n        BoolInput(name=\"allow_dangerous_requests\", display_name=\"Allow Dangerous Requests\", value=False, required=True),\n    ]\n\n    def build_agent(self) -> AgentExecutor:\n        path = Path(self.path)\n        if path.suffix in {\"yaml\", \"yml\"}:\n            with path.open(encoding=\"utf-8\") as file:\n                yaml_dict = yaml.safe_load(file)\n            spec = JsonSpec(dict_=yaml_dict)\n        else:\n            spec = JsonSpec.from_file(path)\n        requests_wrapper = TextRequestsWrapper()\n        toolkit = OpenAPIToolkit.from_llm(\n            llm=self.llm,\n            json_spec=spec,\n            requests_wrapper=requests_wrapper,\n            allow_dangerous_requests=self.allow_dangerous_requests,\n        )\n\n        agent_args = self.get_agent_kwargs()\n\n        # This is bit weird - generally other create_*_agent functions have max_iterations in the\n        # `agent_executor_kwargs`, but openai has this parameter passed directly.\n        agent_args[\"max_iterations\"] = agent_args[\"agent_executor_kwargs\"][\"max_iterations\"]\n        del agent_args[\"agent_executor_kwargs\"][\"max_iterations\"]\n        return create_openapi_agent(llm=self.llm, toolkit=toolkit, **agent_args)\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "handle_parsing_errors": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "handle_parsing_errors",
        "value": true,
        "display_name": "Handle Parse Errors",
        "advanced": true,
        "dynamic": false,
        "info": "Should the Agent fix errors when reading user input for better processing?",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "input_value": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "input_value",
        "value": "",
        "display_name": "Input",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The input provided by the user for the agent to process.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "max_iterations": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "max_iterations",
        "value": 15,
        "display_name": "Max Iterations",
        "advanced": true,
        "dynamic": false,
        "info": "The maximum number of attempts the agent can make to complete its task before it stops.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "verbose": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "verbose",
        "value": true,
        "display_name": "Verbose",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      }
    },
    "description": "Agent to interact with OpenAPI API.",
    "icon": "LangChain",
    "base_classes": [
      "AgentExecutor",
      "Message"
    ],
    "display_name": "OpenAPI Agent",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "AgentExecutor"
        ],
        "selected": "AgentExecutor",
        "name": "agent",
        "hidden": true,
        "display_name": "Agent",
        "method": "build_agent",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "allow_dangerous_requests",
          "llm",
          "path"
        ],
        "allows_loop": false,
        "tool_mode": false
      },
      {
        "types": [
          "Message"
        ],
        "selected": "Message",
        "name": "response",
        "display_name": "Response",
        "method": "message_response",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "input_value",
      "handle_parsing_errors",
      "verbose",
      "max_iterations",
      "agent_description",
      "llm",
      "path",
      "allow_dangerous_requests"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "RetrievalQA": {
    "template": {
      "_type": "Component",
      "llm": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "llm",
        "value": "",
        "display_name": "Language Model",
        "advanced": false,
        "input_types": [
          "LanguageModel"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "memory": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "memory",
        "value": "",
        "display_name": "Memory",
        "advanced": false,
        "input_types": [
          "BaseChatMemory"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "retriever": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "retriever",
        "value": "",
        "display_name": "Retriever",
        "advanced": false,
        "input_types": [
          "Retriever"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "chain_type": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "Stuff",
          "Map Reduce",
          "Refine",
          "Map Rerank"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "chain_type",
        "value": "Stuff",
        "display_name": "Chain Type",
        "advanced": true,
        "dynamic": false,
        "info": "Chain type to use.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain.chains import RetrievalQA\n\nfrom langflow.base.chains.model import LCChainComponent\nfrom langflow.field_typing import Message\nfrom langflow.inputs import BoolInput, DropdownInput, HandleInput, MultilineInput\n\n\nclass RetrievalQAComponent(LCChainComponent):\n    display_name = \"Retrieval QA\"\n    description = \"Chain for question-answering querying sources from a retriever.\"\n    name = \"RetrievalQA\"\n    legacy: bool = True\n    icon = \"LangChain\"\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input\",\n            info=\"The input value to pass to the chain.\",\n            required=True,\n        ),\n        DropdownInput(\n            name=\"chain_type\",\n            display_name=\"Chain Type\",\n            info=\"Chain type to use.\",\n            options=[\"Stuff\", \"Map Reduce\", \"Refine\", \"Map Rerank\"],\n            value=\"Stuff\",\n            advanced=True,\n        ),\n        HandleInput(\n            name=\"llm\",\n            display_name=\"Language Model\",\n            input_types=[\"LanguageModel\"],\n            required=True,\n        ),\n        HandleInput(\n            name=\"retriever\",\n            display_name=\"Retriever\",\n            input_types=[\"Retriever\"],\n            required=True,\n        ),\n        HandleInput(\n            name=\"memory\",\n            display_name=\"Memory\",\n            input_types=[\"BaseChatMemory\"],\n        ),\n        BoolInput(\n            name=\"return_source_documents\",\n            display_name=\"Return Source Documents\",\n            value=False,\n        ),\n    ]\n\n    def invoke_chain(self) -> Message:\n        chain_type = self.chain_type.lower().replace(\" \", \"_\")\n        if self.memory:\n            self.memory.input_key = \"query\"\n            self.memory.output_key = \"result\"\n\n        runnable = RetrievalQA.from_chain_type(\n            llm=self.llm,\n            chain_type=chain_type,\n            retriever=self.retriever,\n            memory=self.memory,\n            # always include to help debugging\n            #\n            return_source_documents=True,\n        )\n\n        result = runnable.invoke(\n            {\"query\": self.input_value},\n            config={\"callbacks\": self.get_langchain_callbacks()},\n        )\n\n        source_docs = self.to_data(result.get(\"source_documents\", keys=[]))\n        result_str = str(result.get(\"result\", \"\"))\n        if self.return_source_documents and len(source_docs):\n            references_str = self.create_references_from_data(source_docs)\n            result_str = f\"{result_str}\\n{references_str}\"\n        # put the entire result to debug history, query and content\n        self.status = {**result, \"source_documents\": source_docs, \"output\": result_str}\n        return result_str\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "input_value": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "input_value",
        "value": "",
        "display_name": "Input",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The input value to pass to the chain.",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "return_source_documents": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "return_source_documents",
        "value": false,
        "display_name": "Return Source Documents",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      }
    },
    "description": "Chain for question-answering querying sources from a retriever.",
    "icon": "LangChain",
    "base_classes": [
      "Message"
    ],
    "display_name": "Retrieval QA",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Message"
        ],
        "selected": "Message",
        "name": "text",
        "display_name": "Text",
        "method": "invoke_chain",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "input_value",
          "llm",
          "retriever"
        ],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "input_value",
      "chain_type",
      "llm",
      "retriever",
      "memory",
      "return_source_documents"
    ],
    "beta": false,
    "legacy": true,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "NaturalLanguageTextSplitter": {
    "template": {
      "_type": "Component",
      "data_input": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "trace_as_input": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "data_input",
        "value": "",
        "display_name": "Input",
        "advanced": false,
        "input_types": [
          "Document",
          "Data"
        ],
        "dynamic": false,
        "info": "The text data to be split.",
        "title_case": false,
        "type": "other",
        "_input_type": "DataInput"
      },
      "chunk_overlap": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "chunk_overlap",
        "value": 200,
        "display_name": "Chunk Overlap",
        "advanced": false,
        "dynamic": false,
        "info": "The number of characters that overlap between consecutive chunks.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "chunk_size": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "chunk_size",
        "value": 1000,
        "display_name": "Chunk Size",
        "advanced": false,
        "dynamic": false,
        "info": "The maximum number of characters in each chunk after splitting.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from typing import Any\n\nfrom langchain_text_splitters import NLTKTextSplitter, TextSplitter\n\nfrom langflow.base.textsplitters.model import LCTextSplitterComponent\nfrom langflow.inputs import DataInput, IntInput, MessageTextInput\nfrom langflow.utils.util import unescape_string\n\n\nclass NaturalLanguageTextSplitterComponent(LCTextSplitterComponent):\n    display_name = \"Natural Language Text Splitter\"\n    description = \"Split text based on natural language boundaries, optimized for a specified language.\"\n    documentation = (\n        \"https://python.langchain.com/v0.1/docs/modules/data_connection/document_transformers/split_by_token/#nltk\"\n    )\n    name = \"NaturalLanguageTextSplitter\"\n    icon = \"LangChain\"\n    inputs = [\n        IntInput(\n            name=\"chunk_size\",\n            display_name=\"Chunk Size\",\n            info=\"The maximum number of characters in each chunk after splitting.\",\n            value=1000,\n        ),\n        IntInput(\n            name=\"chunk_overlap\",\n            display_name=\"Chunk Overlap\",\n            info=\"The number of characters that overlap between consecutive chunks.\",\n            value=200,\n        ),\n        DataInput(\n            name=\"data_input\",\n            display_name=\"Input\",\n            info=\"The text data to be split.\",\n            input_types=[\"Document\", \"Data\"],\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"separator\",\n            display_name=\"Separator\",\n            info='The character(s) to use as a delimiter when splitting text.\\nDefaults to \"\\\\n\\\\n\" if left empty.',\n        ),\n        MessageTextInput(\n            name=\"language\",\n            display_name=\"Language\",\n            info='The language of the text. Default is \"English\". '\n            \"Supports multiple languages for better text boundary recognition.\",\n        ),\n    ]\n\n    def get_data_input(self) -> Any:\n        return self.data_input\n\n    def build_text_splitter(self) -> TextSplitter:\n        separator = unescape_string(self.separator) if self.separator else \"\\n\\n\"\n        return NLTKTextSplitter(\n            language=self.language.lower() if self.language else \"english\",\n            separator=separator,\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n        )\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "language": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "language",
        "value": "",
        "display_name": "Language",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The language of the text. Default is \"English\". Supports multiple languages for better text boundary recognition.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "separator": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "separator",
        "value": "",
        "display_name": "Separator",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The character(s) to use as a delimiter when splitting text.\nDefaults to \"\\n\\n\" if left empty.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      }
    },
    "description": "Split text based on natural language boundaries, optimized for a specified language.",
    "icon": "LangChain",
    "base_classes": [
      "Data"
    ],
    "display_name": "Natural Language Text Splitter",
    "documentation": "https://python.langchain.com/v0.1/docs/modules/data_connection/document_transformers/split_by_token/#nltk",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "data",
        "display_name": "Data",
        "method": "transform_data",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "chunk_size",
      "chunk_overlap",
      "data_input",
      "separator",
      "language"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "RetrieverTool": {
    "template": {
      "_type": "CustomComponent",
      "retriever": {
        "type": "BaseRetriever",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": false,
        "fileTypes": [],
        "file_path": "",
        "name": "retriever",
        "display_name": "Retriever",
        "advanced": false,
        "input_types": [
          "Retriever"
        ],
        "dynamic": false,
        "info": "Retriever to interact with",
        "load_from_db": false,
        "title_case": false
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain_core.tools import create_retriever_tool\n\nfrom langflow.custom import CustomComponent\nfrom langflow.field_typing import BaseRetriever, Tool\n\n\nclass RetrieverToolComponent(CustomComponent):\n    display_name = \"RetrieverTool\"\n    description = \"Tool for interacting with retriever\"\n    name = \"RetrieverTool\"\n    legacy = True\n    icon = \"LangChain\"\n\n    def build_config(self):\n        return {\n            \"retriever\": {\n                \"display_name\": \"Retriever\",\n                \"info\": \"Retriever to interact with\",\n                \"type\": BaseRetriever,\n                \"input_types\": [\"Retriever\"],\n            },\n            \"name\": {\"display_name\": \"Name\", \"info\": \"Name of the tool\"},\n            \"description\": {\"display_name\": \"Description\", \"info\": \"Description of the tool\"},\n        }\n\n    def build(self, retriever: BaseRetriever, name: str, description: str, **kwargs) -> Tool:\n        _ = kwargs\n        return create_retriever_tool(\n            retriever=retriever,\n            name=name,\n            description=description,\n        )\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "description": {
        "type": "str",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": false,
        "fileTypes": [],
        "file_path": "",
        "name": "description",
        "display_name": "Description",
        "advanced": false,
        "dynamic": false,
        "info": "Description of the tool",
        "load_from_db": false,
        "title_case": false,
        "input_types": [
          "Text"
        ]
      },
      "name": {
        "type": "str",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": false,
        "fileTypes": [],
        "file_path": "",
        "name": "name",
        "display_name": "Name",
        "advanced": false,
        "dynamic": false,
        "info": "Name of the tool",
        "load_from_db": false,
        "title_case": false,
        "input_types": [
          "Text"
        ]
      }
    },
    "description": "Tool for interacting with retriever",
    "icon": "LangChain",
    "base_classes": [
      "BaseTool",
      "Generic",
      "object",
      "Runnable",
      "RunnableSerializable",
      "RunnableSerializable[Union[str, dict, ToolCall], Any]",
      "Serializable",
      "Tool"
    ],
    "display_name": "RetrieverTool",
    "documentation": "",
    "minimized": false,
    "custom_fields": {
      "retriever": null,
      "name": null,
      "description": null
    },
    "output_types": [
      "Tool"
    ],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Tool"
        ],
        "selected": "Tool",
        "name": "tool",
        "hidden": null,
        "display_name": "Tool",
        "method": null,
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": null,
        "allows_loop": false,
        "options": null,
        "tool_mode": true
      }
    ],
    "field_order": [],
    "beta": false,
    "legacy": true,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "OpenAIToolsAgent": {
    "template": {
      "_type": "Component",
      "chat_history": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "trace_as_input": true,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "chat_history",
        "value": "",
        "display_name": "Chat History",
        "advanced": true,
        "input_types": [
          "Data"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "DataInput"
      },
      "llm": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "llm",
        "value": "",
        "display_name": "Language Model",
        "advanced": false,
        "input_types": [
          "LanguageModel",
          "ToolEnabledLanguageModel"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "tools": {
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "tools",
        "value": "",
        "display_name": "Tools",
        "advanced": false,
        "input_types": [
          "Tool"
        ],
        "dynamic": false,
        "info": "These are the tools that the agent can use to help with tasks.",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "agent_description": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "agent_description",
        "value": "A helpful assistant with access to the following tools:",
        "display_name": "Agent Description [Deprecated]",
        "advanced": true,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The description of the agent. This is only used when in Tool Mode. Defaults to 'A helpful assistant with access to the following tools:' and tools are added dynamically. This feature is deprecated and will be removed in future versions.",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain.agents import create_openai_tools_agent\nfrom langchain_core.prompts import ChatPromptTemplate, HumanMessagePromptTemplate, PromptTemplate\n\nfrom langflow.base.agents.agent import LCToolsAgentComponent\nfrom langflow.inputs import MultilineInput\nfrom langflow.inputs.inputs import DataInput, HandleInput\nfrom langflow.schema import Data\n\n\nclass OpenAIToolsAgentComponent(LCToolsAgentComponent):\n    display_name: str = \"OpenAI Tools Agent\"\n    description: str = \"Agent that uses tools via openai-tools.\"\n    icon = \"LangChain\"\n    name = \"OpenAIToolsAgent\"\n\n    inputs = [\n        *LCToolsAgentComponent._base_inputs,\n        HandleInput(\n            name=\"llm\",\n            display_name=\"Language Model\",\n            input_types=[\"LanguageModel\", \"ToolEnabledLanguageModel\"],\n            required=True,\n        ),\n        MultilineInput(\n            name=\"system_prompt\",\n            display_name=\"System Prompt\",\n            info=\"System prompt for the agent.\",\n            value=\"You are a helpful assistant\",\n        ),\n        MultilineInput(\n            name=\"user_prompt\", display_name=\"Prompt\", info=\"This prompt must contain 'input' key.\", value=\"{input}\"\n        ),\n        DataInput(name=\"chat_history\", display_name=\"Chat History\", is_list=True, advanced=True),\n    ]\n\n    def get_chat_history_data(self) -> list[Data] | None:\n        return self.chat_history\n\n    def create_agent_runnable(self):\n        if \"input\" not in self.user_prompt:\n            msg = \"Prompt must contain 'input' key.\"\n            raise ValueError(msg)\n        messages = [\n            (\"system\", self.system_prompt),\n            (\"placeholder\", \"{chat_history}\"),\n            HumanMessagePromptTemplate(prompt=PromptTemplate(input_variables=[\"input\"], template=self.user_prompt)),\n            (\"placeholder\", \"{agent_scratchpad}\"),\n        ]\n        prompt = ChatPromptTemplate.from_messages(messages)\n        return create_openai_tools_agent(self.llm, self.tools, prompt)\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "handle_parsing_errors": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "handle_parsing_errors",
        "value": true,
        "display_name": "Handle Parse Errors",
        "advanced": true,
        "dynamic": false,
        "info": "Should the Agent fix errors when reading user input for better processing?",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "input_value": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "input_value",
        "value": "",
        "display_name": "Input",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The input provided by the user for the agent to process.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "max_iterations": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "max_iterations",
        "value": 15,
        "display_name": "Max Iterations",
        "advanced": true,
        "dynamic": false,
        "info": "The maximum number of attempts the agent can make to complete its task before it stops.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "system_prompt": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "system_prompt",
        "value": "You are a helpful assistant",
        "display_name": "System Prompt",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "System prompt for the agent.",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "user_prompt": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "user_prompt",
        "value": "{input}",
        "display_name": "Prompt",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "This prompt must contain 'input' key.",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "verbose": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "verbose",
        "value": true,
        "display_name": "Verbose",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      }
    },
    "description": "Agent that uses tools via openai-tools.",
    "icon": "LangChain",
    "base_classes": [
      "AgentExecutor",
      "Message"
    ],
    "display_name": "OpenAI Tools Agent",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "AgentExecutor"
        ],
        "selected": "AgentExecutor",
        "name": "agent",
        "hidden": true,
        "display_name": "Agent",
        "method": "build_agent",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": false
      },
      {
        "types": [
          "Message"
        ],
        "selected": "Message",
        "name": "response",
        "display_name": "Response",
        "method": "message_response",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "tools",
      "input_value",
      "handle_parsing_errors",
      "verbose",
      "max_iterations",
      "agent_description",
      "llm",
      "system_prompt",
      "user_prompt",
      "chat_history"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "SQLGenerator": {
    "template": {
      "_type": "Component",
      "db": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "db",
        "value": "",
        "display_name": "SQLDatabase",
        "advanced": false,
        "input_types": [
          "SQLDatabase"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "llm": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "llm",
        "value": "",
        "display_name": "Language Model",
        "advanced": false,
        "input_types": [
          "LanguageModel"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from typing import TYPE_CHECKING\n\nfrom langchain.chains import create_sql_query_chain\nfrom langchain_core.prompts import PromptTemplate\n\nfrom langflow.base.chains.model import LCChainComponent\nfrom langflow.field_typing import Message\nfrom langflow.inputs import HandleInput, IntInput, MultilineInput\nfrom langflow.template import Output\n\nif TYPE_CHECKING:\n    from langchain_core.runnables import Runnable\n\n\nclass SQLGeneratorComponent(LCChainComponent):\n    display_name = \"Natural Language to SQL\"\n    description = \"Generate SQL from natural language.\"\n    name = \"SQLGenerator\"\n    legacy: bool = True\n    icon = \"LangChain\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input\",\n            info=\"The input value to pass to the chain.\",\n            required=True,\n        ),\n        HandleInput(\n            name=\"llm\",\n            display_name=\"Language Model\",\n            input_types=[\"LanguageModel\"],\n            required=True,\n        ),\n        HandleInput(\n            name=\"db\",\n            display_name=\"SQLDatabase\",\n            input_types=[\"SQLDatabase\"],\n            required=True,\n        ),\n        IntInput(\n            name=\"top_k\",\n            display_name=\"Top K\",\n            info=\"The number of results per select statement to return.\",\n            value=5,\n        ),\n        MultilineInput(\n            name=\"prompt\",\n            display_name=\"Prompt\",\n            info=\"The prompt must contain `{question}`.\",\n        ),\n    ]\n\n    outputs = [Output(display_name=\"Message\", name=\"text\", method=\"invoke_chain\")]\n\n    def invoke_chain(self) -> Message:\n        prompt_template = PromptTemplate.from_template(template=self.prompt) if self.prompt else None\n\n        if self.top_k < 1:\n            msg = \"Top K must be greater than 0.\"\n            raise ValueError(msg)\n\n        if not prompt_template:\n            sql_query_chain = create_sql_query_chain(llm=self.llm, db=self.db, k=self.top_k)\n        else:\n            # Check if {question} is in the prompt\n            if \"{question}\" not in prompt_template.template or \"question\" not in prompt_template.input_variables:\n                msg = \"Prompt must contain `{question}` to be used with Natural Language to SQL.\"\n                raise ValueError(msg)\n            sql_query_chain = create_sql_query_chain(llm=self.llm, db=self.db, prompt=prompt_template, k=self.top_k)\n        query_writer: Runnable = sql_query_chain | {\"query\": lambda x: x.replace(\"SQLQuery:\", \"\").strip()}\n        response = query_writer.invoke(\n            {\"question\": self.input_value},\n            config={\"callbacks\": self.get_langchain_callbacks()},\n        )\n        query = response.get(\"query\")\n        self.status = query\n        return query\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "input_value": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "input_value",
        "value": "",
        "display_name": "Input",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The input value to pass to the chain.",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "prompt": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "prompt",
        "value": "",
        "display_name": "Prompt",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The prompt must contain `{question}`.",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "top_k": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "top_k",
        "value": 5,
        "display_name": "Top K",
        "advanced": false,
        "dynamic": false,
        "info": "The number of results per select statement to return.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      }
    },
    "description": "Generate SQL from natural language.",
    "icon": "LangChain",
    "base_classes": [
      "Message"
    ],
    "display_name": "Natural Language to SQL",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Message"
        ],
        "selected": "Message",
        "name": "text",
        "display_name": "Message",
        "method": "invoke_chain",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "input_value",
      "llm",
      "db",
      "top_k",
      "prompt"
    ],
    "beta": false,
    "legacy": true,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "LLMCheckerChain": {
    "template": {
      "_type": "Component",
      "llm": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "llm",
        "value": "",
        "display_name": "Language Model",
        "advanced": false,
        "input_types": [
          "LanguageModel"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain.chains import LLMCheckerChain\n\nfrom langflow.base.chains.model import LCChainComponent\nfrom langflow.field_typing import Message\nfrom langflow.inputs import HandleInput, MultilineInput\n\n\nclass LLMCheckerChainComponent(LCChainComponent):\n    display_name = \"LLMCheckerChain\"\n    description = \"Chain for question-answering with self-verification.\"\n    documentation = \"https://python.langchain.com/docs/modules/chains/additional/llm_checker\"\n    name = \"LLMCheckerChain\"\n    legacy: bool = True\n    icon = \"LangChain\"\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input\",\n            info=\"The input value to pass to the chain.\",\n            required=True,\n        ),\n        HandleInput(\n            name=\"llm\",\n            display_name=\"Language Model\",\n            input_types=[\"LanguageModel\"],\n            required=True,\n        ),\n    ]\n\n    def invoke_chain(self) -> Message:\n        chain = LLMCheckerChain.from_llm(llm=self.llm)\n        response = chain.invoke(\n            {chain.input_key: self.input_value},\n            config={\"callbacks\": self.get_langchain_callbacks()},\n        )\n        result = response.get(chain.output_key, \"\")\n        result = str(result)\n        self.status = result\n        return Message(text=result)\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "input_value": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "input_value",
        "value": "",
        "display_name": "Input",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The input value to pass to the chain.",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      }
    },
    "description": "Chain for question-answering with self-verification.",
    "icon": "LangChain",
    "base_classes": [
      "Message"
    ],
    "display_name": "LLMCheckerChain",
    "documentation": "https://python.langchain.com/docs/modules/chains/additional/llm_checker",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Message"
        ],
        "selected": "Message",
        "name": "text",
        "display_name": "Text",
        "method": "invoke_chain",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "input_value",
          "llm"
        ],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "input_value",
      "llm"
    ],
    "beta": false,
    "legacy": true,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "CSVAgent": {
    "template": {
      "_type": "Component",
      "llm": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "llm",
        "value": "",
        "display_name": "Language Model",
        "advanced": false,
        "input_types": [
          "LanguageModel"
        ],
        "dynamic": false,
        "info": "An LLM Model Object (It can be found in any LLM Component).",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "path": {
        "trace_as_metadata": true,
        "file_path": "",
        "fileTypes": [
          "csv"
        ],
        "temp_file": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "path",
        "value": "",
        "display_name": "File Path",
        "advanced": false,
        "input_types": [
          "str",
          "Message"
        ],
        "dynamic": false,
        "info": "A CSV File or File Path.",
        "title_case": false,
        "type": "file",
        "_input_type": "FileInput"
      },
      "agent_description": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "agent_description",
        "value": "A helpful assistant with access to the following tools:",
        "display_name": "Agent Description [Deprecated]",
        "advanced": true,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The description of the agent. This is only used when in Tool Mode. Defaults to 'A helpful assistant with access to the following tools:' and tools are added dynamically. This feature is deprecated and will be removed in future versions.",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "agent_type": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "zero-shot-react-description",
          "openai-functions",
          "openai-tools"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "agent_type",
        "value": "openai-tools",
        "display_name": "Agent Type",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain_experimental.agents.agent_toolkits.csv.base import create_csv_agent\n\nfrom langflow.base.agents.agent import LCAgentComponent\nfrom langflow.field_typing import AgentExecutor\nfrom langflow.inputs import DropdownInput, FileInput, HandleInput\nfrom langflow.inputs.inputs import DictInput, MessageTextInput\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass CSVAgentComponent(LCAgentComponent):\n    display_name = \"CSVAgent\"\n    description = \"Construct a CSV agent from a CSV and tools.\"\n    documentation = \"https://python.langchain.com/docs/modules/agents/toolkits/csv\"\n    name = \"CSVAgent\"\n    icon = \"LangChain\"\n\n    inputs = [\n        *LCAgentComponent._base_inputs,\n        HandleInput(\n            name=\"llm\",\n            display_name=\"Language Model\",\n            input_types=[\"LanguageModel\"],\n            required=True,\n            info=\"An LLM Model Object (It can be found in any LLM Component).\",\n        ),\n        FileInput(\n            name=\"path\",\n            display_name=\"File Path\",\n            file_types=[\"csv\"],\n            input_types=[\"str\", \"Message\"],\n            required=True,\n            info=\"A CSV File or File Path.\",\n        ),\n        DropdownInput(\n            name=\"agent_type\",\n            display_name=\"Agent Type\",\n            advanced=True,\n            options=[\"zero-shot-react-description\", \"openai-functions\", \"openai-tools\"],\n            value=\"openai-tools\",\n        ),\n        MessageTextInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Text to be passed as input and extract info from the CSV File.\",\n            required=True,\n        ),\n        DictInput(\n            name=\"pandas_kwargs\",\n            display_name=\"Pandas Kwargs\",\n            info=\"Pandas Kwargs to be passed to the agent.\",\n            advanced=True,\n            is_list=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Response\", name=\"response\", method=\"build_agent_response\"),\n        Output(display_name=\"Agent\", name=\"agent\", method=\"build_agent\", hidden=True, tool_mode=False),\n    ]\n\n    def _path(self) -> str:\n        if isinstance(self.path, Message) and isinstance(self.path.text, str):\n            return self.path.text\n        return self.path\n\n    def build_agent_response(self) -> Message:\n        agent_kwargs = {\n            \"verbose\": self.verbose,\n            \"allow_dangerous_code\": True,\n        }\n\n        agent_csv = create_csv_agent(\n            llm=self.llm,\n            path=self._path(),\n            agent_type=self.agent_type,\n            handle_parsing_errors=self.handle_parsing_errors,\n            pandas_kwargs=self.pandas_kwargs,\n            **agent_kwargs,\n        )\n\n        result = agent_csv.invoke({\"input\": self.input_value})\n        return Message(text=str(result[\"output\"]))\n\n    def build_agent(self) -> AgentExecutor:\n        agent_kwargs = {\n            \"verbose\": self.verbose,\n            \"allow_dangerous_code\": True,\n        }\n\n        agent_csv = create_csv_agent(\n            llm=self.llm,\n            path=self._path(),\n            agent_type=self.agent_type,\n            handle_parsing_errors=self.handle_parsing_errors,\n            pandas_kwargs=self.pandas_kwargs,\n            **agent_kwargs,\n        )\n\n        self.status = Message(text=str(agent_csv))\n\n        return agent_csv\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "handle_parsing_errors": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "handle_parsing_errors",
        "value": true,
        "display_name": "Handle Parse Errors",
        "advanced": true,
        "dynamic": false,
        "info": "Should the Agent fix errors when reading user input for better processing?",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "input_value": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "input_value",
        "value": "",
        "display_name": "Text",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Text to be passed as input and extract info from the CSV File.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "max_iterations": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "max_iterations",
        "value": 15,
        "display_name": "Max Iterations",
        "advanced": true,
        "dynamic": false,
        "info": "The maximum number of attempts the agent can make to complete its task before it stops.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "pandas_kwargs": {
        "tool_mode": false,
        "trace_as_input": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "pandas_kwargs",
        "value": {},
        "display_name": "Pandas Kwargs",
        "advanced": true,
        "dynamic": false,
        "info": "Pandas Kwargs to be passed to the agent.",
        "title_case": false,
        "type": "dict",
        "_input_type": "DictInput"
      },
      "verbose": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "verbose",
        "value": true,
        "display_name": "Verbose",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      }
    },
    "description": "Construct a CSV agent from a CSV and tools.",
    "icon": "LangChain",
    "base_classes": [
      "AgentExecutor",
      "Message"
    ],
    "display_name": "CSVAgent",
    "documentation": "https://python.langchain.com/docs/modules/agents/toolkits/csv",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Message"
        ],
        "selected": "Message",
        "name": "response",
        "display_name": "Response",
        "method": "build_agent_response",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "AgentExecutor"
        ],
        "selected": "AgentExecutor",
        "name": "agent",
        "hidden": true,
        "display_name": "Agent",
        "method": "build_agent",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": false
      }
    ],
    "field_order": [
      "input_value",
      "handle_parsing_errors",
      "verbose",
      "max_iterations",
      "agent_description",
      "llm",
      "path",
      "agent_type",
      "input_value",
      "pandas_kwargs"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "SelfQueryRetriever": {
    "template": {
      "_type": "Component",
      "attribute_infos": {
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "attribute_infos",
        "value": "",
        "display_name": "Metadata Field Info",
        "advanced": false,
        "input_types": [
          "Data"
        ],
        "dynamic": false,
        "info": "Metadata Field Info to be passed as input.",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "llm": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "llm",
        "value": "",
        "display_name": "LLM",
        "advanced": false,
        "input_types": [
          "LanguageModel"
        ],
        "dynamic": false,
        "info": "LLM to be passed as input.",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "query": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "query",
        "value": "",
        "display_name": "Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Query to be passed as input.",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "vectorstore": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "vectorstore",
        "value": "",
        "display_name": "Vector Store",
        "advanced": false,
        "input_types": [
          "VectorStore"
        ],
        "dynamic": false,
        "info": "Vector Store to be passed as input.",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain.chains.query_constructor.base import AttributeInfo\nfrom langchain.retrievers.self_query.base import SelfQueryRetriever\n\nfrom langflow.custom import Component\nfrom langflow.inputs import HandleInput, MessageTextInput\nfrom langflow.io import Output\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\n\n\nclass SelfQueryRetrieverComponent(Component):\n    display_name = \"Self Query Retriever\"\n    description = \"Retriever that uses a vector store and an LLM to generate the vector store queries.\"\n    name = \"SelfQueryRetriever\"\n    icon = \"LangChain\"\n    legacy: bool = True\n\n    inputs = [\n        HandleInput(\n            name=\"query\",\n            display_name=\"Query\",\n            info=\"Query to be passed as input.\",\n            input_types=[\"Message\"],\n        ),\n        HandleInput(\n            name=\"vectorstore\",\n            display_name=\"Vector Store\",\n            info=\"Vector Store to be passed as input.\",\n            input_types=[\"VectorStore\"],\n        ),\n        HandleInput(\n            name=\"attribute_infos\",\n            display_name=\"Metadata Field Info\",\n            info=\"Metadata Field Info to be passed as input.\",\n            input_types=[\"Data\"],\n            is_list=True,\n        ),\n        MessageTextInput(\n            name=\"document_content_description\",\n            display_name=\"Document Content Description\",\n            info=\"Document Content Description to be passed as input.\",\n        ),\n        HandleInput(\n            name=\"llm\",\n            display_name=\"LLM\",\n            info=\"LLM to be passed as input.\",\n            input_types=[\"LanguageModel\"],\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Retrieved Documents\",\n            name=\"documents\",\n            method=\"retrieve_documents\",\n        ),\n    ]\n\n    def retrieve_documents(self) -> list[Data]:\n        metadata_field_infos = [AttributeInfo(**value.data) for value in self.attribute_infos]\n        self_query_retriever = SelfQueryRetriever.from_llm(\n            llm=self.llm,\n            vectorstore=self.vectorstore,\n            document_contents=self.document_content_description,\n            metadata_field_info=metadata_field_infos,\n            enable_limit=True,\n        )\n\n        if isinstance(self.query, Message):\n            input_text = self.query.text\n        elif isinstance(self.query, str):\n            input_text = self.query\n        else:\n            msg = f\"Query type {type(self.query)} not supported.\"\n            raise TypeError(msg)\n\n        documents = self_query_retriever.invoke(input=input_text, config={\"callbacks\": self.get_langchain_callbacks()})\n        data = [Data.from_document(document) for document in documents]\n        self.status = data\n        return data\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "document_content_description": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "document_content_description",
        "value": "",
        "display_name": "Document Content Description",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Document Content Description to be passed as input.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      }
    },
    "description": "Retriever that uses a vector store and an LLM to generate the vector store queries.",
    "icon": "LangChain",
    "base_classes": [
      "Data"
    ],
    "display_name": "Self Query Retriever",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "documents",
        "display_name": "Retrieved Documents",
        "method": "retrieve_documents",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "query",
      "vectorstore",
      "attribute_infos",
      "document_content_description",
      "llm"
    ],
    "beta": false,
    "legacy": true,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "HtmlLinkExtractor": {
    "template": {
      "_type": "Component",
      "data_input": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "trace_as_input": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "data_input",
        "value": "",
        "display_name": "Input",
        "advanced": false,
        "input_types": [
          "Document",
          "Data"
        ],
        "dynamic": false,
        "info": "The texts from which to extract links.",
        "title_case": false,
        "type": "other",
        "_input_type": "DataInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from typing import Any\n\nfrom langchain_community.graph_vectorstores.extractors import HtmlLinkExtractor, LinkExtractorTransformer\nfrom langchain_core.documents import BaseDocumentTransformer\n\nfrom langflow.base.document_transformers.model import LCDocumentTransformerComponent\nfrom langflow.inputs import BoolInput, DataInput, StrInput\n\n\nclass HtmlLinkExtractorComponent(LCDocumentTransformerComponent):\n    display_name = \"HTML Link Extractor\"\n    description = \"Extract hyperlinks from HTML content.\"\n    documentation = \"https://python.langchain.com/v0.2/api_reference/community/graph_vectorstores/langchain_community.graph_vectorstores.extractors.html_link_extractor.HtmlLinkExtractor.html\"\n    name = \"HtmlLinkExtractor\"\n    icon = \"LangChain\"\n\n    inputs = [\n        StrInput(name=\"kind\", display_name=\"Kind of edge\", value=\"hyperlink\", required=False),\n        BoolInput(name=\"drop_fragments\", display_name=\"Drop URL fragments\", value=True, required=False),\n        DataInput(\n            name=\"data_input\",\n            display_name=\"Input\",\n            info=\"The texts from which to extract links.\",\n            input_types=[\"Document\", \"Data\"],\n            required=True,\n        ),\n    ]\n\n    def get_data_input(self) -> Any:\n        return self.data_input\n\n    def build_document_transformer(self) -> BaseDocumentTransformer:\n        return LinkExtractorTransformer(\n            [HtmlLinkExtractor(kind=self.kind, drop_fragments=self.drop_fragments).as_document_extractor()]\n        )\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "drop_fragments": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "drop_fragments",
        "value": true,
        "display_name": "Drop URL fragments",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "kind": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "kind",
        "value": "hyperlink",
        "display_name": "Kind of edge",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      }
    },
    "description": "Extract hyperlinks from HTML content.",
    "icon": "LangChain",
    "base_classes": [
      "Data"
    ],
    "display_name": "HTML Link Extractor",
    "documentation": "https://python.langchain.com/v0.2/api_reference/community/graph_vectorstores/langchain_community.graph_vectorstores.extractors.html_link_extractor.HtmlLinkExtractor.html",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "data",
        "display_name": "Data",
        "method": "transform_data",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "kind",
      "drop_fragments",
      "data_input"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "SQLDatabase": {
    "template": {
      "_type": "Component",
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain_community.utilities.sql_database import SQLDatabase\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.pool import StaticPool\n\nfrom langflow.custom import Component\nfrom langflow.io import (\n    Output,\n    StrInput,\n)\n\n\nclass SQLDatabaseComponent(Component):\n    display_name = \"SQLDatabase\"\n    description = \"SQL Database\"\n    name = \"SQLDatabase\"\n    icon = \"LangChain\"\n\n    inputs = [\n        StrInput(name=\"uri\", display_name=\"URI\", info=\"URI to the database.\", required=True),\n    ]\n\n    outputs = [\n        Output(display_name=\"SQLDatabase\", name=\"SQLDatabase\", method=\"build_sqldatabase\"),\n    ]\n\n    def clean_up_uri(self, uri: str) -> str:\n        if uri.startswith(\"postgres://\"):\n            uri = uri.replace(\"postgres://\", \"postgresql://\")\n        return uri.strip()\n\n    def build_sqldatabase(self) -> SQLDatabase:\n        uri = self.clean_up_uri(self.uri)\n        # Create an engine using SQLAlchemy with StaticPool\n        engine = create_engine(uri, poolclass=StaticPool)\n        return SQLDatabase(engine)\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "uri": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "uri",
        "value": "",
        "display_name": "URI",
        "advanced": false,
        "dynamic": false,
        "info": "URI to the database.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      }
    },
    "description": "SQL Database",
    "icon": "LangChain",
    "base_classes": [
      "SQLDatabase"
    ],
    "display_name": "SQLDatabase",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "SQLDatabase"
        ],
        "selected": "SQLDatabase",
        "name": "SQLDatabase",
        "display_name": "SQLDatabase",
        "method": "build_sqldatabase",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "uri"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "VectorStoreInfo": {
    "template": {
      "_type": "Component",
      "input_vectorstore": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "input_vectorstore",
        "value": "",
        "display_name": "Vector Store",
        "advanced": false,
        "input_types": [
          "VectorStore"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain.agents.agent_toolkits.vectorstore.toolkit import VectorStoreInfo\n\nfrom langflow.custom import Component\nfrom langflow.inputs import HandleInput, MessageTextInput, MultilineInput\nfrom langflow.template import Output\n\n\nclass VectorStoreInfoComponent(Component):\n    display_name = \"VectorStoreInfo\"\n    description = \"Information about a VectorStore\"\n    name = \"VectorStoreInfo\"\n    legacy: bool = True\n    icon = \"LangChain\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"vectorstore_name\",\n            display_name=\"Name\",\n            info=\"Name of the VectorStore\",\n            required=True,\n        ),\n        MultilineInput(\n            name=\"vectorstore_description\",\n            display_name=\"Description\",\n            info=\"Description of the VectorStore\",\n            required=True,\n        ),\n        HandleInput(\n            name=\"input_vectorstore\",\n            display_name=\"Vector Store\",\n            input_types=[\"VectorStore\"],\n            required=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Vector Store Info\", name=\"info\", method=\"build_info\"),\n    ]\n\n    def build_info(self) -> VectorStoreInfo:\n        self.status = {\n            \"name\": self.vectorstore_name,\n            \"description\": self.vectorstore_description,\n        }\n        return VectorStoreInfo(\n            vectorstore=self.input_vectorstore,\n            description=self.vectorstore_description,\n            name=self.vectorstore_name,\n        )\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "vectorstore_description": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "vectorstore_description",
        "value": "",
        "display_name": "Description",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Description of the VectorStore",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "vectorstore_name": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "vectorstore_name",
        "value": "",
        "display_name": "Name",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Name of the VectorStore",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      }
    },
    "description": "Information about a VectorStore",
    "icon": "LangChain",
    "base_classes": [
      "VectorStoreInfo"
    ],
    "display_name": "VectorStoreInfo",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "VectorStoreInfo"
        ],
        "selected": "VectorStoreInfo",
        "name": "info",
        "display_name": "Vector Store Info",
        "method": "build_info",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "vectorstore_name",
      "vectorstore_description",
      "input_vectorstore"
    ],
    "beta": false,
    "legacy": true,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "XMLAgent": {
    "template": {
      "_type": "Component",
      "chat_history": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "trace_as_input": true,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "chat_history",
        "value": "",
        "display_name": "Chat History",
        "advanced": true,
        "input_types": [
          "Data"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "DataInput"
      },
      "llm": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "llm",
        "value": "",
        "display_name": "Language Model",
        "advanced": false,
        "input_types": [
          "LanguageModel"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "tools": {
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "tools",
        "value": "",
        "display_name": "Tools",
        "advanced": false,
        "input_types": [
          "Tool"
        ],
        "dynamic": false,
        "info": "These are the tools that the agent can use to help with tasks.",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "agent_description": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "agent_description",
        "value": "A helpful assistant with access to the following tools:",
        "display_name": "Agent Description [Deprecated]",
        "advanced": true,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The description of the agent. This is only used when in Tool Mode. Defaults to 'A helpful assistant with access to the following tools:' and tools are added dynamically. This feature is deprecated and will be removed in future versions.",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain.agents import create_xml_agent\nfrom langchain_core.prompts import ChatPromptTemplate, HumanMessagePromptTemplate, PromptTemplate\n\nfrom langflow.base.agents.agent import LCToolsAgentComponent\nfrom langflow.inputs import MultilineInput\nfrom langflow.inputs.inputs import DataInput, HandleInput\nfrom langflow.schema import Data\n\n\nclass XMLAgentComponent(LCToolsAgentComponent):\n    display_name: str = \"XML Agent\"\n    description: str = \"Agent that uses tools formatting instructions as xml to the Language Model.\"\n    icon = \"LangChain\"\n    beta = True\n    name = \"XMLAgent\"\n    inputs = [\n        *LCToolsAgentComponent._base_inputs,\n        HandleInput(name=\"llm\", display_name=\"Language Model\", input_types=[\"LanguageModel\"], required=True),\n        DataInput(name=\"chat_history\", display_name=\"Chat History\", is_list=True, advanced=True),\n        MultilineInput(\n            name=\"system_prompt\",\n            display_name=\"System Prompt\",\n            info=\"System prompt for the agent.\",\n            value=\"\"\"You are a helpful assistant. Help the user answer any questions.\n\nYou have access to the following tools:\n\n{tools}\n\nIn order to use a tool, you can use <tool></tool> and <tool_input></tool_input> tags. You will then get back a response in the form <observation></observation>\n\nFor example, if you have a tool called 'search' that could run a google search, in order to search for the weather in SF you would respond:\n\n<tool>search</tool><tool_input>weather in SF</tool_input>\n\n<observation>64 degrees</observation>\n\nWhen you are done, respond with a final answer between <final_answer></final_answer>. For example:\n\n<final_answer>The weather in SF is 64 degrees</final_answer>\n\nBegin!\n\nQuestion: {input}\n\n{agent_scratchpad}\n            \"\"\",  # noqa: E501\n        ),\n        MultilineInput(\n            name=\"user_prompt\", display_name=\"Prompt\", info=\"This prompt must contain 'input' key.\", value=\"{input}\"\n        ),\n    ]\n\n    def get_chat_history_data(self) -> list[Data] | None:\n        return self.chat_history\n\n    def create_agent_runnable(self):\n        if \"input\" not in self.user_prompt:\n            msg = \"Prompt must contain 'input' key.\"\n            raise ValueError(msg)\n        messages = [\n            (\"system\", self.system_prompt),\n            (\"placeholder\", \"{chat_history}\"),\n            HumanMessagePromptTemplate(prompt=PromptTemplate(input_variables=[\"input\"], template=self.user_prompt)),\n            (\"ai\", \"{agent_scratchpad}\"),\n        ]\n        prompt = ChatPromptTemplate.from_messages(messages)\n        return create_xml_agent(self.llm, self.tools, prompt)\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "handle_parsing_errors": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "handle_parsing_errors",
        "value": true,
        "display_name": "Handle Parse Errors",
        "advanced": true,
        "dynamic": false,
        "info": "Should the Agent fix errors when reading user input for better processing?",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "input_value": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "input_value",
        "value": "",
        "display_name": "Input",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The input provided by the user for the agent to process.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "max_iterations": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "max_iterations",
        "value": 15,
        "display_name": "Max Iterations",
        "advanced": true,
        "dynamic": false,
        "info": "The maximum number of attempts the agent can make to complete its task before it stops.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "system_prompt": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "system_prompt",
        "value": "You are a helpful assistant. Help the user answer any questions.\n\nYou have access to the following tools:\n\n{tools}\n\nIn order to use a tool, you can use <tool></tool> and <tool_input></tool_input> tags. You will then get back a response in the form <observation></observation>\n\nFor example, if you have a tool called 'search' that could run a google search, in order to search for the weather in SF you would respond:\n\n<tool>search</tool><tool_input>weather in SF</tool_input>\n\n<observation>64 degrees</observation>\n\nWhen you are done, respond with a final answer between <final_answer></final_answer>. For example:\n\n<final_answer>The weather in SF is 64 degrees</final_answer>\n\nBegin!\n\nQuestion: {input}\n\n{agent_scratchpad}\n            ",
        "display_name": "System Prompt",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "System prompt for the agent.",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "user_prompt": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "user_prompt",
        "value": "{input}",
        "display_name": "Prompt",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "This prompt must contain 'input' key.",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "verbose": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "verbose",
        "value": true,
        "display_name": "Verbose",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      }
    },
    "description": "Agent that uses tools formatting instructions as xml to the Language Model.",
    "icon": "LangChain",
    "base_classes": [
      "AgentExecutor",
      "Message"
    ],
    "display_name": "XML Agent",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "AgentExecutor"
        ],
        "selected": "AgentExecutor",
        "name": "agent",
        "hidden": true,
        "display_name": "Agent",
        "method": "build_agent",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": false
      },
      {
        "types": [
          "Message"
        ],
        "selected": "Message",
        "name": "response",
        "display_name": "Response",
        "method": "message_response",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "tools",
      "input_value",
      "handle_parsing_errors",
      "verbose",
      "max_iterations",
      "agent_description",
      "llm",
      "chat_history",
      "system_prompt",
      "user_prompt"
    ],
    "beta": true,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "VectorStoreRouterAgent": {
    "template": {
      "_type": "Component",
      "llm": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "llm",
        "value": "",
        "display_name": "Language Model",
        "advanced": false,
        "input_types": [
          "LanguageModel"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "vectorstores": {
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "vectorstores",
        "value": "",
        "display_name": "Vector Stores",
        "advanced": false,
        "input_types": [
          "VectorStoreInfo"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "agent_description": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "agent_description",
        "value": "A helpful assistant with access to the following tools:",
        "display_name": "Agent Description [Deprecated]",
        "advanced": true,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The description of the agent. This is only used when in Tool Mode. Defaults to 'A helpful assistant with access to the following tools:' and tools are added dynamically. This feature is deprecated and will be removed in future versions.",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain.agents import AgentExecutor, create_vectorstore_router_agent\nfrom langchain.agents.agent_toolkits.vectorstore.toolkit import VectorStoreRouterToolkit\n\nfrom langflow.base.agents.agent import LCAgentComponent\nfrom langflow.inputs import HandleInput\n\n\nclass VectorStoreRouterAgentComponent(LCAgentComponent):\n    display_name = \"VectorStoreRouterAgent\"\n    description = \"Construct an agent from a Vector Store Router.\"\n    name = \"VectorStoreRouterAgent\"\n    legacy: bool = True\n\n    inputs = [\n        *LCAgentComponent._base_inputs,\n        HandleInput(\n            name=\"llm\",\n            display_name=\"Language Model\",\n            input_types=[\"LanguageModel\"],\n            required=True,\n        ),\n        HandleInput(\n            name=\"vectorstores\",\n            display_name=\"Vector Stores\",\n            input_types=[\"VectorStoreInfo\"],\n            is_list=True,\n            required=True,\n        ),\n    ]\n\n    def build_agent(self) -> AgentExecutor:\n        toolkit = VectorStoreRouterToolkit(vectorstores=self.vectorstores, llm=self.llm)\n        return create_vectorstore_router_agent(llm=self.llm, toolkit=toolkit, **self.get_agent_kwargs())\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "handle_parsing_errors": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "handle_parsing_errors",
        "value": true,
        "display_name": "Handle Parse Errors",
        "advanced": true,
        "dynamic": false,
        "info": "Should the Agent fix errors when reading user input for better processing?",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "input_value": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "input_value",
        "value": "",
        "display_name": "Input",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The input provided by the user for the agent to process.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "max_iterations": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "max_iterations",
        "value": 15,
        "display_name": "Max Iterations",
        "advanced": true,
        "dynamic": false,
        "info": "The maximum number of attempts the agent can make to complete its task before it stops.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "verbose": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "verbose",
        "value": true,
        "display_name": "Verbose",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      }
    },
    "description": "Construct an agent from a Vector Store Router.",
    "base_classes": [
      "AgentExecutor",
      "Message"
    ],
    "display_name": "VectorStoreRouterAgent",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "AgentExecutor"
        ],
        "selected": "AgentExecutor",
        "name": "agent",
        "hidden": true,
        "display_name": "Agent",
        "method": "build_agent",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "llm",
          "vectorstores"
        ],
        "allows_loop": false,
        "tool_mode": false
      },
      {
        "types": [
          "Message"
        ],
        "selected": "Message",
        "name": "response",
        "display_name": "Response",
        "method": "message_response",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "input_value",
      "handle_parsing_errors",
      "verbose",
      "max_iterations",
      "agent_description",
      "llm",
      "vectorstores"
    ],
    "beta": false,
    "legacy": true,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "RunnableExecutor": {
    "template": {
      "_type": "Component",
      "runnable": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "runnable",
        "value": "",
        "display_name": "Agent Executor",
        "advanced": false,
        "input_types": [
          "Chain",
          "AgentExecutor",
          "Agent",
          "Runnable"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain.agents import AgentExecutor\n\nfrom langflow.custom import Component\nfrom langflow.inputs import BoolInput, HandleInput, MessageTextInput\nfrom langflow.schema.message import Message\nfrom langflow.template import Output\n\n\nclass RunnableExecComponent(Component):\n    description = \"Execute a runnable. It will try to guess the input and output keys.\"\n    display_name = \"Runnable Executor\"\n    name = \"RunnableExecutor\"\n    beta: bool = True\n    icon = \"LangChain\"\n\n    inputs = [\n        MessageTextInput(name=\"input_value\", display_name=\"Input\", required=True),\n        HandleInput(\n            name=\"runnable\",\n            display_name=\"Agent Executor\",\n            input_types=[\"Chain\", \"AgentExecutor\", \"Agent\", \"Runnable\"],\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"input_key\",\n            display_name=\"Input Key\",\n            value=\"input\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"output_key\",\n            display_name=\"Output Key\",\n            value=\"output\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"use_stream\",\n            display_name=\"Stream\",\n            value=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Message\",\n            name=\"text\",\n            method=\"build_executor\",\n        ),\n    ]\n\n    def get_output(self, result, input_key, output_key):\n        \"\"\"Retrieves the output value from the given result dictionary based on the specified input and output keys.\n\n        Args:\n            result (dict): The result dictionary containing the output value.\n            input_key (str): The key used to retrieve the input value from the result dictionary.\n            output_key (str): The key used to retrieve the output value from the result dictionary.\n\n        Returns:\n            tuple: A tuple containing the output value and the status message.\n\n        \"\"\"\n        possible_output_keys = [\"answer\", \"response\", \"output\", \"result\", \"text\"]\n        status = \"\"\n        result_value = None\n\n        if output_key in result:\n            result_value = result.get(output_key)\n        elif len(result) == 2 and input_key in result:  # noqa: PLR2004\n            # get the other key from the result dict\n            other_key = next(k for k in result if k != input_key)\n            if other_key == output_key:\n                result_value = result.get(output_key)\n            else:\n                status += f\"Warning: The output key is not '{output_key}'. The output key is '{other_key}'.\"\n                result_value = result.get(other_key)\n        elif len(result) == 1:\n            result_value = next(iter(result.values()))\n        elif any(k in result for k in possible_output_keys):\n            for key in possible_output_keys:\n                if key in result:\n                    result_value = result.get(key)\n                    status += f\"Output key: '{key}'.\"\n                    break\n            if result_value is None:\n                result_value = result\n                status += f\"Warning: The output key is not '{output_key}'.\"\n        else:\n            result_value = result\n            status += f\"Warning: The output key is not '{output_key}'.\"\n\n        return result_value, status\n\n    def get_input_dict(self, runnable, input_key, input_value):\n        \"\"\"Returns a dictionary containing the input key-value pair for the given runnable.\n\n        Args:\n            runnable: The runnable object.\n            input_key: The key for the input value.\n            input_value: The value for the input key.\n\n        Returns:\n            input_dict: A dictionary containing the input key-value pair.\n            status: A status message indicating if the input key is not in the runnable's input keys.\n        \"\"\"\n        input_dict = {}\n        status = \"\"\n        if hasattr(runnable, \"input_keys\"):\n            # Check if input_key is in the runnable's input_keys\n            if input_key in runnable.input_keys:\n                input_dict[input_key] = input_value\n            else:\n                input_dict = dict.fromkeys(runnable.input_keys, input_value)\n                status = f\"Warning: The input key is not '{input_key}'. The input key is '{runnable.input_keys}'.\"\n        return input_dict, status\n\n    async def build_executor(self) -> Message:\n        input_dict, status = self.get_input_dict(self.runnable, self.input_key, self.input_value)\n        if not isinstance(self.runnable, AgentExecutor):\n            msg = \"The runnable must be an AgentExecutor\"\n            raise TypeError(msg)\n\n        if self.use_stream:\n            return self.astream_events(input_dict)\n        result = await self.runnable.ainvoke(input_dict)\n        result_value, status_ = self.get_output(result, self.input_key, self.output_key)\n        status += status_\n        status += f\"\\n\\nOutput: {result_value}\\n\\nRaw Output: {result}\"\n        self.status = status\n        return result_value\n\n    async def astream_events(self, runnable_input):\n        async for event in self.runnable.astream_events(runnable_input, version=\"v1\"):\n            if event.get(\"event\") != \"on_chat_model_stream\":\n                continue\n\n            yield event.get(\"data\").get(\"chunk\")\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "input_key": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "input_key",
        "value": "input",
        "display_name": "Input Key",
        "advanced": true,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "input_value": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "input_value",
        "value": "",
        "display_name": "Input",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "output_key": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "output_key",
        "value": "output",
        "display_name": "Output Key",
        "advanced": true,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "use_stream": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "use_stream",
        "value": false,
        "display_name": "Stream",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      }
    },
    "description": "Execute a runnable. It will try to guess the input and output keys.",
    "icon": "LangChain",
    "base_classes": [
      "Message"
    ],
    "display_name": "Runnable Executor",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Message"
        ],
        "selected": "Message",
        "name": "text",
        "display_name": "Message",
        "method": "build_executor",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "input_value",
      "runnable",
      "input_key",
      "output_key",
      "use_stream"
    ],
    "beta": true,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "SemanticTextSplitter": {
    "template": {
      "_type": "Component",
      "data_inputs": {
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "data_inputs",
        "value": "",
        "display_name": "Data Inputs",
        "advanced": false,
        "input_types": [
          "Data"
        ],
        "dynamic": false,
        "info": "List of Data objects containing text and metadata to split.",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "embeddings": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "embeddings",
        "value": "",
        "display_name": "Embeddings",
        "advanced": false,
        "input_types": [
          "Embeddings"
        ],
        "dynamic": false,
        "info": "Embeddings model to use for semantic similarity. Required.",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "breakpoint_threshold_amount": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "breakpoint_threshold_amount",
        "value": 0.5,
        "display_name": "Breakpoint Threshold Amount",
        "advanced": false,
        "dynamic": false,
        "info": "Numerical amount for the breakpoint threshold.",
        "title_case": false,
        "type": "float",
        "_input_type": "FloatInput"
      },
      "breakpoint_threshold_type": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "percentile",
          "standard_deviation",
          "interquartile"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "breakpoint_threshold_type",
        "value": "percentile",
        "display_name": "Breakpoint Threshold Type",
        "advanced": false,
        "dynamic": false,
        "info": "Method to determine breakpoints. Options: 'percentile', 'standard_deviation', 'interquartile'. Defaults to 'percentile'.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "buffer_size": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "buffer_size",
        "value": 0,
        "display_name": "Buffer Size",
        "advanced": true,
        "dynamic": false,
        "info": "Size of the buffer.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain.docstore.document import Document\nfrom langchain_experimental.text_splitter import SemanticChunker\n\nfrom langflow.base.textsplitters.model import LCTextSplitterComponent\nfrom langflow.io import (\n    DropdownInput,\n    FloatInput,\n    HandleInput,\n    IntInput,\n    MessageTextInput,\n    Output,\n)\nfrom langflow.schema import Data\n\n\nclass SemanticTextSplitterComponent(LCTextSplitterComponent):\n    \"\"\"Split text into semantically meaningful chunks using semantic similarity.\"\"\"\n\n    display_name: str = \"Semantic Text Splitter\"\n    name: str = \"SemanticTextSplitter\"\n    description: str = \"Split text into semantically meaningful chunks using semantic similarity.\"\n    documentation = \"https://python.langchain.com/docs/how_to/semantic-chunker/\"\n    beta = True  # this component is beta because it is imported from langchain_experimental\n    icon = \"LangChain\"\n\n    inputs = [\n        HandleInput(\n            name=\"data_inputs\",\n            display_name=\"Data Inputs\",\n            info=\"List of Data objects containing text and metadata to split.\",\n            input_types=[\"Data\"],\n            is_list=True,\n            required=True,\n        ),\n        HandleInput(\n            name=\"embeddings\",\n            display_name=\"Embeddings\",\n            info=\"Embeddings model to use for semantic similarity. Required.\",\n            input_types=[\"Embeddings\"],\n            is_list=False,\n            required=True,\n        ),\n        DropdownInput(\n            name=\"breakpoint_threshold_type\",\n            display_name=\"Breakpoint Threshold Type\",\n            info=(\n                \"Method to determine breakpoints. Options: 'percentile', \"\n                \"'standard_deviation', 'interquartile'. Defaults to 'percentile'.\"\n            ),\n            value=\"percentile\",\n            options=[\"percentile\", \"standard_deviation\", \"interquartile\"],\n        ),\n        FloatInput(\n            name=\"breakpoint_threshold_amount\",\n            display_name=\"Breakpoint Threshold Amount\",\n            info=\"Numerical amount for the breakpoint threshold.\",\n            value=0.5,\n        ),\n        IntInput(\n            name=\"number_of_chunks\",\n            display_name=\"Number of Chunks\",\n            info=\"Number of chunks to split the text into.\",\n            value=5,\n        ),\n        MessageTextInput(\n            name=\"sentence_split_regex\",\n            display_name=\"Sentence Split Regex\",\n            info=\"Regular expression to split sentences. Optional.\",\n            value=\"\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"buffer_size\",\n            display_name=\"Buffer Size\",\n            info=\"Size of the buffer.\",\n            value=0,\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Chunks\", name=\"chunks\", method=\"split_text\"),\n    ]\n\n    def _docs_to_data(self, docs: list[Document]) -> list[Data]:\n        \"\"\"Convert a list of Document objects to Data objects.\"\"\"\n        return [Data(text=doc.page_content, data=doc.metadata) for doc in docs]\n\n    def split_text(self) -> list[Data]:\n        \"\"\"Split the input data into semantically meaningful chunks.\"\"\"\n        try:\n            embeddings = getattr(self, \"embeddings\", None)\n            if embeddings is None:\n                error_msg = \"An embeddings model is required for SemanticTextSplitter.\"\n                raise ValueError(error_msg)\n\n            if not self.data_inputs:\n                error_msg = \"Data inputs cannot be empty.\"\n                raise ValueError(error_msg)\n\n            documents = []\n            for _input in self.data_inputs:\n                if isinstance(_input, Data):\n                    documents.append(_input.to_lc_document())\n                else:\n                    error_msg = f\"Invalid data input type: {_input}\"\n                    raise TypeError(error_msg)\n\n            if not documents:\n                error_msg = \"No valid Data objects found in data_inputs.\"\n                raise ValueError(error_msg)\n\n            texts = [doc.page_content for doc in documents]\n            metadatas = [doc.metadata for doc in documents]\n\n            splitter_params = {\n                \"embeddings\": embeddings,\n                \"breakpoint_threshold_type\": self.breakpoint_threshold_type or \"percentile\",\n                \"breakpoint_threshold_amount\": self.breakpoint_threshold_amount,\n                \"number_of_chunks\": self.number_of_chunks,\n                \"buffer_size\": self.buffer_size,\n            }\n\n            if self.sentence_split_regex:\n                splitter_params[\"sentence_split_regex\"] = self.sentence_split_regex\n\n            splitter = SemanticChunker(**splitter_params)\n            docs = splitter.create_documents(texts, metadatas=metadatas)\n\n            data = self._docs_to_data(docs)\n            self.status = data\n\n        except Exception as e:\n            error_msg = f\"An error occurred during semantic splitting: {e}\"\n            raise RuntimeError(error_msg) from e\n\n        else:\n            return data\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "number_of_chunks": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "number_of_chunks",
        "value": 5,
        "display_name": "Number of Chunks",
        "advanced": false,
        "dynamic": false,
        "info": "Number of chunks to split the text into.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "sentence_split_regex": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "sentence_split_regex",
        "value": "",
        "display_name": "Sentence Split Regex",
        "advanced": true,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Regular expression to split sentences. Optional.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      }
    },
    "description": "Split text into semantically meaningful chunks using semantic similarity.",
    "icon": "LangChain",
    "base_classes": [
      "Data"
    ],
    "display_name": "Semantic Text Splitter",
    "documentation": "https://python.langchain.com/docs/how_to/semantic-chunker/",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "chunks",
        "display_name": "Chunks",
        "method": "split_text",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "data_inputs",
      "embeddings",
      "breakpoint_threshold_type",
      "breakpoint_threshold_amount",
      "number_of_chunks",
      "sentence_split_regex",
      "buffer_size"
    ],
    "beta": true,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "CharacterTextSplitter": {
    "template": {
      "_type": "Component",
      "data_input": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "trace_as_input": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "data_input",
        "value": "",
        "display_name": "Input",
        "advanced": false,
        "input_types": [
          "Document",
          "Data"
        ],
        "dynamic": false,
        "info": "The texts to split.",
        "title_case": false,
        "type": "other",
        "_input_type": "DataInput"
      },
      "chunk_overlap": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "chunk_overlap",
        "value": 200,
        "display_name": "Chunk Overlap",
        "advanced": false,
        "dynamic": false,
        "info": "The amount of overlap between chunks.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "chunk_size": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "chunk_size",
        "value": 1000,
        "display_name": "Chunk Size",
        "advanced": false,
        "dynamic": false,
        "info": "The maximum length of each chunk.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from typing import Any\n\nfrom langchain_text_splitters import CharacterTextSplitter, TextSplitter\n\nfrom langflow.base.textsplitters.model import LCTextSplitterComponent\nfrom langflow.inputs import DataInput, IntInput, MessageTextInput\nfrom langflow.utils.util import unescape_string\n\n\nclass CharacterTextSplitterComponent(LCTextSplitterComponent):\n    display_name = \"CharacterTextSplitter\"\n    description = \"Split text by number of characters.\"\n    documentation = \"https://docs.langflow.org/components/text-splitters#charactertextsplitter\"\n    name = \"CharacterTextSplitter\"\n    icon = \"LangChain\"\n\n    inputs = [\n        IntInput(\n            name=\"chunk_size\",\n            display_name=\"Chunk Size\",\n            info=\"The maximum length of each chunk.\",\n            value=1000,\n        ),\n        IntInput(\n            name=\"chunk_overlap\",\n            display_name=\"Chunk Overlap\",\n            info=\"The amount of overlap between chunks.\",\n            value=200,\n        ),\n        DataInput(\n            name=\"data_input\",\n            display_name=\"Input\",\n            info=\"The texts to split.\",\n            input_types=[\"Document\", \"Data\"],\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"separator\",\n            display_name=\"Separator\",\n            info='The characters to split on.\\nIf left empty defaults to \"\\\\n\\\\n\".',\n        ),\n    ]\n\n    def get_data_input(self) -> Any:\n        return self.data_input\n\n    def build_text_splitter(self) -> TextSplitter:\n        separator = unescape_string(self.separator) if self.separator else \"\\n\\n\"\n        return CharacterTextSplitter(\n            chunk_overlap=self.chunk_overlap,\n            chunk_size=self.chunk_size,\n            separator=separator,\n        )\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "separator": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "separator",
        "value": "",
        "display_name": "Separator",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The characters to split on.\nIf left empty defaults to \"\\n\\n\".",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      }
    },
    "description": "Split text by number of characters.",
    "icon": "LangChain",
    "base_classes": [
      "Data"
    ],
    "display_name": "CharacterTextSplitter",
    "documentation": "https://docs.langflow.org/components/text-splitters#charactertextsplitter",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "data",
        "display_name": "Data",
        "method": "transform_data",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "chunk_size",
      "chunk_overlap",
      "data_input",
      "separator"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "SQLAgent": {
    "template": {
      "_type": "Component",
      "extra_tools": {
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "extra_tools",
        "value": "",
        "display_name": "Extra Tools",
        "advanced": true,
        "input_types": [
          "Tool"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "llm": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "llm",
        "value": "",
        "display_name": "Language Model",
        "advanced": false,
        "input_types": [
          "LanguageModel"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "agent_description": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "agent_description",
        "value": "A helpful assistant with access to the following tools:",
        "display_name": "Agent Description [Deprecated]",
        "advanced": true,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The description of the agent. This is only used when in Tool Mode. Defaults to 'A helpful assistant with access to the following tools:' and tools are added dynamically. This feature is deprecated and will be removed in future versions.",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain.agents import AgentExecutor\nfrom langchain_community.agent_toolkits import SQLDatabaseToolkit\nfrom langchain_community.agent_toolkits.sql.base import create_sql_agent\nfrom langchain_community.utilities import SQLDatabase\n\nfrom langflow.base.agents.agent import LCAgentComponent\nfrom langflow.inputs import HandleInput, MessageTextInput\n\n\nclass SQLAgentComponent(LCAgentComponent):\n    display_name = \"SQLAgent\"\n    description = \"Construct an SQL agent from an LLM and tools.\"\n    name = \"SQLAgent\"\n    icon = \"LangChain\"\n    inputs = [\n        *LCAgentComponent._base_inputs,\n        HandleInput(name=\"llm\", display_name=\"Language Model\", input_types=[\"LanguageModel\"], required=True),\n        MessageTextInput(name=\"database_uri\", display_name=\"Database URI\", required=True),\n        HandleInput(\n            name=\"extra_tools\",\n            display_name=\"Extra Tools\",\n            input_types=[\"Tool\"],\n            is_list=True,\n            advanced=True,\n        ),\n    ]\n\n    def build_agent(self) -> AgentExecutor:\n        db = SQLDatabase.from_uri(self.database_uri)\n        toolkit = SQLDatabaseToolkit(db=db, llm=self.llm)\n        agent_args = self.get_agent_kwargs()\n        agent_args[\"max_iterations\"] = agent_args[\"agent_executor_kwargs\"][\"max_iterations\"]\n        del agent_args[\"agent_executor_kwargs\"][\"max_iterations\"]\n        return create_sql_agent(llm=self.llm, toolkit=toolkit, extra_tools=self.extra_tools or [], **agent_args)\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "database_uri": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "database_uri",
        "value": "",
        "display_name": "Database URI",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "handle_parsing_errors": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "handle_parsing_errors",
        "value": true,
        "display_name": "Handle Parse Errors",
        "advanced": true,
        "dynamic": false,
        "info": "Should the Agent fix errors when reading user input for better processing?",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "input_value": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "input_value",
        "value": "",
        "display_name": "Input",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The input provided by the user for the agent to process.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "max_iterations": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "max_iterations",
        "value": 15,
        "display_name": "Max Iterations",
        "advanced": true,
        "dynamic": false,
        "info": "The maximum number of attempts the agent can make to complete its task before it stops.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "verbose": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "verbose",
        "value": true,
        "display_name": "Verbose",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      }
    },
    "description": "Construct an SQL agent from an LLM and tools.",
    "icon": "LangChain",
    "base_classes": [
      "AgentExecutor",
      "Message"
    ],
    "display_name": "SQLAgent",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "AgentExecutor"
        ],
        "selected": "AgentExecutor",
        "name": "agent",
        "hidden": true,
        "display_name": "Agent",
        "method": "build_agent",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "database_uri",
          "llm"
        ],
        "allows_loop": false,
        "tool_mode": false
      },
      {
        "types": [
          "Message"
        ],
        "selected": "Message",
        "name": "response",
        "display_name": "Response",
        "method": "message_response",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "input_value",
      "handle_parsing_errors",
      "verbose",
      "max_iterations",
      "agent_description",
      "llm",
      "database_uri",
      "extra_tools"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "RecursiveCharacterTextSplitter": {
    "template": {
      "_type": "Component",
      "data_input": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "trace_as_input": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "data_input",
        "value": "",
        "display_name": "Input",
        "advanced": false,
        "input_types": [
          "Document",
          "Data"
        ],
        "dynamic": false,
        "info": "The texts to split.",
        "title_case": false,
        "type": "other",
        "_input_type": "DataInput"
      },
      "chunk_overlap": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "chunk_overlap",
        "value": 200,
        "display_name": "Chunk Overlap",
        "advanced": false,
        "dynamic": false,
        "info": "The amount of overlap between chunks.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "chunk_size": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "chunk_size",
        "value": 1000,
        "display_name": "Chunk Size",
        "advanced": false,
        "dynamic": false,
        "info": "The maximum length of each chunk.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from typing import Any\n\nfrom langchain_text_splitters import RecursiveCharacterTextSplitter, TextSplitter\n\nfrom langflow.base.textsplitters.model import LCTextSplitterComponent\nfrom langflow.inputs.inputs import DataInput, IntInput, MessageTextInput\nfrom langflow.utils.util import unescape_string\n\n\nclass RecursiveCharacterTextSplitterComponent(LCTextSplitterComponent):\n    display_name: str = \"Recursive Character Text Splitter\"\n    description: str = \"Split text trying to keep all related text together.\"\n    documentation: str = \"https://docs.langflow.org/components-processing\"\n    name = \"RecursiveCharacterTextSplitter\"\n    icon = \"LangChain\"\n\n    inputs = [\n        IntInput(\n            name=\"chunk_size\",\n            display_name=\"Chunk Size\",\n            info=\"The maximum length of each chunk.\",\n            value=1000,\n        ),\n        IntInput(\n            name=\"chunk_overlap\",\n            display_name=\"Chunk Overlap\",\n            info=\"The amount of overlap between chunks.\",\n            value=200,\n        ),\n        DataInput(\n            name=\"data_input\",\n            display_name=\"Input\",\n            info=\"The texts to split.\",\n            input_types=[\"Document\", \"Data\"],\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"separators\",\n            display_name=\"Separators\",\n            info='The characters to split on.\\nIf left empty defaults to [\"\\\\n\\\\n\", \"\\\\n\", \" \", \"\"].',\n            is_list=True,\n        ),\n    ]\n\n    def get_data_input(self) -> Any:\n        return self.data_input\n\n    def build_text_splitter(self) -> TextSplitter:\n        if not self.separators:\n            separators: list[str] | None = None\n        else:\n            # check if the separators list has escaped characters\n            # if there are escaped characters, unescape them\n            separators = [unescape_string(x) for x in self.separators]\n\n        return RecursiveCharacterTextSplitter(\n            separators=separators,\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n        )\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "separators": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "separators",
        "value": "",
        "display_name": "Separators",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The characters to split on.\nIf left empty defaults to [\"\\n\\n\", \"\\n\", \" \", \"\"].",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      }
    },
    "description": "Split text trying to keep all related text together.",
    "icon": "LangChain",
    "base_classes": [
      "Data"
    ],
    "display_name": "Recursive Character Text Splitter",
    "documentation": "https://docs.langflow.org/components-processing",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "data",
        "display_name": "Data",
        "method": "transform_data",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "chunk_size",
      "chunk_overlap",
      "data_input",
      "separators"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "LangChainFakeEmbeddings": {
    "template": {
      "_type": "Component",
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain_community.embeddings import FakeEmbeddings\n\nfrom langflow.base.embeddings.model import LCEmbeddingsModel\nfrom langflow.field_typing import Embeddings\nfrom langflow.io import IntInput\n\n\nclass FakeEmbeddingsComponent(LCEmbeddingsModel):\n    display_name = \"Fake Embeddings\"\n    description = \"Generate fake embeddings, useful for initial testing and connecting components.\"\n    icon = \"LangChain\"\n    name = \"LangChainFakeEmbeddings\"\n\n    inputs = [\n        IntInput(\n            name=\"dimensions\",\n            display_name=\"Dimensions\",\n            info=\"The number of dimensions the resulting output embeddings should have.\",\n            value=5,\n        ),\n    ]\n\n    def build_embeddings(self) -> Embeddings:\n        return FakeEmbeddings(\n            size=self.dimensions or 5,\n        )\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "dimensions": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "dimensions",
        "value": 5,
        "display_name": "Dimensions",
        "advanced": false,
        "dynamic": false,
        "info": "The number of dimensions the resulting output embeddings should have.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      }
    },
    "description": "Generate fake embeddings, useful for initial testing and connecting components.",
    "icon": "LangChain",
    "base_classes": [
      "Embeddings"
    ],
    "display_name": "Fake Embeddings",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Embeddings"
        ],
        "selected": "Embeddings",
        "name": "embeddings",
        "display_name": "Embeddings",
        "method": "build_embeddings",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "dimensions"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "JsonAgent": {
    "template": {
      "_type": "Component",
      "llm": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "llm",
        "value": "",
        "display_name": "Language Model",
        "advanced": false,
        "input_types": [
          "LanguageModel"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "path": {
        "trace_as_metadata": true,
        "file_path": "",
        "fileTypes": [
          "json",
          "yaml",
          "yml"
        ],
        "temp_file": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "path",
        "value": "",
        "display_name": "File Path",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "file",
        "_input_type": "FileInput"
      },
      "agent_description": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "agent_description",
        "value": "A helpful assistant with access to the following tools:",
        "display_name": "Agent Description [Deprecated]",
        "advanced": true,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The description of the agent. This is only used when in Tool Mode. Defaults to 'A helpful assistant with access to the following tools:' and tools are added dynamically. This feature is deprecated and will be removed in future versions.",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from pathlib import Path\n\nimport yaml\nfrom langchain.agents import AgentExecutor\nfrom langchain_community.agent_toolkits import create_json_agent\nfrom langchain_community.agent_toolkits.json.toolkit import JsonToolkit\nfrom langchain_community.tools.json.tool import JsonSpec\n\nfrom langflow.base.agents.agent import LCAgentComponent\nfrom langflow.inputs import FileInput, HandleInput\n\n\nclass JsonAgentComponent(LCAgentComponent):\n    display_name = \"JsonAgent\"\n    description = \"Construct a json agent from an LLM and tools.\"\n    name = \"JsonAgent\"\n    legacy: bool = True\n\n    inputs = [\n        *LCAgentComponent._base_inputs,\n        HandleInput(\n            name=\"llm\",\n            display_name=\"Language Model\",\n            input_types=[\"LanguageModel\"],\n            required=True,\n        ),\n        FileInput(\n            name=\"path\",\n            display_name=\"File Path\",\n            file_types=[\"json\", \"yaml\", \"yml\"],\n            required=True,\n        ),\n    ]\n\n    def build_agent(self) -> AgentExecutor:\n        path = Path(self.path)\n        if path.suffix in {\"yaml\", \"yml\"}:\n            with path.open(encoding=\"utf-8\") as file:\n                yaml_dict = yaml.safe_load(file)\n            spec = JsonSpec(dict_=yaml_dict)\n        else:\n            spec = JsonSpec.from_file(path)\n        toolkit = JsonToolkit(spec=spec)\n\n        return create_json_agent(llm=self.llm, toolkit=toolkit, **self.get_agent_kwargs())\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "handle_parsing_errors": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "handle_parsing_errors",
        "value": true,
        "display_name": "Handle Parse Errors",
        "advanced": true,
        "dynamic": false,
        "info": "Should the Agent fix errors when reading user input for better processing?",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "input_value": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "input_value",
        "value": "",
        "display_name": "Input",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The input provided by the user for the agent to process.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "max_iterations": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "max_iterations",
        "value": 15,
        "display_name": "Max Iterations",
        "advanced": true,
        "dynamic": false,
        "info": "The maximum number of attempts the agent can make to complete its task before it stops.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "verbose": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "verbose",
        "value": true,
        "display_name": "Verbose",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      }
    },
    "description": "Construct a json agent from an LLM and tools.",
    "base_classes": [
      "AgentExecutor",
      "Message"
    ],
    "display_name": "JsonAgent",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "AgentExecutor"
        ],
        "selected": "AgentExecutor",
        "name": "agent",
        "hidden": true,
        "display_name": "Agent",
        "method": "build_agent",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "llm",
          "path"
        ],
        "allows_loop": false,
        "tool_mode": false
      },
      {
        "types": [
          "Message"
        ],
        "selected": "Message",
        "name": "response",
        "display_name": "Response",
        "method": "message_response",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "input_value",
      "handle_parsing_errors",
      "verbose",
      "max_iterations",
      "agent_description",
      "llm",
      "path"
    ],
    "beta": false,
    "legacy": true,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "SpiderTool": {
    "template": {
      "_type": "Component",
      "blacklist": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "blacklist",
        "value": "",
        "display_name": "Blacklist",
        "advanced": true,
        "dynamic": false,
        "info": "Blacklist paths that you do not want to crawl. Use Regex patterns.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from spider.spider import Spider\n\nfrom langflow.base.langchain_utilities.spider_constants import MODES\nfrom langflow.custom import Component\nfrom langflow.io import (\n    BoolInput,\n    DictInput,\n    DropdownInput,\n    IntInput,\n    Output,\n    SecretStrInput,\n    StrInput,\n)\nfrom langflow.schema import Data\n\n\nclass SpiderTool(Component):\n    display_name: str = \"Spider Web Crawler & Scraper\"\n    description: str = \"Spider API for web crawling and scraping.\"\n    output_types: list[str] = [\"Document\"]\n    documentation: str = \"https://spider.cloud/docs/api\"\n\n    inputs = [\n        SecretStrInput(\n            name=\"spider_api_key\",\n            display_name=\"Spider API Key\",\n            required=True,\n            password=True,\n            info=\"The Spider API Key, get it from https://spider.cloud\",\n        ),\n        StrInput(\n            name=\"url\",\n            display_name=\"URL\",\n            required=True,\n            info=\"The URL to scrape or crawl\",\n        ),\n        DropdownInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            required=True,\n            options=MODES,\n            value=MODES[0],\n            info=\"The mode of operation: scrape or crawl\",\n        ),\n        IntInput(\n            name=\"limit\",\n            display_name=\"Limit\",\n            info=\"The maximum amount of pages allowed to crawl per website. Set to 0 to crawl all pages.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"depth\",\n            display_name=\"Depth\",\n            info=\"The crawl limit for maximum depth. If 0, no limit will be applied.\",\n            advanced=True,\n        ),\n        StrInput(\n            name=\"blacklist\",\n            display_name=\"Blacklist\",\n            info=\"Blacklist paths that you do not want to crawl. Use Regex patterns.\",\n            advanced=True,\n        ),\n        StrInput(\n            name=\"whitelist\",\n            display_name=\"Whitelist\",\n            info=\"Whitelist paths that you want to crawl, ignoring all other routes. Use Regex patterns.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"readability\",\n            display_name=\"Use Readability\",\n            info=\"Use readability to pre-process the content for reading.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"request_timeout\",\n            display_name=\"Request Timeout\",\n            info=\"Timeout for the request in seconds.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"metadata\",\n            display_name=\"Metadata\",\n            info=\"Include metadata in the response.\",\n            advanced=True,\n        ),\n        DictInput(\n            name=\"params\",\n            display_name=\"Additional Parameters\",\n            info=\"Additional parameters to pass to the API. If provided, other inputs will be ignored.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Markdown\", name=\"content\", method=\"crawl\"),\n    ]\n\n    def crawl(self) -> list[Data]:\n        if self.params:\n            parameters = self.params[\"data\"]\n        else:\n            parameters = {\n                \"limit\": self.limit or None,\n                \"depth\": self.depth or None,\n                \"blacklist\": self.blacklist or None,\n                \"whitelist\": self.whitelist or None,\n                \"readability\": self.readability,\n                \"request_timeout\": self.request_timeout or None,\n                \"metadata\": self.metadata,\n                \"return_format\": \"markdown\",\n            }\n\n        app = Spider(api_key=self.spider_api_key)\n        if self.mode == \"scrape\":\n            parameters[\"limit\"] = 1\n            result = app.scrape_url(self.url, parameters)\n        elif self.mode == \"crawl\":\n            result = app.crawl_url(self.url, parameters)\n        else:\n            msg = f\"Invalid mode: {self.mode}. Must be 'scrape' or 'crawl'.\"\n            raise ValueError(msg)\n\n        records = []\n\n        for record in result:\n            if self.metadata:\n                records.append(\n                    Data(\n                        data={\n                            \"content\": record[\"content\"],\n                            \"url\": record[\"url\"],\n                            \"metadata\": record[\"metadata\"],\n                        }\n                    )\n                )\n            else:\n                records.append(Data(data={\"content\": record[\"content\"], \"url\": record[\"url\"]}))\n        return records\n\n\nclass SpiderToolError(Exception):\n    \"\"\"SpiderTool error.\"\"\"\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "depth": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "depth",
        "value": "",
        "display_name": "Depth",
        "advanced": true,
        "dynamic": false,
        "info": "The crawl limit for maximum depth. If 0, no limit will be applied.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "limit": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "limit",
        "value": "",
        "display_name": "Limit",
        "advanced": true,
        "dynamic": false,
        "info": "The maximum amount of pages allowed to crawl per website. Set to 0 to crawl all pages.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "metadata": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "metadata",
        "value": false,
        "display_name": "Metadata",
        "advanced": true,
        "dynamic": false,
        "info": "Include metadata in the response.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "mode": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "scrape",
          "crawl"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "mode",
        "value": "scrape",
        "display_name": "Mode",
        "advanced": false,
        "dynamic": false,
        "info": "The mode of operation: scrape or crawl",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "params": {
        "tool_mode": false,
        "trace_as_input": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "params",
        "value": {},
        "display_name": "Additional Parameters",
        "advanced": false,
        "dynamic": false,
        "info": "Additional parameters to pass to the API. If provided, other inputs will be ignored.",
        "title_case": false,
        "type": "dict",
        "_input_type": "DictInput"
      },
      "readability": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "readability",
        "value": false,
        "display_name": "Use Readability",
        "advanced": true,
        "dynamic": false,
        "info": "Use readability to pre-process the content for reading.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "request_timeout": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "request_timeout",
        "value": "",
        "display_name": "Request Timeout",
        "advanced": true,
        "dynamic": false,
        "info": "Timeout for the request in seconds.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "spider_api_key": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "spider_api_key",
        "value": "",
        "display_name": "Spider API Key",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "The Spider API Key, get it from https://spider.cloud",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "url": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "url",
        "value": "",
        "display_name": "URL",
        "advanced": false,
        "dynamic": false,
        "info": "The URL to scrape or crawl",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "whitelist": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "whitelist",
        "value": "",
        "display_name": "Whitelist",
        "advanced": true,
        "dynamic": false,
        "info": "Whitelist paths that you want to crawl, ignoring all other routes. Use Regex patterns.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      }
    },
    "description": "Spider API for web crawling and scraping.",
    "base_classes": [
      "Data"
    ],
    "display_name": "Spider Web Crawler & Scraper",
    "documentation": "https://spider.cloud/docs/api",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "content",
        "display_name": "Markdown",
        "method": "crawl",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "spider_api_key",
      "url",
      "mode",
      "limit",
      "depth",
      "blacklist",
      "whitelist",
      "readability",
      "request_timeout",
      "metadata",
      "params"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "JSONDocumentBuilder": {
    "template": {
      "_type": "CustomComponent",
      "document": {
        "type": "Document",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": false,
        "fileTypes": [],
        "file_path": "",
        "name": "document",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "# JSON Document Builder\n\n# Build a Document containing a JSON object using a key and another Document page content.\n\n# **Params**\n\n# - **Key:** The key to use for the JSON object.\n# - **Document:** The Document page to use for the JSON object.\n\n# **Output**\n\n# - **Document:** The Document containing the JSON object.\n\nfrom langchain_core.documents import Document\n\nfrom langflow.custom import CustomComponent\nfrom langflow.services.database.models.base import orjson_dumps\n\n\nclass JSONDocumentBuilder(CustomComponent):\n    display_name: str = \"JSON Document Builder\"\n    description: str = \"Build a Document containing a JSON object using a key and another Document page content.\"\n    name = \"JSONDocumentBuilder\"\n    legacy: bool = True\n\n    output_types: list[str] = [\"Document\"]\n    documentation: str = \"https://docs.langflow.org/components/utilities#json-document-builder\"\n\n    field_config = {\n        \"key\": {\"display_name\": \"Key\"},\n        \"document\": {\"display_name\": \"Document\"},\n    }\n\n    def build(\n        self,\n        key: str,\n        document: Document,\n    ) -> Document:\n        documents = None\n        if isinstance(document, list):\n            documents = [\n                Document(page_content=orjson_dumps({key: doc.page_content}, indent_2=False)) for doc in document\n            ]\n        elif isinstance(document, Document):\n            documents = Document(page_content=orjson_dumps({key: document.page_content}, indent_2=False))\n        else:\n            msg = f\"Expected Document or list of Documents, got {type(document)}\"\n            raise TypeError(msg)\n        self.repr_value = documents\n        return documents\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "key": {
        "type": "str",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": false,
        "fileTypes": [],
        "file_path": "",
        "name": "key",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "load_from_db": false,
        "title_case": false,
        "input_types": [
          "Text"
        ]
      }
    },
    "description": "Build a Document containing a JSON object using a key and another Document page content.",
    "base_classes": [
      "BaseMedia",
      "Document",
      "Serializable"
    ],
    "display_name": "JSON Document Builder",
    "documentation": "https://docs.langflow.org/components/utilities#json-document-builder",
    "minimized": false,
    "custom_fields": {
      "key": null,
      "document": null
    },
    "output_types": [
      "Document"
    ],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Document"
        ],
        "selected": "Document",
        "name": "document",
        "hidden": null,
        "display_name": "Document",
        "method": null,
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": null,
        "allows_loop": false,
        "options": null,
        "tool_mode": true
      }
    ],
    "field_order": [],
    "beta": false,
    "legacy": true,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "ToolCallingAgent": {
    "template": {
      "_type": "Component",
      "chat_history": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "trace_as_input": true,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "chat_history",
        "value": "",
        "display_name": "Chat Memory",
        "advanced": true,
        "input_types": [
          "Data"
        ],
        "dynamic": false,
        "info": "This input stores the chat history, allowing the agent to remember previous conversations.",
        "title_case": false,
        "type": "other",
        "_input_type": "DataInput"
      },
      "llm": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "llm",
        "value": "",
        "display_name": "Language Model",
        "advanced": false,
        "input_types": [
          "LanguageModel"
        ],
        "dynamic": false,
        "info": "Language model that the agent utilizes to perform tasks effectively.",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "tools": {
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "tools",
        "value": "",
        "display_name": "Tools",
        "advanced": false,
        "input_types": [
          "Tool"
        ],
        "dynamic": false,
        "info": "These are the tools that the agent can use to help with tasks.",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "agent_description": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "agent_description",
        "value": "A helpful assistant with access to the following tools:",
        "display_name": "Agent Description [Deprecated]",
        "advanced": true,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The description of the agent. This is only used when in Tool Mode. Defaults to 'A helpful assistant with access to the following tools:' and tools are added dynamically. This feature is deprecated and will be removed in future versions.",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain.agents import create_tool_calling_agent\nfrom langchain_core.prompts import ChatPromptTemplate\n\nfrom langflow.base.agents.agent import LCToolsAgentComponent\nfrom langflow.inputs import MessageTextInput\nfrom langflow.inputs.inputs import DataInput, HandleInput\nfrom langflow.schema import Data\n\n\nclass ToolCallingAgentComponent(LCToolsAgentComponent):\n    display_name: str = \"Tool Calling Agent\"\n    description: str = \"An agent designed to utilize various tools seamlessly within workflows.\"\n    icon = \"LangChain\"\n    name = \"ToolCallingAgent\"\n\n    inputs = [\n        *LCToolsAgentComponent._base_inputs,\n        HandleInput(\n            name=\"llm\",\n            display_name=\"Language Model\",\n            input_types=[\"LanguageModel\"],\n            required=True,\n            info=\"Language model that the agent utilizes to perform tasks effectively.\",\n        ),\n        MessageTextInput(\n            name=\"system_prompt\",\n            display_name=\"System Prompt\",\n            info=\"System prompt to guide the agent's behavior.\",\n            value=\"You are a helpful assistant that can use tools to answer questions and perform tasks.\",\n        ),\n        DataInput(\n            name=\"chat_history\",\n            display_name=\"Chat Memory\",\n            is_list=True,\n            advanced=True,\n            info=\"This input stores the chat history, allowing the agent to remember previous conversations.\",\n        ),\n    ]\n\n    def get_chat_history_data(self) -> list[Data] | None:\n        return self.chat_history\n\n    def create_agent_runnable(self):\n        messages = [\n            (\"system\", \"{system_prompt}\"),\n            (\"placeholder\", \"{chat_history}\"),\n            (\"human\", \"{input}\"),\n            (\"placeholder\", \"{agent_scratchpad}\"),\n        ]\n        prompt = ChatPromptTemplate.from_messages(messages)\n        self.validate_tool_names()\n        try:\n            return create_tool_calling_agent(self.llm, self.tools or [], prompt)\n        except NotImplementedError as e:\n            message = f\"{self.display_name} does not support tool calling. Please try using a compatible model.\"\n            raise NotImplementedError(message) from e\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "handle_parsing_errors": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "handle_parsing_errors",
        "value": true,
        "display_name": "Handle Parse Errors",
        "advanced": true,
        "dynamic": false,
        "info": "Should the Agent fix errors when reading user input for better processing?",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "input_value": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "input_value",
        "value": "",
        "display_name": "Input",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The input provided by the user for the agent to process.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "max_iterations": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "max_iterations",
        "value": 15,
        "display_name": "Max Iterations",
        "advanced": true,
        "dynamic": false,
        "info": "The maximum number of attempts the agent can make to complete its task before it stops.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "system_prompt": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "system_prompt",
        "value": "You are a helpful assistant that can use tools to answer questions and perform tasks.",
        "display_name": "System Prompt",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "System prompt to guide the agent's behavior.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "verbose": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "verbose",
        "value": true,
        "display_name": "Verbose",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      }
    },
    "description": "An agent designed to utilize various tools seamlessly within workflows.",
    "icon": "LangChain",
    "base_classes": [
      "AgentExecutor",
      "Message"
    ],
    "display_name": "Tool Calling Agent",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "AgentExecutor"
        ],
        "selected": "AgentExecutor",
        "name": "agent",
        "hidden": true,
        "display_name": "Agent",
        "method": "build_agent",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": false
      },
      {
        "types": [
          "Message"
        ],
        "selected": "Message",
        "name": "response",
        "display_name": "Response",
        "method": "message_response",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "tools",
      "input_value",
      "handle_parsing_errors",
      "verbose",
      "max_iterations",
      "agent_description",
      "llm",
      "system_prompt",
      "chat_history"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "LangChain Hub Prompt": {
    "template": {
      "_type": "Component",
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "import re\n\nfrom langchain_core.prompts import HumanMessagePromptTemplate\n\nfrom langflow.custom import Component\nfrom langflow.inputs import DefaultPromptField, SecretStrInput, StrInput\nfrom langflow.io import Output\nfrom langflow.schema.message import Message\n\n\nclass LangChainHubPromptComponent(Component):\n    display_name: str = \"Prompt Hub\"\n    description: str = \"Prompt Component that uses LangChain Hub prompts\"\n    beta = True\n    icon = \"LangChain\"\n    trace_type = \"prompt\"\n    name = \"LangChain Hub Prompt\"\n\n    inputs = [\n        SecretStrInput(\n            name=\"langchain_api_key\",\n            display_name=\"Your LangChain API Key\",\n            info=\"The LangChain API Key to use.\",\n            required=True,\n        ),\n        StrInput(\n            name=\"langchain_hub_prompt\",\n            display_name=\"LangChain Hub Prompt\",\n            info=\"The LangChain Hub prompt to use, i.e., 'efriis/my-first-prompt'\",\n            refresh_button=True,\n            required=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Build Prompt\", name=\"prompt\", method=\"build_prompt\"),\n    ]\n\n    def update_build_config(self, build_config: dict, field_value: str, field_name: str | None = None):\n        # If the field is not langchain_hub_prompt or the value is empty, return the build config as is\n        if field_name != \"langchain_hub_prompt\" or not field_value:\n            return build_config\n\n        # Fetch the template\n        template = self._fetch_langchain_hub_template()\n\n        # Get the template's messages\n        if hasattr(template, \"messages\"):\n            template_messages = template.messages\n        else:\n            template_messages = [HumanMessagePromptTemplate(prompt=template)]\n\n        # Extract the messages from the prompt data\n        prompt_template = [message_data.prompt for message_data in template_messages]\n\n        # Regular expression to find all instances of {<string>}\n        pattern = r\"\\{(.*?)\\}\"\n\n        # Get all the custom fields\n        custom_fields: list[str] = []\n        full_template = \"\"\n        for message in prompt_template:\n            # Find all matches\n            matches = re.findall(pattern, message.template)\n            custom_fields += matches\n\n            # Create a string version of the full template\n            full_template = full_template + \"\\n\" + message.template\n\n        # No need to reprocess if we have them already\n        if all(\"param_\" + custom_field in build_config for custom_field in custom_fields):\n            return build_config\n\n        # Easter egg: Show template in info popup\n        build_config[\"langchain_hub_prompt\"][\"info\"] = full_template\n\n        # Remove old parameter inputs if any\n        for key in build_config.copy():\n            if key.startswith(\"param_\"):\n                del build_config[key]\n\n        # Now create inputs for each\n        for custom_field in custom_fields:\n            new_parameter = DefaultPromptField(\n                name=f\"param_{custom_field}\",\n                display_name=custom_field,\n                info=\"Fill in the value for {\" + custom_field + \"}\",\n            ).to_dict()\n\n            # Add the new parameter to the build config\n            build_config[f\"param_{custom_field}\"] = new_parameter\n\n        return build_config\n\n    async def build_prompt(\n        self,\n    ) -> Message:\n        # Fetch the template\n        template = self._fetch_langchain_hub_template()\n\n        # Get the parameters from the attributes\n        params_dict = {param: getattr(self, \"param_\" + param, f\"{{{param}}}\") for param in template.input_variables}\n        original_params = {k: v.text if hasattr(v, \"text\") else v for k, v in params_dict.items() if v is not None}\n        prompt_value = template.invoke(original_params)\n\n        # Update the template with the new value\n        original_params[\"template\"] = prompt_value.to_string()\n\n        # Now pass the filtered attributes to the function\n        prompt = Message.from_template(**original_params)\n\n        self.status = prompt.text\n\n        return prompt\n\n    def _fetch_langchain_hub_template(self):\n        import langchain.hub\n\n        # Check if the api key is provided\n        if not self.langchain_api_key:\n            msg = \"Please provide a LangChain API Key\"\n\n            raise ValueError(msg)\n\n        # Pull the prompt from LangChain Hub\n        return langchain.hub.pull(self.langchain_hub_prompt, api_key=self.langchain_api_key)\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "langchain_api_key": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "langchain_api_key",
        "value": "",
        "display_name": "Your LangChain API Key",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "The LangChain API Key to use.",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "langchain_hub_prompt": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "langchain_hub_prompt",
        "value": "",
        "display_name": "LangChain Hub Prompt",
        "advanced": false,
        "dynamic": false,
        "info": "The LangChain Hub prompt to use, i.e., 'efriis/my-first-prompt'",
        "refresh_button": true,
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      }
    },
    "description": "Prompt Component that uses LangChain Hub prompts",
    "icon": "LangChain",
    "base_classes": [
      "Message"
    ],
    "display_name": "Prompt Hub",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Message"
        ],
        "selected": "Message",
        "name": "prompt",
        "display_name": "Build Prompt",
        "method": "build_prompt",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "langchain_api_key",
      "langchain_hub_prompt"
    ],
    "beta": true,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  }
}