{
  "Cassandra": {
    "template": {
      "_type": "Component",
      "embedding": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "embedding",
        "value": "",
        "display_name": "Embedding",
        "advanced": false,
        "input_types": [
          "Embeddings"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "ingest_data": {
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "ingest_data",
        "value": "",
        "display_name": "Ingest Data",
        "advanced": false,
        "input_types": [
          "Data",
          "DataFrame"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "batch_size": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "batch_size",
        "value": 16,
        "display_name": "Batch Size",
        "advanced": true,
        "dynamic": false,
        "info": "Optional number of data to process in a single batch.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "body_search": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "body_search",
        "value": "",
        "display_name": "Search Body",
        "advanced": true,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Document textual search terms to apply to the search query.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "cluster_kwargs": {
        "tool_mode": false,
        "trace_as_input": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "cluster_kwargs",
        "value": {},
        "display_name": "Cluster arguments",
        "advanced": true,
        "dynamic": false,
        "info": "Optional dictionary of additional keyword arguments for the Cassandra cluster.",
        "title_case": false,
        "type": "dict",
        "_input_type": "DictInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain_community.vectorstores import Cassandra\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.inputs import BoolInput, DictInput, FloatInput\nfrom langflow.io import (\n    DropdownInput,\n    HandleInput,\n    IntInput,\n    MessageTextInput,\n    SecretStrInput,\n)\nfrom langflow.schema import Data\n\n\nclass CassandraVectorStoreComponent(LCVectorStoreComponent):\n    display_name = \"Cassandra\"\n    description = \"Cassandra Vector Store with search capabilities\"\n    documentation = \"https://python.langchain.com/docs/modules/data_connection/vectorstores/integrations/cassandra\"\n    name = \"Cassandra\"\n    icon = \"Cassandra\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"database_ref\",\n            display_name=\"Contact Points / Astra Database ID\",\n            info=\"Contact points for the database (or AstraDB database ID)\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"username\", display_name=\"Username\", info=\"Username for the database (leave empty for AstraDB).\"\n        ),\n        SecretStrInput(\n            name=\"token\",\n            display_name=\"Password / AstraDB Token\",\n            info=\"User password for the database (or AstraDB token).\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"keyspace\",\n            display_name=\"Keyspace\",\n            info=\"Table Keyspace (or AstraDB namespace).\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"table_name\",\n            display_name=\"Table Name\",\n            info=\"The name of the table (or AstraDB collection) where vectors will be stored.\",\n            required=True,\n        ),\n        IntInput(\n            name=\"ttl_seconds\",\n            display_name=\"TTL Seconds\",\n            info=\"Optional time-to-live for the added texts.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"batch_size\",\n            display_name=\"Batch Size\",\n            info=\"Optional number of data to process in a single batch.\",\n            value=16,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"setup_mode\",\n            display_name=\"Setup Mode\",\n            info=\"Configuration mode for setting up the Cassandra table, with options like 'Sync', 'Async', or 'Off'.\",\n            options=[\"Sync\", \"Async\", \"Off\"],\n            value=\"Sync\",\n            advanced=True,\n        ),\n        DictInput(\n            name=\"cluster_kwargs\",\n            display_name=\"Cluster arguments\",\n            info=\"Optional dictionary of additional keyword arguments for the Cassandra cluster.\",\n            advanced=True,\n            list=True,\n        ),\n        *LCVectorStoreComponent.inputs,\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            value=4,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"search_type\",\n            display_name=\"Search Type\",\n            info=\"Search type to use\",\n            options=[\"Similarity\", \"Similarity with score threshold\", \"MMR (Max Marginal Relevance)\"],\n            value=\"Similarity\",\n            advanced=True,\n        ),\n        FloatInput(\n            name=\"search_score_threshold\",\n            display_name=\"Search Score Threshold\",\n            info=\"Minimum similarity score threshold for search results. \"\n            \"(when using 'Similarity with score threshold')\",\n            value=0,\n            advanced=True,\n        ),\n        DictInput(\n            name=\"search_filter\",\n            display_name=\"Search Metadata Filter\",\n            info=\"Optional dictionary of filters to apply to the search query.\",\n            advanced=True,\n            list=True,\n        ),\n        MessageTextInput(\n            name=\"body_search\",\n            display_name=\"Search Body\",\n            info=\"Document textual search terms to apply to the search query.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"enable_body_search\",\n            display_name=\"Enable Body Search\",\n            info=\"Flag to enable body search. This must be enabled BEFORE the table is created.\",\n            value=False,\n            advanced=True,\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> Cassandra:\n        try:\n            import cassio\n            from langchain_community.utilities.cassandra import SetupMode\n        except ImportError as e:\n            msg = \"Could not import cassio integration package. Please install it with `pip install cassio`.\"\n            raise ImportError(msg) from e\n\n        from uuid import UUID\n\n        database_ref = self.database_ref\n\n        try:\n            UUID(self.database_ref)\n            is_astra = True\n        except ValueError:\n            is_astra = False\n            if \",\" in self.database_ref:\n                # use a copy because we can't change the type of the parameter\n                database_ref = self.database_ref.split(\",\")\n\n        if is_astra:\n            cassio.init(\n                database_id=database_ref,\n                token=self.token,\n                cluster_kwargs=self.cluster_kwargs,\n            )\n        else:\n            cassio.init(\n                contact_points=database_ref,\n                username=self.username,\n                password=self.token,\n                cluster_kwargs=self.cluster_kwargs,\n            )\n\n        # Convert DataFrame to Data if needed using parent's method\n        self.ingest_data = self._prepare_ingest_data()\n\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                documents.append(_input)\n\n        body_index_options = [(\"index_analyzer\", \"STANDARD\")] if self.enable_body_search else None\n\n        if self.setup_mode == \"Off\":\n            setup_mode = SetupMode.OFF\n        elif self.setup_mode == \"Sync\":\n            setup_mode = SetupMode.SYNC\n        else:\n            setup_mode = SetupMode.ASYNC\n\n        if documents:\n            self.log(f\"Adding {len(documents)} documents to the Vector Store.\")\n            table = Cassandra.from_documents(\n                documents=documents,\n                embedding=self.embedding,\n                table_name=self.table_name,\n                keyspace=self.keyspace,\n                ttl_seconds=self.ttl_seconds or None,\n                batch_size=self.batch_size,\n                body_index_options=body_index_options,\n            )\n        else:\n            self.log(\"No documents to add to the Vector Store.\")\n            table = Cassandra(\n                embedding=self.embedding,\n                table_name=self.table_name,\n                keyspace=self.keyspace,\n                ttl_seconds=self.ttl_seconds or None,\n                body_index_options=body_index_options,\n                setup_mode=setup_mode,\n            )\n        return table\n\n    def _map_search_type(self) -> str:\n        if self.search_type == \"Similarity with score threshold\":\n            return \"similarity_score_threshold\"\n        if self.search_type == \"MMR (Max Marginal Relevance)\":\n            return \"mmr\"\n        return \"similarity\"\n\n    def search_documents(self) -> list[Data]:\n        vector_store = self.build_vector_store()\n\n        self.log(f\"Search input: {self.search_query}\")\n        self.log(f\"Search type: {self.search_type}\")\n        self.log(f\"Number of results: {self.number_of_results}\")\n\n        if self.search_query and isinstance(self.search_query, str) and self.search_query.strip():\n            try:\n                search_type = self._map_search_type()\n                search_args = self._build_search_args()\n\n                self.log(f\"Search args: {search_args}\")\n\n                docs = vector_store.search(query=self.search_query, search_type=search_type, **search_args)\n            except KeyError as e:\n                if \"content\" in str(e):\n                    msg = (\n                        \"You should ingest data through Langflow (or LangChain) to query it in Langflow. \"\n                        \"Your collection does not contain a field name 'content'.\"\n                    )\n                    raise ValueError(msg) from e\n                raise\n\n            self.log(f\"Retrieved documents: {len(docs)}\")\n\n            data = docs_to_data(docs)\n            self.status = data\n            return data\n        return []\n\n    def _build_search_args(self):\n        args = {\n            \"k\": self.number_of_results,\n            \"score_threshold\": self.search_score_threshold,\n        }\n\n        if self.search_filter:\n            clean_filter = {k: v for k, v in self.search_filter.items() if k and v}\n            if len(clean_filter) > 0:\n                args[\"filter\"] = clean_filter\n        if self.body_search:\n            if not self.enable_body_search:\n                msg = \"You should enable body search when creating the table to search the body field.\"\n                raise ValueError(msg)\n            args[\"body_search\"] = self.body_search\n        return args\n\n    def get_retriever_kwargs(self):\n        search_args = self._build_search_args()\n        return {\n            \"search_type\": self._map_search_type(),\n            \"search_kwargs\": search_args,\n        }\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "database_ref": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "database_ref",
        "value": "",
        "display_name": "Contact Points / Astra Database ID",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Contact points for the database (or AstraDB database ID)",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "enable_body_search": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "enable_body_search",
        "value": false,
        "display_name": "Enable Body Search",
        "advanced": true,
        "dynamic": false,
        "info": "Flag to enable body search. This must be enabled BEFORE the table is created.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "keyspace": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "keyspace",
        "value": "",
        "display_name": "Keyspace",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Table Keyspace (or AstraDB namespace).",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "number_of_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "number_of_results",
        "value": 4,
        "display_name": "Number of Results",
        "advanced": true,
        "dynamic": false,
        "info": "Number of results to return.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "search_filter": {
        "tool_mode": false,
        "trace_as_input": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_filter",
        "value": {},
        "display_name": "Search Metadata Filter",
        "advanced": true,
        "dynamic": false,
        "info": "Optional dictionary of filters to apply to the search query.",
        "title_case": false,
        "type": "dict",
        "_input_type": "DictInput"
      },
      "search_query": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "Enter a query...",
        "show": true,
        "name": "search_query",
        "value": "",
        "display_name": "Search Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Enter a query to run a similarity search.",
        "title_case": false,
        "type": "query",
        "_input_type": "QueryInput"
      },
      "search_score_threshold": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_score_threshold",
        "value": 0,
        "display_name": "Search Score Threshold",
        "advanced": true,
        "dynamic": false,
        "info": "Minimum similarity score threshold for search results. (when using 'Similarity with score threshold')",
        "title_case": false,
        "type": "float",
        "_input_type": "FloatInput"
      },
      "search_type": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "Similarity",
          "Similarity with score threshold",
          "MMR (Max Marginal Relevance)"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_type",
        "value": "Similarity",
        "display_name": "Search Type",
        "advanced": true,
        "dynamic": false,
        "info": "Search type to use",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "setup_mode": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "Sync",
          "Async",
          "Off"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "setup_mode",
        "value": "Sync",
        "display_name": "Setup Mode",
        "advanced": true,
        "dynamic": false,
        "info": "Configuration mode for setting up the Cassandra table, with options like 'Sync', 'Async', or 'Off'.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "should_cache_vector_store": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "should_cache_vector_store",
        "value": true,
        "display_name": "Cache Vector Store",
        "advanced": true,
        "dynamic": false,
        "info": "If True, the vector store will be cached for the current build of the component. This is useful for components that have multiple output methods and want to share the same vector store.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "table_name": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "table_name",
        "value": "",
        "display_name": "Table Name",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The name of the table (or AstraDB collection) where vectors will be stored.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "token": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "token",
        "value": "",
        "display_name": "Password / AstraDB Token",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "User password for the database (or AstraDB token).",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "ttl_seconds": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "ttl_seconds",
        "value": "",
        "display_name": "TTL Seconds",
        "advanced": true,
        "dynamic": false,
        "info": "Optional time-to-live for the added texts.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "username": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "username",
        "value": "",
        "display_name": "Username",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Username for the database (leave empty for AstraDB).",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      }
    },
    "description": "Cassandra Vector Store with search capabilities",
    "icon": "Cassandra",
    "base_classes": [
      "Data",
      "DataFrame"
    ],
    "display_name": "Cassandra",
    "documentation": "https://python.langchain.com/docs/modules/data_connection/vectorstores/integrations/cassandra",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "search_results",
        "display_name": "Search Results",
        "method": "search_documents",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "database_ref",
          "keyspace",
          "table_name",
          "token"
        ],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "database_ref",
      "username",
      "token",
      "keyspace",
      "table_name",
      "ttl_seconds",
      "batch_size",
      "setup_mode",
      "cluster_kwargs",
      "ingest_data",
      "search_query",
      "should_cache_vector_store",
      "embedding",
      "number_of_results",
      "search_type",
      "search_score_threshold",
      "search_filter",
      "body_search",
      "enable_body_search"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "VectaraRAG": {
    "template": {
      "_type": "Component",
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langflow.custom import Component\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.io import DropdownInput, FloatInput, IntInput, MessageTextInput, Output, SecretStrInput, StrInput\nfrom langflow.schema.message import Message\n\n\nclass VectaraRagComponent(Component):\n    display_name = \"Vectara RAG\"\n    description = \"Vectara's full end to end RAG\"\n    documentation = \"https://docs.vectara.com/docs\"\n    icon = \"Vectara\"\n    name = \"VectaraRAG\"\n    SUMMARIZER_PROMPTS = [\n        \"vectara-summary-ext-24-05-sml\",\n        \"vectara-summary-ext-24-05-med-omni\",\n        \"vectara-summary-ext-24-05-large\",\n        \"vectara-summary-ext-24-05-med\",\n        \"vectara-summary-ext-v1.3.0\",\n    ]\n\n    RERANKER_TYPES = [\"mmr\", \"rerank_multilingual_v1\", \"none\"]\n\n    RESPONSE_LANGUAGES = [\n        \"auto\",\n        \"eng\",\n        \"spa\",\n        \"fra\",\n        \"zho\",\n        \"deu\",\n        \"hin\",\n        \"ara\",\n        \"por\",\n        \"ita\",\n        \"jpn\",\n        \"kor\",\n        \"rus\",\n        \"tur\",\n        \"fas\",\n        \"vie\",\n        \"tha\",\n        \"heb\",\n        \"nld\",\n        \"ind\",\n        \"pol\",\n        \"ukr\",\n        \"ron\",\n        \"swe\",\n        \"ces\",\n        \"ell\",\n        \"ben\",\n        \"msa\",\n        \"urd\",\n    ]\n\n    field_order = [\"vectara_customer_id\", \"vectara_corpus_id\", \"vectara_api_key\", \"search_query\", \"reranker\"]\n\n    inputs = [\n        StrInput(name=\"vectara_customer_id\", display_name=\"Vectara Customer ID\", required=True),\n        StrInput(name=\"vectara_corpus_id\", display_name=\"Vectara Corpus ID\", required=True),\n        SecretStrInput(name=\"vectara_api_key\", display_name=\"Vectara API Key\", required=True),\n        MessageTextInput(\n            name=\"search_query\",\n            display_name=\"Search Query\",\n            info=\"The query to receive an answer on.\",\n            tool_mode=True,\n        ),\n        FloatInput(\n            name=\"lexical_interpolation\",\n            display_name=\"Hybrid Search Factor\",\n            range_spec=RangeSpec(min=0.005, max=0.1, step=0.005),\n            value=0.005,\n            advanced=True,\n            info=\"How much to weigh lexical scores compared to the embedding score. \"\n            \"0 means lexical search is not used at all, and 1 means only lexical search is used.\",\n        ),\n        MessageTextInput(\n            name=\"filter\",\n            display_name=\"Metadata Filters\",\n            value=\"\",\n            advanced=True,\n            info=\"The filter string to narrow the search to according to metadata attributes.\",\n        ),\n        DropdownInput(\n            name=\"reranker\",\n            display_name=\"Reranker Type\",\n            options=RERANKER_TYPES,\n            value=RERANKER_TYPES[0],\n            info=\"How to rerank the retrieved search results.\",\n        ),\n        IntInput(\n            name=\"reranker_k\",\n            display_name=\"Number of Results to Rerank\",\n            value=50,\n            range_spec=RangeSpec(min=1, max=100, step=1),\n            advanced=True,\n        ),\n        FloatInput(\n            name=\"diversity_bias\",\n            display_name=\"Diversity Bias\",\n            value=0.2,\n            range_spec=RangeSpec(min=0, max=1, step=0.01),\n            advanced=True,\n            info=\"Ranges from 0 to 1, with higher values indicating greater diversity (only applies to MMR reranker).\",\n        ),\n        IntInput(\n            name=\"max_results\",\n            display_name=\"Max Results to Summarize\",\n            value=7,\n            range_spec=RangeSpec(min=1, max=100, step=1),\n            advanced=True,\n            info=\"The maximum number of search results to be available to the prompt.\",\n        ),\n        DropdownInput(\n            name=\"response_lang\",\n            display_name=\"Response Language\",\n            options=RESPONSE_LANGUAGES,\n            value=\"eng\",\n            advanced=True,\n            info=\"Use the ISO 639-1 or 639-3 language code or auto to automatically detect the language.\",\n        ),\n        DropdownInput(\n            name=\"prompt\",\n            display_name=\"Prompt Name\",\n            options=SUMMARIZER_PROMPTS,\n            value=SUMMARIZER_PROMPTS[0],\n            advanced=True,\n            info=\"Only vectara-summary-ext-24-05-sml is for Growth customers; \"\n            \"all other prompts are for Scale customers only.\",\n        ),\n    ]\n\n    outputs = [\n        Output(name=\"answer\", display_name=\"Answer\", method=\"generate_response\"),\n    ]\n\n    def generate_response(\n        self,\n    ) -> Message:\n        text_output = \"\"\n\n        try:\n            from langchain_community.vectorstores import Vectara\n            from langchain_community.vectorstores.vectara import RerankConfig, SummaryConfig, VectaraQueryConfig\n        except ImportError as e:\n            msg = \"Could not import Vectara. Please install it with `pip install langchain-community`.\"\n            raise ImportError(msg) from e\n\n        vectara = Vectara(self.vectara_customer_id, self.vectara_corpus_id, self.vectara_api_key)\n        rerank_config = RerankConfig(self.reranker, self.reranker_k, self.diversity_bias)\n        summary_config = SummaryConfig(\n            is_enabled=True, max_results=self.max_results, response_lang=self.response_lang, prompt_name=self.prompt\n        )\n        config = VectaraQueryConfig(\n            lambda_val=self.lexical_interpolation,\n            filter=self.filter,\n            summary_config=summary_config,\n            rerank_config=rerank_config,\n        )\n        rag = vectara.as_rag(config)\n        response = rag.invoke(self.search_query, config={\"callbacks\": self.get_langchain_callbacks()})\n\n        text_output = response[\"answer\"]\n\n        return Message(text=text_output)\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "diversity_bias": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "range_spec": {
          "step_type": "float",
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "diversity_bias",
        "value": 0.2,
        "display_name": "Diversity Bias",
        "advanced": true,
        "dynamic": false,
        "info": "Ranges from 0 to 1, with higher values indicating greater diversity (only applies to MMR reranker).",
        "title_case": false,
        "type": "float",
        "_input_type": "FloatInput"
      },
      "filter": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "filter",
        "value": "",
        "display_name": "Metadata Filters",
        "advanced": true,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The filter string to narrow the search to according to metadata attributes.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "lexical_interpolation": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "range_spec": {
          "step_type": "float",
          "min": 0.005,
          "max": 0.1,
          "step": 0.005
        },
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "lexical_interpolation",
        "value": 0.005,
        "display_name": "Hybrid Search Factor",
        "advanced": true,
        "dynamic": false,
        "info": "How much to weigh lexical scores compared to the embedding score. 0 means lexical search is not used at all, and 1 means only lexical search is used.",
        "title_case": false,
        "type": "float",
        "_input_type": "FloatInput"
      },
      "max_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "range_spec": {
          "step_type": "float",
          "min": 1,
          "max": 100,
          "step": 1
        },
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "max_results",
        "value": 7,
        "display_name": "Max Results to Summarize",
        "advanced": true,
        "dynamic": false,
        "info": "The maximum number of search results to be available to the prompt.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "prompt": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "vectara-summary-ext-24-05-sml",
          "vectara-summary-ext-24-05-med-omni",
          "vectara-summary-ext-24-05-large",
          "vectara-summary-ext-24-05-med",
          "vectara-summary-ext-v1.3.0"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "prompt",
        "value": "vectara-summary-ext-24-05-sml",
        "display_name": "Prompt Name",
        "advanced": true,
        "dynamic": false,
        "info": "Only vectara-summary-ext-24-05-sml is for Growth customers; all other prompts are for Scale customers only.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "reranker": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "mmr",
          "rerank_multilingual_v1",
          "none"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "reranker",
        "value": "mmr",
        "display_name": "Reranker Type",
        "advanced": false,
        "dynamic": false,
        "info": "How to rerank the retrieved search results.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "reranker_k": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "range_spec": {
          "step_type": "float",
          "min": 1,
          "max": 100,
          "step": 1
        },
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "reranker_k",
        "value": 50,
        "display_name": "Number of Results to Rerank",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "response_lang": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "auto",
          "eng",
          "spa",
          "fra",
          "zho",
          "deu",
          "hin",
          "ara",
          "por",
          "ita",
          "jpn",
          "kor",
          "rus",
          "tur",
          "fas",
          "vie",
          "tha",
          "heb",
          "nld",
          "ind",
          "pol",
          "ukr",
          "ron",
          "swe",
          "ces",
          "ell",
          "ben",
          "msa",
          "urd"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "response_lang",
        "value": "eng",
        "display_name": "Response Language",
        "advanced": true,
        "dynamic": false,
        "info": "Use the ISO 639-1 or 639-3 language code or auto to automatically detect the language.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "search_query": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_query",
        "value": "",
        "display_name": "Search Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The query to receive an answer on.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "vectara_api_key": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "vectara_api_key",
        "value": "",
        "display_name": "Vectara API Key",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "vectara_corpus_id": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "vectara_corpus_id",
        "value": "",
        "display_name": "Vectara Corpus ID",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "vectara_customer_id": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "vectara_customer_id",
        "value": "",
        "display_name": "Vectara Customer ID",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      }
    },
    "description": "Vectara's full end to end RAG",
    "icon": "Vectara",
    "base_classes": [
      "Message"
    ],
    "display_name": "Vectara RAG",
    "documentation": "https://docs.vectara.com/docs",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Message"
        ],
        "selected": "Message",
        "name": "answer",
        "display_name": "Answer",
        "method": "generate_response",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "vectara_customer_id",
      "vectara_corpus_id",
      "vectara_api_key",
      "search_query",
      "lexical_interpolation",
      "filter",
      "reranker",
      "reranker_k",
      "diversity_bias",
      "max_results",
      "response_lang",
      "prompt"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "Elasticsearch": {
    "template": {
      "_type": "Component",
      "embedding": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "embedding",
        "value": "",
        "display_name": "Embedding",
        "advanced": false,
        "input_types": [
          "Embeddings"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "ingest_data": {
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "ingest_data",
        "value": "",
        "display_name": "Ingest Data",
        "advanced": false,
        "input_types": [
          "Data",
          "DataFrame"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "api_key": {
        "load_from_db": true,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "api_key",
        "value": "",
        "display_name": "Elastic API Key",
        "advanced": true,
        "input_types": [],
        "dynamic": false,
        "info": "API Key for Elastic Cloud authentication. If used, 'username' and 'password' are not required.",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "cloud_id": {
        "load_from_db": true,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "cloud_id",
        "value": "",
        "display_name": "Elastic Cloud ID",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "Use this for Elastic Cloud deployments. Do not use together with 'Elasticsearch URL'.",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from typing import Any\n\nfrom langchain.schema import Document\nfrom langchain_elasticsearch import ElasticsearchStore\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.io import (\n    DropdownInput,\n    FloatInput,\n    HandleInput,\n    IntInput,\n    SecretStrInput,\n    StrInput,\n)\nfrom langflow.schema import Data\n\n\nclass ElasticsearchVectorStoreComponent(LCVectorStoreComponent):\n    \"\"\"Elasticsearch Vector Store with with advanced, customizable search capabilities.\"\"\"\n\n    display_name: str = \"Elasticsearch\"\n    description: str = \"Elasticsearch Vector Store with with advanced, customizable search capabilities.\"\n    name = \"Elasticsearch\"\n    icon = \"ElasticsearchStore\"\n\n    inputs = [\n        StrInput(\n            name=\"elasticsearch_url\",\n            display_name=\"Elasticsearch URL\",\n            value=\"http://localhost:9200\",\n            info=\"URL for self-managed Elasticsearch deployments (e.g., http://localhost:9200). \"\n            \"Do not use with Elastic Cloud deployments, use Elastic Cloud ID instead.\",\n        ),\n        SecretStrInput(\n            name=\"cloud_id\",\n            display_name=\"Elastic Cloud ID\",\n            value=\"\",\n            info=\"Use this for Elastic Cloud deployments. Do not use together with 'Elasticsearch URL'.\",\n        ),\n        StrInput(\n            name=\"index_name\",\n            display_name=\"Index Name\",\n            value=\"langflow\",\n            info=\"The index name where the vectors will be stored in Elasticsearch cluster.\",\n        ),\n        *LCVectorStoreComponent.inputs,\n        StrInput(\n            name=\"username\",\n            display_name=\"Username\",\n            value=\"\",\n            advanced=False,\n            info=(\n                \"Elasticsearch username (e.g., 'elastic'). \"\n                \"Required for both local and Elastic Cloud setups unless API keys are used.\"\n            ),\n        ),\n        SecretStrInput(\n            name=\"password\",\n            display_name=\"Password\",\n            value=\"\",\n            advanced=False,\n            info=(\n                \"Elasticsearch password for the specified user. \"\n                \"Required for both local and Elastic Cloud setups unless API keys are used.\"\n            ),\n        ),\n        HandleInput(\n            name=\"embedding\",\n            display_name=\"Embedding\",\n            input_types=[\"Embeddings\"],\n        ),\n        DropdownInput(\n            name=\"search_type\",\n            display_name=\"Search Type\",\n            options=[\"similarity\", \"mmr\"],\n            value=\"similarity\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            advanced=True,\n            value=4,\n        ),\n        FloatInput(\n            name=\"search_score_threshold\",\n            display_name=\"Search Score Threshold\",\n            info=\"Minimum similarity score threshold for search results.\",\n            value=0.0,\n            advanced=True,\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"Elastic API Key\",\n            value=\"\",\n            advanced=True,\n            info=\"API Key for Elastic Cloud authentication. If used, 'username' and 'password' are not required.\",\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> ElasticsearchStore:\n        \"\"\"Builds the Elasticsearch Vector Store object.\"\"\"\n        if self.cloud_id and self.elasticsearch_url:\n            msg = (\n                \"Both 'cloud_id' and 'elasticsearch_url' provided. \"\n                \"Please use only one based on your deployment (Cloud or Local).\"\n            )\n            raise ValueError(msg)\n\n        es_params = {\n            \"index_name\": self.index_name,\n            \"embedding\": self.embedding,\n            \"es_user\": self.username or None,\n            \"es_password\": self.password or None,\n        }\n\n        if self.cloud_id:\n            es_params[\"es_cloud_id\"] = self.cloud_id\n        else:\n            es_params[\"es_url\"] = self.elasticsearch_url\n\n        if self.api_key:\n            es_params[\"api_key\"] = self.api_key\n\n        elasticsearch = ElasticsearchStore(**es_params)\n\n        # If documents are provided, add them to the store\n        if self.ingest_data:\n            documents = self._prepare_documents()\n            if documents:\n                elasticsearch.add_documents(documents)\n\n        return elasticsearch\n\n    def _prepare_documents(self) -> list[Document]:\n        \"\"\"Prepares documents from the input data to add to the vector store.\"\"\"\n        self.ingest_data = self._prepare_ingest_data()\n\n        documents = []\n        for data in self.ingest_data:\n            if isinstance(data, Data):\n                documents.append(data.to_lc_document())\n            else:\n                error_message = \"Vector Store Inputs must be Data objects.\"\n                self.log(error_message)\n                raise TypeError(error_message)\n        return documents\n\n    def _add_documents_to_vector_store(self, vector_store: \"ElasticsearchStore\") -> None:\n        \"\"\"Adds documents to the Vector Store.\"\"\"\n        documents = self._prepare_documents()\n        if documents and self.embedding:\n            self.log(f\"Adding {len(documents)} documents to the Vector Store.\")\n            vector_store.add_documents(documents)\n        else:\n            self.log(\"No documents to add to the Vector Store.\")\n\n    def search(self, query: str | None = None) -> list[dict[str, Any]]:\n        \"\"\"Search for similar documents in the vector store or retrieve all documents if no query is provided.\"\"\"\n        vector_store = self.build_vector_store()\n        search_kwargs = {\n            \"k\": self.number_of_results,\n            \"score_threshold\": self.search_score_threshold,\n        }\n\n        if query:\n            search_type = self.search_type.lower()\n            if search_type not in {\"similarity\", \"mmr\"}:\n                msg = f\"Invalid search type: {self.search_type}\"\n                self.log(msg)\n                raise ValueError(msg)\n            try:\n                if search_type == \"similarity\":\n                    results = vector_store.similarity_search_with_score(query, **search_kwargs)\n                elif search_type == \"mmr\":\n                    results = vector_store.max_marginal_relevance_search(query, **search_kwargs)\n            except Exception as e:\n                msg = (\n                    \"Error occurred while querying the Elasticsearch VectorStore,\"\n                    \" there is no Data into the VectorStore.\"\n                )\n                self.log(msg)\n                raise ValueError(msg) from e\n            return [\n                {\"page_content\": doc.page_content, \"metadata\": doc.metadata, \"score\": score} for doc, score in results\n            ]\n        results = self.get_all_documents(vector_store, **search_kwargs)\n        return [{\"page_content\": doc.page_content, \"metadata\": doc.metadata, \"score\": score} for doc, score in results]\n\n    def get_all_documents(self, vector_store: ElasticsearchStore, **kwargs) -> list[tuple[Document, float]]:\n        \"\"\"Retrieve all documents from the vector store.\"\"\"\n        client = vector_store.client\n        index_name = self.index_name\n\n        query = {\n            \"query\": {\"match_all\": {}},\n            \"size\": kwargs.get(\"k\", self.number_of_results),\n        }\n\n        response = client.search(index=index_name, body=query)\n\n        results = []\n        for hit in response[\"hits\"][\"hits\"]:\n            doc = Document(\n                page_content=hit[\"_source\"].get(\"text\", \"\"),\n                metadata=hit[\"_source\"].get(\"metadata\", {}),\n            )\n            score = hit[\"_score\"]\n            results.append((doc, score))\n\n        return results\n\n    def search_documents(self) -> list[Data]:\n        \"\"\"Search for documents in the vector store based on the search input.\n\n        If no search input is provided, retrieve all documents.\n        \"\"\"\n        results = self.search(self.search_query)\n        retrieved_data = [\n            Data(\n                text=result[\"page_content\"],\n                file_path=result[\"metadata\"].get(\"file_path\", \"\"),\n            )\n            for result in results\n        ]\n        self.status = retrieved_data\n        return retrieved_data\n\n    def get_retriever_kwargs(self):\n        \"\"\"Get the keyword arguments for the retriever.\"\"\"\n        return {\n            \"search_type\": self.search_type.lower(),\n            \"search_kwargs\": {\n                \"k\": self.number_of_results,\n                \"score_threshold\": self.search_score_threshold,\n            },\n        }\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "elasticsearch_url": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "elasticsearch_url",
        "value": "http://localhost:9200",
        "display_name": "Elasticsearch URL",
        "advanced": false,
        "dynamic": false,
        "info": "URL for self-managed Elasticsearch deployments (e.g., http://localhost:9200). Do not use with Elastic Cloud deployments, use Elastic Cloud ID instead.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "index_name": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "index_name",
        "value": "langflow",
        "display_name": "Index Name",
        "advanced": false,
        "dynamic": false,
        "info": "The index name where the vectors will be stored in Elasticsearch cluster.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "number_of_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "number_of_results",
        "value": 4,
        "display_name": "Number of Results",
        "advanced": true,
        "dynamic": false,
        "info": "Number of results to return.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "password": {
        "load_from_db": true,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "password",
        "value": "",
        "display_name": "Password",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "Elasticsearch password for the specified user. Required for both local and Elastic Cloud setups unless API keys are used.",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "search_query": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "Enter a query...",
        "show": true,
        "name": "search_query",
        "value": "",
        "display_name": "Search Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Enter a query to run a similarity search.",
        "title_case": false,
        "type": "query",
        "_input_type": "QueryInput"
      },
      "search_score_threshold": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_score_threshold",
        "value": 0,
        "display_name": "Search Score Threshold",
        "advanced": true,
        "dynamic": false,
        "info": "Minimum similarity score threshold for search results.",
        "title_case": false,
        "type": "float",
        "_input_type": "FloatInput"
      },
      "search_type": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "similarity",
          "mmr"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_type",
        "value": "similarity",
        "display_name": "Search Type",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "should_cache_vector_store": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "should_cache_vector_store",
        "value": true,
        "display_name": "Cache Vector Store",
        "advanced": true,
        "dynamic": false,
        "info": "If True, the vector store will be cached for the current build of the component. This is useful for components that have multiple output methods and want to share the same vector store.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "username": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "username",
        "value": "",
        "display_name": "Username",
        "advanced": false,
        "dynamic": false,
        "info": "Elasticsearch username (e.g., 'elastic'). Required for both local and Elastic Cloud setups unless API keys are used.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      }
    },
    "description": "Elasticsearch Vector Store with with advanced, customizable search capabilities.",
    "icon": "ElasticsearchStore",
    "base_classes": [
      "Data",
      "DataFrame"
    ],
    "display_name": "Elasticsearch",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "search_results",
        "display_name": "Search Results",
        "method": "search_documents",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "elasticsearch_url",
      "cloud_id",
      "index_name",
      "ingest_data",
      "search_query",
      "should_cache_vector_store",
      "username",
      "password",
      "embedding",
      "search_type",
      "number_of_results",
      "search_score_threshold",
      "api_key"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "CassandraGraph": {
    "template": {
      "_type": "Component",
      "embedding": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "embedding",
        "value": "",
        "display_name": "Embedding",
        "advanced": false,
        "input_types": [
          "Embeddings"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "ingest_data": {
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "ingest_data",
        "value": "",
        "display_name": "Ingest Data",
        "advanced": false,
        "input_types": [
          "Data",
          "DataFrame"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "cluster_kwargs": {
        "tool_mode": false,
        "trace_as_input": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "cluster_kwargs",
        "value": {},
        "display_name": "Cluster arguments",
        "advanced": true,
        "dynamic": false,
        "info": "Optional dictionary of additional keyword arguments for the Cassandra cluster.",
        "title_case": false,
        "type": "dict",
        "_input_type": "DictInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from uuid import UUID\n\nfrom langchain_community.graph_vectorstores import CassandraGraphVectorStore\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.inputs import DictInput, FloatInput\nfrom langflow.io import (\n    DropdownInput,\n    HandleInput,\n    IntInput,\n    MessageTextInput,\n    SecretStrInput,\n)\nfrom langflow.schema import Data\n\n\nclass CassandraGraphVectorStoreComponent(LCVectorStoreComponent):\n    display_name = \"Cassandra Graph\"\n    description = \"Cassandra Graph Vector Store\"\n    name = \"CassandraGraph\"\n    icon = \"Cassandra\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"database_ref\",\n            display_name=\"Contact Points / Astra Database ID\",\n            info=\"Contact points for the database (or AstraDB database ID)\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"username\", display_name=\"Username\", info=\"Username for the database (leave empty for AstraDB).\"\n        ),\n        SecretStrInput(\n            name=\"token\",\n            display_name=\"Password / AstraDB Token\",\n            info=\"User password for the database (or AstraDB token).\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"keyspace\",\n            display_name=\"Keyspace\",\n            info=\"Table Keyspace (or AstraDB namespace).\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"table_name\",\n            display_name=\"Table Name\",\n            info=\"The name of the table (or AstraDB collection) where vectors will be stored.\",\n            required=True,\n        ),\n        DropdownInput(\n            name=\"setup_mode\",\n            display_name=\"Setup Mode\",\n            info=\"Configuration mode for setting up the Cassandra table, with options like 'Sync' or 'Off'.\",\n            options=[\"Sync\", \"Off\"],\n            value=\"Sync\",\n            advanced=True,\n        ),\n        DictInput(\n            name=\"cluster_kwargs\",\n            display_name=\"Cluster arguments\",\n            info=\"Optional dictionary of additional keyword arguments for the Cassandra cluster.\",\n            advanced=True,\n            list=True,\n        ),\n        *LCVectorStoreComponent.inputs,\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            value=4,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"search_type\",\n            display_name=\"Search Type\",\n            info=\"Search type to use\",\n            options=[\n                \"Traversal\",\n                \"MMR traversal\",\n                \"Similarity\",\n                \"Similarity with score threshold\",\n                \"MMR (Max Marginal Relevance)\",\n            ],\n            value=\"Traversal\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"depth\",\n            display_name=\"Depth of traversal\",\n            info=\"The maximum depth of edges to traverse. (when using 'Traversal' or 'MMR traversal')\",\n            value=1,\n            advanced=True,\n        ),\n        FloatInput(\n            name=\"search_score_threshold\",\n            display_name=\"Search Score Threshold\",\n            info=\"Minimum similarity score threshold for search results. \"\n            \"(when using 'Similarity with score threshold')\",\n            value=0,\n            advanced=True,\n        ),\n        DictInput(\n            name=\"search_filter\",\n            display_name=\"Search Metadata Filter\",\n            info=\"Optional dictionary of filters to apply to the search query.\",\n            advanced=True,\n            list=True,\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> CassandraGraphVectorStore:\n        try:\n            import cassio\n            from langchain_community.utilities.cassandra import SetupMode\n        except ImportError as e:\n            msg = \"Could not import cassio integration package. Please install it with `pip install cassio`.\"\n            raise ImportError(msg) from e\n\n        database_ref = self.database_ref\n\n        try:\n            UUID(self.database_ref)\n            is_astra = True\n        except ValueError:\n            is_astra = False\n            if \",\" in self.database_ref:\n                # use a copy because we can't change the type of the parameter\n                database_ref = self.database_ref.split(\",\")\n\n        if is_astra:\n            cassio.init(\n                database_id=database_ref,\n                token=self.token,\n                cluster_kwargs=self.cluster_kwargs,\n            )\n        else:\n            cassio.init(\n                contact_points=database_ref,\n                username=self.username,\n                password=self.token,\n                cluster_kwargs=self.cluster_kwargs,\n            )\n\n        self.ingest_data = self._prepare_ingest_data()\n\n        documents = []\n\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                documents.append(_input)\n\n        setup_mode = SetupMode.OFF if self.setup_mode == \"Off\" else SetupMode.SYNC\n\n        if documents:\n            self.log(f\"Adding {len(documents)} documents to the Vector Store.\")\n            store = CassandraGraphVectorStore.from_documents(\n                documents=documents,\n                embedding=self.embedding,\n                node_table=self.table_name,\n                keyspace=self.keyspace,\n            )\n        else:\n            self.log(\"No documents to add to the Vector Store.\")\n            store = CassandraGraphVectorStore(\n                embedding=self.embedding,\n                node_table=self.table_name,\n                keyspace=self.keyspace,\n                setup_mode=setup_mode,\n            )\n        return store\n\n    def _map_search_type(self) -> str:\n        if self.search_type == \"Similarity\":\n            return \"similarity\"\n        if self.search_type == \"Similarity with score threshold\":\n            return \"similarity_score_threshold\"\n        if self.search_type == \"MMR (Max Marginal Relevance)\":\n            return \"mmr\"\n        if self.search_type == \"MMR Traversal\":\n            return \"mmr_traversal\"\n        return \"traversal\"\n\n    def search_documents(self) -> list[Data]:\n        vector_store = self.build_vector_store()\n\n        self.log(f\"Search input: {self.search_query}\")\n        self.log(f\"Search type: {self.search_type}\")\n        self.log(f\"Number of results: {self.number_of_results}\")\n\n        if self.search_query and isinstance(self.search_query, str) and self.search_query.strip():\n            try:\n                search_type = self._map_search_type()\n                search_args = self._build_search_args()\n\n                self.log(f\"Search args: {search_args}\")\n\n                docs = vector_store.search(query=self.search_query, search_type=search_type, **search_args)\n            except KeyError as e:\n                if \"content\" in str(e):\n                    msg = (\n                        \"You should ingest data through Langflow (or LangChain) to query it in Langflow. \"\n                        \"Your collection does not contain a field name 'content'.\"\n                    )\n                    raise ValueError(msg) from e\n                raise\n\n            self.log(f\"Retrieved documents: {len(docs)}\")\n\n            data = docs_to_data(docs)\n            self.status = data\n            return data\n        return []\n\n    def _build_search_args(self):\n        args = {\n            \"k\": self.number_of_results,\n            \"score_threshold\": self.search_score_threshold,\n            \"depth\": self.depth,\n        }\n\n        if self.search_filter:\n            clean_filter = {k: v for k, v in self.search_filter.items() if k and v}\n            if len(clean_filter) > 0:\n                args[\"filter\"] = clean_filter\n        return args\n\n    def get_retriever_kwargs(self):\n        search_args = self._build_search_args()\n        return {\n            \"search_type\": self._map_search_type(),\n            \"search_kwargs\": search_args,\n        }\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "database_ref": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "database_ref",
        "value": "",
        "display_name": "Contact Points / Astra Database ID",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Contact points for the database (or AstraDB database ID)",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "depth": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "depth",
        "value": 1,
        "display_name": "Depth of traversal",
        "advanced": true,
        "dynamic": false,
        "info": "The maximum depth of edges to traverse. (when using 'Traversal' or 'MMR traversal')",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "keyspace": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "keyspace",
        "value": "",
        "display_name": "Keyspace",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Table Keyspace (or AstraDB namespace).",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "number_of_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "number_of_results",
        "value": 4,
        "display_name": "Number of Results",
        "advanced": true,
        "dynamic": false,
        "info": "Number of results to return.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "search_filter": {
        "tool_mode": false,
        "trace_as_input": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_filter",
        "value": {},
        "display_name": "Search Metadata Filter",
        "advanced": true,
        "dynamic": false,
        "info": "Optional dictionary of filters to apply to the search query.",
        "title_case": false,
        "type": "dict",
        "_input_type": "DictInput"
      },
      "search_query": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "Enter a query...",
        "show": true,
        "name": "search_query",
        "value": "",
        "display_name": "Search Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Enter a query to run a similarity search.",
        "title_case": false,
        "type": "query",
        "_input_type": "QueryInput"
      },
      "search_score_threshold": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_score_threshold",
        "value": 0,
        "display_name": "Search Score Threshold",
        "advanced": true,
        "dynamic": false,
        "info": "Minimum similarity score threshold for search results. (when using 'Similarity with score threshold')",
        "title_case": false,
        "type": "float",
        "_input_type": "FloatInput"
      },
      "search_type": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "Traversal",
          "MMR traversal",
          "Similarity",
          "Similarity with score threshold",
          "MMR (Max Marginal Relevance)"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_type",
        "value": "Traversal",
        "display_name": "Search Type",
        "advanced": true,
        "dynamic": false,
        "info": "Search type to use",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "setup_mode": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "Sync",
          "Off"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "setup_mode",
        "value": "Sync",
        "display_name": "Setup Mode",
        "advanced": true,
        "dynamic": false,
        "info": "Configuration mode for setting up the Cassandra table, with options like 'Sync' or 'Off'.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "should_cache_vector_store": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "should_cache_vector_store",
        "value": true,
        "display_name": "Cache Vector Store",
        "advanced": true,
        "dynamic": false,
        "info": "If True, the vector store will be cached for the current build of the component. This is useful for components that have multiple output methods and want to share the same vector store.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "table_name": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "table_name",
        "value": "",
        "display_name": "Table Name",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The name of the table (or AstraDB collection) where vectors will be stored.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "token": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "token",
        "value": "",
        "display_name": "Password / AstraDB Token",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "User password for the database (or AstraDB token).",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "username": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "username",
        "value": "",
        "display_name": "Username",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Username for the database (leave empty for AstraDB).",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      }
    },
    "description": "Cassandra Graph Vector Store",
    "icon": "Cassandra",
    "base_classes": [
      "Data",
      "DataFrame"
    ],
    "display_name": "Cassandra Graph",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "search_results",
        "display_name": "Search Results",
        "method": "search_documents",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "database_ref",
          "keyspace",
          "table_name",
          "token"
        ],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "database_ref",
      "username",
      "token",
      "keyspace",
      "table_name",
      "setup_mode",
      "cluster_kwargs",
      "ingest_data",
      "search_query",
      "should_cache_vector_store",
      "embedding",
      "number_of_results",
      "search_type",
      "depth",
      "search_score_threshold",
      "search_filter"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "Milvus": {
    "template": {
      "_type": "Component",
      "embedding": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "embedding",
        "value": "",
        "display_name": "Embedding",
        "advanced": false,
        "input_types": [
          "Embeddings"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "ingest_data": {
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "ingest_data",
        "value": "",
        "display_name": "Ingest Data",
        "advanced": false,
        "input_types": [
          "Data",
          "DataFrame"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.io import (\n    BoolInput,\n    DictInput,\n    DropdownInput,\n    FloatInput,\n    HandleInput,\n    IntInput,\n    SecretStrInput,\n    StrInput,\n)\nfrom langflow.schema import Data\n\n\nclass MilvusVectorStoreComponent(LCVectorStoreComponent):\n    \"\"\"Milvus vector store with search capabilities.\"\"\"\n\n    display_name: str = \"Milvus\"\n    description: str = \"Milvus vector store with search capabilities\"\n    name = \"Milvus\"\n    icon = \"Milvus\"\n\n    inputs = [\n        StrInput(name=\"collection_name\", display_name=\"Collection Name\", value=\"langflow\"),\n        StrInput(name=\"collection_description\", display_name=\"Collection Description\", value=\"\"),\n        StrInput(\n            name=\"uri\",\n            display_name=\"Connection URI\",\n            value=\"http://localhost:19530\",\n        ),\n        SecretStrInput(\n            name=\"password\",\n            display_name=\"Token\",\n            value=\"\",\n            info=\"Ignore this field if no token is required to make connection.\",\n        ),\n        DictInput(name=\"connection_args\", display_name=\"Other Connection Arguments\", advanced=True),\n        StrInput(name=\"primary_field\", display_name=\"Primary Field Name\", value=\"pk\"),\n        StrInput(name=\"text_field\", display_name=\"Text Field Name\", value=\"text\"),\n        StrInput(name=\"vector_field\", display_name=\"Vector Field Name\", value=\"vector\"),\n        DropdownInput(\n            name=\"consistency_level\",\n            display_name=\"Consistencey Level\",\n            options=[\"Bounded\", \"Session\", \"Strong\", \"Eventual\"],\n            value=\"Session\",\n            advanced=True,\n        ),\n        DictInput(name=\"index_params\", display_name=\"Index Parameters\", advanced=True),\n        DictInput(name=\"search_params\", display_name=\"Search Parameters\", advanced=True),\n        BoolInput(name=\"drop_old\", display_name=\"Drop Old Collection\", value=False, advanced=True),\n        FloatInput(name=\"timeout\", display_name=\"Timeout\", advanced=True),\n        *LCVectorStoreComponent.inputs,\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            value=4,\n            advanced=True,\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self):\n        try:\n            from langchain_milvus.vectorstores import Milvus as LangchainMilvus\n        except ImportError as e:\n            msg = \"Could not import Milvus integration package. Please install it with `pip install langchain-milvus`.\"\n            raise ImportError(msg) from e\n        self.connection_args.update(uri=self.uri, token=self.password)\n        milvus_store = LangchainMilvus(\n            embedding_function=self.embedding,\n            collection_name=self.collection_name,\n            collection_description=self.collection_description,\n            connection_args=self.connection_args,\n            consistency_level=self.consistency_level,\n            index_params=self.index_params,\n            search_params=self.search_params,\n            drop_old=self.drop_old,\n            auto_id=True,\n            primary_field=self.primary_field,\n            text_field=self.text_field,\n            vector_field=self.vector_field,\n            timeout=self.timeout,\n        )\n\n        # Convert DataFrame to Data if needed using parent's method\n        self.ingest_data = self._prepare_ingest_data()\n\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                documents.append(_input)\n\n        if documents:\n            milvus_store.add_documents(documents)\n\n        return milvus_store\n\n    def search_documents(self) -> list[Data]:\n        vector_store = self.build_vector_store()\n\n        if self.search_query and isinstance(self.search_query, str) and self.search_query.strip():\n            docs = vector_store.similarity_search(\n                query=self.search_query,\n                k=self.number_of_results,\n            )\n\n            data = docs_to_data(docs)\n            self.status = data\n            return data\n        return []\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "collection_description": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "collection_description",
        "value": "",
        "display_name": "Collection Description",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "collection_name": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "collection_name",
        "value": "langflow",
        "display_name": "Collection Name",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "connection_args": {
        "tool_mode": false,
        "trace_as_input": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "connection_args",
        "value": {},
        "display_name": "Other Connection Arguments",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "dict",
        "_input_type": "DictInput"
      },
      "consistency_level": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "Bounded",
          "Session",
          "Strong",
          "Eventual"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "consistency_level",
        "value": "Session",
        "display_name": "Consistencey Level",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "drop_old": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "drop_old",
        "value": false,
        "display_name": "Drop Old Collection",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "index_params": {
        "tool_mode": false,
        "trace_as_input": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "index_params",
        "value": {},
        "display_name": "Index Parameters",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "dict",
        "_input_type": "DictInput"
      },
      "number_of_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "number_of_results",
        "value": 4,
        "display_name": "Number of Results",
        "advanced": true,
        "dynamic": false,
        "info": "Number of results to return.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "password": {
        "load_from_db": true,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "password",
        "value": "",
        "display_name": "Token",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "Ignore this field if no token is required to make connection.",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "primary_field": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "primary_field",
        "value": "pk",
        "display_name": "Primary Field Name",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "search_params": {
        "tool_mode": false,
        "trace_as_input": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_params",
        "value": {},
        "display_name": "Search Parameters",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "dict",
        "_input_type": "DictInput"
      },
      "search_query": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "Enter a query...",
        "show": true,
        "name": "search_query",
        "value": "",
        "display_name": "Search Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Enter a query to run a similarity search.",
        "title_case": false,
        "type": "query",
        "_input_type": "QueryInput"
      },
      "should_cache_vector_store": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "should_cache_vector_store",
        "value": true,
        "display_name": "Cache Vector Store",
        "advanced": true,
        "dynamic": false,
        "info": "If True, the vector store will be cached for the current build of the component. This is useful for components that have multiple output methods and want to share the same vector store.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "text_field": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "text_field",
        "value": "text",
        "display_name": "Text Field Name",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "timeout": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "timeout",
        "value": "",
        "display_name": "Timeout",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "float",
        "_input_type": "FloatInput"
      },
      "uri": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "uri",
        "value": "http://localhost:19530",
        "display_name": "Connection URI",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "vector_field": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "vector_field",
        "value": "vector",
        "display_name": "Vector Field Name",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      }
    },
    "description": "Milvus vector store with search capabilities",
    "icon": "Milvus",
    "base_classes": [
      "Data",
      "DataFrame"
    ],
    "display_name": "Milvus",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "search_results",
        "display_name": "Search Results",
        "method": "search_documents",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "collection_name",
      "collection_description",
      "uri",
      "password",
      "connection_args",
      "primary_field",
      "text_field",
      "vector_field",
      "consistency_level",
      "index_params",
      "search_params",
      "drop_old",
      "timeout",
      "ingest_data",
      "search_query",
      "should_cache_vector_store",
      "embedding",
      "number_of_results"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "Clickhouse": {
    "template": {
      "_type": "Component",
      "embedding": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "embedding",
        "value": "",
        "display_name": "Embedding",
        "advanced": false,
        "input_types": [
          "Embeddings"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "ingest_data": {
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "ingest_data",
        "value": "",
        "display_name": "Ingest Data",
        "advanced": false,
        "input_types": [
          "Data",
          "DataFrame"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain_community.vectorstores import Clickhouse, ClickhouseSettings\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.inputs import BoolInput, FloatInput\nfrom langflow.io import (\n    DictInput,\n    DropdownInput,\n    HandleInput,\n    IntInput,\n    SecretStrInput,\n    StrInput,\n)\nfrom langflow.schema import Data\n\n\nclass ClickhouseVectorStoreComponent(LCVectorStoreComponent):\n    display_name = \"Clickhouse\"\n    description = \"Clickhouse Vector Store with search capabilities\"\n    name = \"Clickhouse\"\n    icon = \"Clickhouse\"\n\n    inputs = [\n        StrInput(name=\"host\", display_name=\"hostname\", required=True, value=\"localhost\"),\n        IntInput(name=\"port\", display_name=\"port\", required=True, value=8123),\n        StrInput(name=\"database\", display_name=\"database\", required=True),\n        StrInput(name=\"table\", display_name=\"Table name\", required=True),\n        StrInput(name=\"username\", display_name=\"The ClickHouse user name.\", required=True),\n        SecretStrInput(name=\"password\", display_name=\"The password for username.\", required=True),\n        DropdownInput(\n            name=\"index_type\",\n            display_name=\"index_type\",\n            options=[\"annoy\", \"vector_similarity\"],\n            info=\"Type of the index.\",\n            value=\"annoy\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"metric\",\n            display_name=\"metric\",\n            options=[\"angular\", \"euclidean\", \"manhattan\", \"hamming\", \"dot\"],\n            info=\"Metric to compute distance.\",\n            value=\"angular\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"secure\",\n            display_name=\"Use https/TLS. This overrides inferred values from the interface or port arguments.\",\n            value=False,\n            advanced=True,\n        ),\n        StrInput(name=\"index_param\", display_name=\"Param of the index\", value=\"100,'L2Distance'\", advanced=True),\n        DictInput(name=\"index_query_params\", display_name=\"index query params\", advanced=True),\n        *LCVectorStoreComponent.inputs,\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            value=4,\n            advanced=True,\n        ),\n        FloatInput(name=\"score_threshold\", display_name=\"Score threshold\", advanced=True),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> Clickhouse:\n        try:\n            import clickhouse_connect\n        except ImportError as e:\n            msg = (\n                \"Failed to import Clickhouse dependencies. \"\n                \"Install it using `pip install langflow[clickhouse-connect] --pre`\"\n            )\n            raise ImportError(msg) from e\n\n        try:\n            client = clickhouse_connect.get_client(\n                host=self.host, port=self.port, username=self.username, password=self.password\n            )\n            client.command(\"SELECT 1\")\n        except Exception as e:\n            msg = f\"Failed to connect to Clickhouse: {e}\"\n            raise ValueError(msg) from e\n\n        # Convert DataFrame to Data if needed using parent's method\n        self.ingest_data = self._prepare_ingest_data()\n\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                documents.append(_input)\n\n        kwargs = {}\n        if self.index_param:\n            kwargs[\"index_param\"] = self.index_param.split(\",\")\n        if self.index_query_params:\n            kwargs[\"index_query_params\"] = self.index_query_params\n\n        settings = ClickhouseSettings(\n            table=self.table,\n            database=self.database,\n            host=self.host,\n            index_type=self.index_type,\n            metric=self.metric,\n            password=self.password,\n            port=self.port,\n            secure=self.secure,\n            username=self.username,\n            **kwargs,\n        )\n        if documents:\n            clickhouse_vs = Clickhouse.from_documents(documents=documents, embedding=self.embedding, config=settings)\n\n        else:\n            clickhouse_vs = Clickhouse(embedding=self.embedding, config=settings)\n\n        return clickhouse_vs\n\n    def search_documents(self) -> list[Data]:\n        vector_store = self.build_vector_store()\n\n        if self.search_query and isinstance(self.search_query, str) and self.search_query.strip():\n            kwargs = {}\n            if self.score_threshold:\n                kwargs[\"score_threshold\"] = self.score_threshold\n\n            docs = vector_store.similarity_search(query=self.search_query, k=self.number_of_results, **kwargs)\n\n            data = docs_to_data(docs)\n            self.status = data\n            return data\n        return []\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "database": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "database",
        "value": "",
        "display_name": "database",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "host": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "host",
        "value": "localhost",
        "display_name": "hostname",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "index_param": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "index_param",
        "value": "100,'L2Distance'",
        "display_name": "Param of the index",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "index_query_params": {
        "tool_mode": false,
        "trace_as_input": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "index_query_params",
        "value": {},
        "display_name": "index query params",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "dict",
        "_input_type": "DictInput"
      },
      "index_type": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "annoy",
          "vector_similarity"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "index_type",
        "value": "annoy",
        "display_name": "index_type",
        "advanced": true,
        "dynamic": false,
        "info": "Type of the index.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "metric": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "angular",
          "euclidean",
          "manhattan",
          "hamming",
          "dot"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "metric",
        "value": "angular",
        "display_name": "metric",
        "advanced": true,
        "dynamic": false,
        "info": "Metric to compute distance.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "number_of_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "number_of_results",
        "value": 4,
        "display_name": "Number of Results",
        "advanced": true,
        "dynamic": false,
        "info": "Number of results to return.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "password": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "password",
        "value": "",
        "display_name": "The password for username.",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "port": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "port",
        "value": 8123,
        "display_name": "port",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "score_threshold": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "score_threshold",
        "value": "",
        "display_name": "Score threshold",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "float",
        "_input_type": "FloatInput"
      },
      "search_query": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "Enter a query...",
        "show": true,
        "name": "search_query",
        "value": "",
        "display_name": "Search Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Enter a query to run a similarity search.",
        "title_case": false,
        "type": "query",
        "_input_type": "QueryInput"
      },
      "secure": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "secure",
        "value": false,
        "display_name": "Use https/TLS. This overrides inferred values from the interface or port arguments.",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "should_cache_vector_store": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "should_cache_vector_store",
        "value": true,
        "display_name": "Cache Vector Store",
        "advanced": true,
        "dynamic": false,
        "info": "If True, the vector store will be cached for the current build of the component. This is useful for components that have multiple output methods and want to share the same vector store.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "table": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "table",
        "value": "",
        "display_name": "Table name",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "username": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "username",
        "value": "",
        "display_name": "The ClickHouse user name.",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      }
    },
    "description": "Clickhouse Vector Store with search capabilities",
    "icon": "Clickhouse",
    "base_classes": [
      "Data",
      "DataFrame"
    ],
    "display_name": "Clickhouse",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "search_results",
        "display_name": "Search Results",
        "method": "search_documents",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "database",
          "host",
          "password",
          "port",
          "table",
          "username"
        ],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "host",
      "port",
      "database",
      "table",
      "username",
      "password",
      "index_type",
      "metric",
      "secure",
      "index_param",
      "index_query_params",
      "ingest_data",
      "search_query",
      "should_cache_vector_store",
      "embedding",
      "number_of_results",
      "score_threshold"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "Pinecone": {
    "template": {
      "_type": "Component",
      "embedding": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "embedding",
        "value": "",
        "display_name": "Embedding",
        "advanced": false,
        "input_types": [
          "Embeddings"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "ingest_data": {
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "ingest_data",
        "value": "",
        "display_name": "Ingest Data",
        "advanced": false,
        "input_types": [
          "Data",
          "DataFrame"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "import numpy as np\nfrom langchain_core.vectorstores import VectorStore\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.io import DropdownInput, HandleInput, IntInput, SecretStrInput, StrInput\nfrom langflow.schema import Data\n\n\nclass PineconeVectorStoreComponent(LCVectorStoreComponent):\n    display_name = \"Pinecone\"\n    description = \"Pinecone Vector Store with search capabilities\"\n    name = \"Pinecone\"\n    icon = \"Pinecone\"\n    inputs = [\n        StrInput(name=\"index_name\", display_name=\"Index Name\", required=True),\n        StrInput(name=\"namespace\", display_name=\"Namespace\", info=\"Namespace for the index.\"),\n        DropdownInput(\n            name=\"distance_strategy\",\n            display_name=\"Distance Strategy\",\n            options=[\"Cosine\", \"Euclidean\", \"Dot Product\"],\n            value=\"Cosine\",\n            advanced=True,\n        ),\n        SecretStrInput(name=\"pinecone_api_key\", display_name=\"Pinecone API Key\", required=True),\n        StrInput(\n            name=\"text_key\",\n            display_name=\"Text Key\",\n            info=\"Key in the record to use as text.\",\n            value=\"text\",\n            advanced=True,\n        ),\n        *LCVectorStoreComponent.inputs,\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            value=4,\n            advanced=True,\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> VectorStore:\n        \"\"\"Build and return a Pinecone vector store instance.\"\"\"\n        try:\n            from langchain_pinecone import PineconeVectorStore\n        except ImportError as e:\n            msg = \"langchain-pinecone is not installed. Please install it with `pip install langchain-pinecone`.\"\n            raise ValueError(msg) from e\n\n        try:\n            from langchain_pinecone._utilities import DistanceStrategy\n\n            # Wrap the embedding model to ensure float32 output\n            wrapped_embeddings = Float32Embeddings(self.embedding)\n\n            # Convert distance strategy\n            distance_strategy = self.distance_strategy.replace(\" \", \"_\").upper()\n            distance_strategy = DistanceStrategy[distance_strategy]\n\n            # Initialize Pinecone instance with wrapped embeddings\n            pinecone = PineconeVectorStore(\n                index_name=self.index_name,\n                embedding=wrapped_embeddings,  # Use wrapped embeddings\n                text_key=self.text_key,\n                namespace=self.namespace,\n                distance_strategy=distance_strategy,\n                pinecone_api_key=self.pinecone_api_key,\n            )\n        except Exception as e:\n            error_msg = \"Error building Pinecone vector store\"\n            raise ValueError(error_msg) from e\n        else:\n            self.ingest_data = self._prepare_ingest_data()\n\n            # Process documents if any\n            documents = []\n            if self.ingest_data:\n                # Convert DataFrame to Data if needed using parent's method\n\n                for doc in self.ingest_data:\n                    if isinstance(doc, Data):\n                        documents.append(doc.to_lc_document())\n                    else:\n                        documents.append(doc)\n\n                if documents:\n                    pinecone.add_documents(documents)\n\n            return pinecone\n\n    def search_documents(self) -> list[Data]:\n        \"\"\"Search documents in the vector store.\"\"\"\n        try:\n            if not self.search_query or not isinstance(self.search_query, str) or not self.search_query.strip():\n                return []\n\n            vector_store = self.build_vector_store()\n            docs = vector_store.similarity_search(\n                query=self.search_query,\n                k=self.number_of_results,\n            )\n        except Exception as e:\n            error_msg = \"Error searching documents\"\n            raise ValueError(error_msg) from e\n        else:\n            data = docs_to_data(docs)\n            self.status = data\n            return data\n\n\nclass Float32Embeddings:\n    \"\"\"Wrapper class to ensure float32 embeddings.\"\"\"\n\n    def __init__(self, base_embeddings):\n        self.base_embeddings = base_embeddings\n\n    def embed_documents(self, texts):\n        embeddings = self.base_embeddings.embed_documents(texts)\n        if isinstance(embeddings, np.ndarray):\n            return [[self._force_float32(x) for x in vec] for vec in embeddings]\n        return [[self._force_float32(x) for x in vec] for vec in embeddings]\n\n    def embed_query(self, text):\n        embedding = self.base_embeddings.embed_query(text)\n        if isinstance(embedding, np.ndarray):\n            return [self._force_float32(x) for x in embedding]\n        return [self._force_float32(x) for x in embedding]\n\n    def _force_float32(self, value):\n        \"\"\"Convert any numeric type to Python float.\"\"\"\n        return float(np.float32(value))\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "distance_strategy": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "Cosine",
          "Euclidean",
          "Dot Product"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "distance_strategy",
        "value": "Cosine",
        "display_name": "Distance Strategy",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "index_name": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "index_name",
        "value": "",
        "display_name": "Index Name",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "namespace": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "namespace",
        "value": "",
        "display_name": "Namespace",
        "advanced": false,
        "dynamic": false,
        "info": "Namespace for the index.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "number_of_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "number_of_results",
        "value": 4,
        "display_name": "Number of Results",
        "advanced": true,
        "dynamic": false,
        "info": "Number of results to return.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "pinecone_api_key": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "pinecone_api_key",
        "value": "",
        "display_name": "Pinecone API Key",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "search_query": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "Enter a query...",
        "show": true,
        "name": "search_query",
        "value": "",
        "display_name": "Search Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Enter a query to run a similarity search.",
        "title_case": false,
        "type": "query",
        "_input_type": "QueryInput"
      },
      "should_cache_vector_store": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "should_cache_vector_store",
        "value": true,
        "display_name": "Cache Vector Store",
        "advanced": true,
        "dynamic": false,
        "info": "If True, the vector store will be cached for the current build of the component. This is useful for components that have multiple output methods and want to share the same vector store.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "text_key": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "text_key",
        "value": "text",
        "display_name": "Text Key",
        "advanced": true,
        "dynamic": false,
        "info": "Key in the record to use as text.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      }
    },
    "description": "Pinecone Vector Store with search capabilities",
    "icon": "Pinecone",
    "base_classes": [
      "Data",
      "DataFrame"
    ],
    "display_name": "Pinecone",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "search_results",
        "display_name": "Search Results",
        "method": "search_documents",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "index_name",
          "pinecone_api_key"
        ],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "index_name",
      "namespace",
      "distance_strategy",
      "pinecone_api_key",
      "text_key",
      "ingest_data",
      "search_query",
      "should_cache_vector_store",
      "embedding",
      "number_of_results"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "OpenSearch": {
    "template": {
      "_type": "Component",
      "embedding": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "embedding",
        "value": "",
        "display_name": "Embedding",
        "advanced": false,
        "input_types": [
          "Embeddings"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "ingest_data": {
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "ingest_data",
        "value": "",
        "display_name": "Ingest Data",
        "advanced": false,
        "input_types": [
          "Data",
          "DataFrame"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "import json\nfrom typing import Any\n\nfrom langchain_community.vectorstores import OpenSearchVectorSearch\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.base.vectorstores.vector_store_connection_decorator import vector_store_connection\nfrom langflow.io import (\n    BoolInput,\n    DropdownInput,\n    FloatInput,\n    HandleInput,\n    IntInput,\n    MultilineInput,\n    SecretStrInput,\n    StrInput,\n)\nfrom langflow.schema import Data\n\n\n@vector_store_connection\nclass OpenSearchVectorStoreComponent(LCVectorStoreComponent):\n    \"\"\"OpenSearch Vector Store with advanced, customizable search capabilities.\"\"\"\n\n    display_name: str = \"OpenSearch\"\n    description: str = \"OpenSearch Vector Store with advanced, customizable search capabilities.\"\n    name = \"OpenSearch\"\n    icon = \"OpenSearch\"\n\n    inputs = [\n        StrInput(\n            name=\"opensearch_url\",\n            display_name=\"OpenSearch URL\",\n            value=\"http://localhost:9200\",\n            info=\"URL for OpenSearch cluster (e.g. https://192.168.1.1:9200).\",\n        ),\n        StrInput(\n            name=\"index_name\",\n            display_name=\"Index Name\",\n            value=\"langflow\",\n            info=\"The index name where the vectors will be stored in OpenSearch cluster.\",\n        ),\n        *LCVectorStoreComponent.inputs,\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n        DropdownInput(\n            name=\"search_type\",\n            display_name=\"Search Type\",\n            options=[\"similarity\", \"similarity_score_threshold\", \"mmr\"],\n            value=\"similarity\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            advanced=True,\n            value=4,\n        ),\n        FloatInput(\n            name=\"search_score_threshold\",\n            display_name=\"Search Score Threshold\",\n            info=\"Minimum similarity score threshold for search results.\",\n            value=0.0,\n            advanced=True,\n        ),\n        StrInput(\n            name=\"username\",\n            display_name=\"Username\",\n            value=\"admin\",\n            advanced=True,\n        ),\n        SecretStrInput(\n            name=\"password\",\n            display_name=\"Password\",\n            value=\"admin\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"use_ssl\",\n            display_name=\"Use SSL\",\n            value=True,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"verify_certs\",\n            display_name=\"Verify Certificates\",\n            value=False,\n            advanced=True,\n        ),\n        MultilineInput(\n            name=\"hybrid_search_query\",\n            display_name=\"Hybrid Search Query\",\n            value=\"\",\n            advanced=True,\n            info=(\n                \"Provide a custom hybrid search query in JSON format. This allows you to combine \"\n                \"vector similarity and keyword matching.\"\n            ),\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> OpenSearchVectorSearch:\n        \"\"\"Builds the OpenSearch Vector Store object.\"\"\"\n        try:\n            from langchain_community.vectorstores import OpenSearchVectorSearch\n        except ImportError as e:\n            error_message = f\"Failed to import required modules: {e}\"\n            self.log(error_message)\n            raise ImportError(error_message) from e\n\n        try:\n            opensearch = OpenSearchVectorSearch(\n                index_name=self.index_name,\n                embedding_function=self.embedding,\n                opensearch_url=self.opensearch_url,\n                http_auth=(self.username, self.password),\n                use_ssl=self.use_ssl,\n                verify_certs=self.verify_certs,\n                ssl_assert_hostname=False,\n                ssl_show_warn=False,\n            )\n        except Exception as e:\n            error_message = f\"Failed to create OpenSearchVectorSearch instance: {e}\"\n            self.log(error_message)\n            raise RuntimeError(error_message) from e\n\n        if self.ingest_data:\n            self._add_documents_to_vector_store(opensearch)\n\n        return opensearch\n\n    def _add_documents_to_vector_store(self, vector_store: \"OpenSearchVectorSearch\") -> None:\n        \"\"\"Adds documents to the Vector Store.\"\"\"\n        # Convert DataFrame to Data if needed using parent's method\n        self.ingest_data = self._prepare_ingest_data()\n\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                error_message = f\"Expected Data object, got {type(_input)}\"\n                self.log(error_message)\n                raise TypeError(error_message)\n\n        if documents and self.embedding is not None:\n            self.log(f\"Adding {len(documents)} documents to the Vector Store.\")\n            try:\n                vector_store.add_documents(documents)\n            except Exception as e:\n                error_message = f\"Error adding documents to Vector Store: {e}\"\n                self.log(error_message)\n                raise RuntimeError(error_message) from e\n        else:\n            self.log(\"No documents to add to the Vector Store.\")\n\n    def search(self, query: str | None = None) -> list[dict[str, Any]]:\n        \"\"\"Search for similar documents in the vector store or retrieve all documents if no query is provided.\"\"\"\n        try:\n            vector_store = self.build_vector_store()\n\n            query = query or \"\"\n\n            if self.hybrid_search_query.strip():\n                try:\n                    hybrid_query = json.loads(self.hybrid_search_query)\n                except json.JSONDecodeError as e:\n                    error_message = f\"Invalid hybrid search query JSON: {e}\"\n                    self.log(error_message)\n                    raise ValueError(error_message) from e\n\n                results = vector_store.client.search(index=self.index_name, body=hybrid_query)\n\n                processed_results = []\n                for hit in results.get(\"hits\", {}).get(\"hits\", []):\n                    source = hit.get(\"_source\", {})\n                    text = source.get(\"text\", \"\")\n                    metadata = source.get(\"metadata\", {})\n\n                    if isinstance(text, dict):\n                        text = text.get(\"text\", \"\")\n\n                    processed_results.append(\n                        {\n                            \"page_content\": text,\n                            \"metadata\": metadata,\n                        }\n                    )\n                return processed_results\n\n            search_kwargs = {\"k\": self.number_of_results}\n            search_type = self.search_type.lower()\n\n            if search_type == \"similarity\":\n                results = vector_store.similarity_search(query, **search_kwargs)\n                return [{\"page_content\": doc.page_content, \"metadata\": doc.metadata} for doc in results]\n            if search_type == \"similarity_score_threshold\":\n                search_kwargs[\"score_threshold\"] = self.search_score_threshold\n                results = vector_store.similarity_search_with_relevance_scores(query, **search_kwargs)\n                return [\n                    {\n                        \"page_content\": doc.page_content,\n                        \"metadata\": doc.metadata,\n                        \"score\": score,\n                    }\n                    for doc, score in results\n                ]\n            if search_type == \"mmr\":\n                results = vector_store.max_marginal_relevance_search(query, **search_kwargs)\n                return [{\"page_content\": doc.page_content, \"metadata\": doc.metadata} for doc in results]\n\n        except Exception as e:\n            error_message = f\"Error during search: {e}\"\n            self.log(error_message)\n            raise RuntimeError(error_message) from e\n\n        error_message = f\"Error during search. Invalid search type: {self.search_type}\"\n        self.log(error_message)\n        raise ValueError(error_message)\n\n    def search_documents(self) -> list[Data]:\n        \"\"\"Search for documents in the vector store based on the search input.\n\n        If no search input is provided, retrieve all documents.\n        \"\"\"\n        try:\n            query = self.search_query.strip() if self.search_query else None\n            results = self.search(query)\n            retrieved_data = [\n                Data(\n                    file_path=result[\"metadata\"].get(\"file_path\", \"\"),\n                    text=result[\"page_content\"],\n                )\n                for result in results\n            ]\n        except Exception as e:\n            error_message = f\"Error during document search: {e}\"\n            self.log(error_message)\n            raise RuntimeError(error_message) from e\n\n        self.status = retrieved_data\n        return retrieved_data\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "hybrid_search_query": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "hybrid_search_query",
        "value": "",
        "display_name": "Hybrid Search Query",
        "advanced": true,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Provide a custom hybrid search query in JSON format. This allows you to combine vector similarity and keyword matching.",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "index_name": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "index_name",
        "value": "langflow",
        "display_name": "Index Name",
        "advanced": false,
        "dynamic": false,
        "info": "The index name where the vectors will be stored in OpenSearch cluster.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "number_of_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "number_of_results",
        "value": 4,
        "display_name": "Number of Results",
        "advanced": true,
        "dynamic": false,
        "info": "Number of results to return.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "opensearch_url": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "opensearch_url",
        "value": "http://localhost:9200",
        "display_name": "OpenSearch URL",
        "advanced": false,
        "dynamic": false,
        "info": "URL for OpenSearch cluster (e.g. https://192.168.1.1:9200).",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "password": {
        "load_from_db": true,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "password",
        "value": "admin",
        "display_name": "Password",
        "advanced": true,
        "input_types": [],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "search_query": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "Enter a query...",
        "show": true,
        "name": "search_query",
        "value": "",
        "display_name": "Search Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Enter a query to run a similarity search.",
        "title_case": false,
        "type": "query",
        "_input_type": "QueryInput"
      },
      "search_score_threshold": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_score_threshold",
        "value": 0,
        "display_name": "Search Score Threshold",
        "advanced": true,
        "dynamic": false,
        "info": "Minimum similarity score threshold for search results.",
        "title_case": false,
        "type": "float",
        "_input_type": "FloatInput"
      },
      "search_type": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "similarity",
          "similarity_score_threshold",
          "mmr"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_type",
        "value": "similarity",
        "display_name": "Search Type",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "should_cache_vector_store": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "should_cache_vector_store",
        "value": true,
        "display_name": "Cache Vector Store",
        "advanced": true,
        "dynamic": false,
        "info": "If True, the vector store will be cached for the current build of the component. This is useful for components that have multiple output methods and want to share the same vector store.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "use_ssl": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "use_ssl",
        "value": true,
        "display_name": "Use SSL",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "username": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "username",
        "value": "admin",
        "display_name": "Username",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "verify_certs": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "verify_certs",
        "value": false,
        "display_name": "Verify Certificates",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      }
    },
    "description": "OpenSearch Vector Store with advanced, customizable search capabilities.",
    "icon": "OpenSearch",
    "base_classes": [
      "Data",
      "DataFrame",
      "VectorStore"
    ],
    "display_name": "OpenSearch",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "search_results",
        "display_name": "Search Results",
        "method": "search_documents",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "VectorStore"
        ],
        "selected": "VectorStore",
        "name": "vectorstoreconnection",
        "hidden": true,
        "display_name": "Vector Store Connection",
        "method": "as_vector_store",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "opensearch_url",
      "index_name",
      "ingest_data",
      "search_query",
      "should_cache_vector_store",
      "embedding",
      "search_type",
      "number_of_results",
      "search_score_threshold",
      "username",
      "password",
      "use_ssl",
      "verify_certs",
      "hybrid_search_query"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "SupabaseVectorStore": {
    "template": {
      "_type": "Component",
      "embedding": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "embedding",
        "value": "",
        "display_name": "Embedding",
        "advanced": false,
        "input_types": [
          "Embeddings"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "ingest_data": {
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "ingest_data",
        "value": "",
        "display_name": "Ingest Data",
        "advanced": false,
        "input_types": [
          "Data",
          "DataFrame"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain_community.vectorstores import SupabaseVectorStore\nfrom supabase.client import Client, create_client\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.io import HandleInput, IntInput, SecretStrInput, StrInput\nfrom langflow.schema import Data\n\n\nclass SupabaseVectorStoreComponent(LCVectorStoreComponent):\n    display_name = \"Supabase\"\n    description = \"Supabase Vector Store with search capabilities\"\n    name = \"SupabaseVectorStore\"\n    icon = \"Supabase\"\n\n    inputs = [\n        StrInput(name=\"supabase_url\", display_name=\"Supabase URL\", required=True),\n        SecretStrInput(name=\"supabase_service_key\", display_name=\"Supabase Service Key\", required=True),\n        StrInput(name=\"table_name\", display_name=\"Table Name\", advanced=True),\n        StrInput(name=\"query_name\", display_name=\"Query Name\"),\n        *LCVectorStoreComponent.inputs,\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            value=4,\n            advanced=True,\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> SupabaseVectorStore:\n        supabase: Client = create_client(self.supabase_url, supabase_key=self.supabase_service_key)\n\n        # Convert DataFrame to Data if needed using parent's method\n        self.ingest_data = self._prepare_ingest_data()\n\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                documents.append(_input)\n\n        if documents:\n            supabase_vs = SupabaseVectorStore.from_documents(\n                documents=documents,\n                embedding=self.embedding,\n                query_name=self.query_name,\n                client=supabase,\n                table_name=self.table_name,\n            )\n        else:\n            supabase_vs = SupabaseVectorStore(\n                client=supabase,\n                embedding=self.embedding,\n                table_name=self.table_name,\n                query_name=self.query_name,\n            )\n\n        return supabase_vs\n\n    def search_documents(self) -> list[Data]:\n        vector_store = self.build_vector_store()\n\n        if self.search_query and isinstance(self.search_query, str) and self.search_query.strip():\n            docs = vector_store.similarity_search(\n                query=self.search_query,\n                k=self.number_of_results,\n            )\n\n            data = docs_to_data(docs)\n            self.status = data\n            return data\n        return []\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "number_of_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "number_of_results",
        "value": 4,
        "display_name": "Number of Results",
        "advanced": true,
        "dynamic": false,
        "info": "Number of results to return.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "query_name": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "query_name",
        "value": "",
        "display_name": "Query Name",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "search_query": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "Enter a query...",
        "show": true,
        "name": "search_query",
        "value": "",
        "display_name": "Search Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Enter a query to run a similarity search.",
        "title_case": false,
        "type": "query",
        "_input_type": "QueryInput"
      },
      "should_cache_vector_store": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "should_cache_vector_store",
        "value": true,
        "display_name": "Cache Vector Store",
        "advanced": true,
        "dynamic": false,
        "info": "If True, the vector store will be cached for the current build of the component. This is useful for components that have multiple output methods and want to share the same vector store.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "supabase_service_key": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "supabase_service_key",
        "value": "",
        "display_name": "Supabase Service Key",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "supabase_url": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "supabase_url",
        "value": "",
        "display_name": "Supabase URL",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "table_name": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "table_name",
        "value": "",
        "display_name": "Table Name",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      }
    },
    "description": "Supabase Vector Store with search capabilities",
    "icon": "Supabase",
    "base_classes": [
      "Data",
      "DataFrame"
    ],
    "display_name": "Supabase",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "search_results",
        "display_name": "Search Results",
        "method": "search_documents",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "supabase_service_key",
          "supabase_url"
        ],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "supabase_url",
      "supabase_service_key",
      "table_name",
      "query_name",
      "ingest_data",
      "search_query",
      "should_cache_vector_store",
      "embedding",
      "number_of_results"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "QdrantVectorStoreComponent": {
    "template": {
      "_type": "Component",
      "embedding": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "embedding",
        "value": "",
        "display_name": "Embedding",
        "advanced": false,
        "input_types": [
          "Embeddings"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "ingest_data": {
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "ingest_data",
        "value": "",
        "display_name": "Ingest Data",
        "advanced": false,
        "input_types": [
          "Data",
          "DataFrame"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "api_key": {
        "load_from_db": true,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "api_key",
        "value": "",
        "display_name": "API Key",
        "advanced": true,
        "input_types": [],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain.embeddings.base import Embeddings\nfrom langchain_community.vectorstores import Qdrant\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.io import (\n    DropdownInput,\n    HandleInput,\n    IntInput,\n    SecretStrInput,\n    StrInput,\n)\nfrom langflow.schema import Data\n\n\nclass QdrantVectorStoreComponent(LCVectorStoreComponent):\n    display_name = \"Qdrant\"\n    description = \"Qdrant Vector Store with search capabilities\"\n    icon = \"Qdrant\"\n\n    inputs = [\n        StrInput(name=\"collection_name\", display_name=\"Collection Name\", required=True),\n        StrInput(name=\"host\", display_name=\"Host\", value=\"localhost\", advanced=True),\n        IntInput(name=\"port\", display_name=\"Port\", value=6333, advanced=True),\n        IntInput(name=\"grpc_port\", display_name=\"gRPC Port\", value=6334, advanced=True),\n        SecretStrInput(name=\"api_key\", display_name=\"API Key\", advanced=True),\n        StrInput(name=\"prefix\", display_name=\"Prefix\", advanced=True),\n        IntInput(name=\"timeout\", display_name=\"Timeout\", advanced=True),\n        StrInput(name=\"path\", display_name=\"Path\", advanced=True),\n        StrInput(name=\"url\", display_name=\"URL\", advanced=True),\n        DropdownInput(\n            name=\"distance_func\",\n            display_name=\"Distance Function\",\n            options=[\"Cosine\", \"Euclidean\", \"Dot Product\"],\n            value=\"Cosine\",\n            advanced=True,\n        ),\n        StrInput(name=\"content_payload_key\", display_name=\"Content Payload Key\", value=\"page_content\", advanced=True),\n        StrInput(name=\"metadata_payload_key\", display_name=\"Metadata Payload Key\", value=\"metadata\", advanced=True),\n        *LCVectorStoreComponent.inputs,\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            value=4,\n            advanced=True,\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> Qdrant:\n        qdrant_kwargs = {\n            \"collection_name\": self.collection_name,\n            \"content_payload_key\": self.content_payload_key,\n            \"metadata_payload_key\": self.metadata_payload_key,\n        }\n\n        server_kwargs = {\n            \"host\": self.host or None,\n            \"port\": int(self.port),  # Ensure port is an integer\n            \"grpc_port\": int(self.grpc_port),  # Ensure grpc_port is an integer\n            \"api_key\": self.api_key,\n            \"prefix\": self.prefix,\n            # Ensure timeout is an integer\n            \"timeout\": int(self.timeout) if self.timeout else None,\n            \"path\": self.path or None,\n            \"url\": self.url or None,\n        }\n\n        server_kwargs = {k: v for k, v in server_kwargs.items() if v is not None}\n\n        # Convert DataFrame to Data if needed using parent's method\n        self.ingest_data = self._prepare_ingest_data()\n\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                documents.append(_input)\n\n        if not isinstance(self.embedding, Embeddings):\n            msg = \"Invalid embedding object\"\n            raise TypeError(msg)\n\n        if documents:\n            qdrant = Qdrant.from_documents(documents, embedding=self.embedding, **qdrant_kwargs, **server_kwargs)\n        else:\n            from qdrant_client import QdrantClient\n\n            client = QdrantClient(**server_kwargs)\n            qdrant = Qdrant(embeddings=self.embedding, client=client, **qdrant_kwargs)\n\n        return qdrant\n\n    def search_documents(self) -> list[Data]:\n        vector_store = self.build_vector_store()\n\n        if self.search_query and isinstance(self.search_query, str) and self.search_query.strip():\n            docs = vector_store.similarity_search(\n                query=self.search_query,\n                k=self.number_of_results,\n            )\n\n            data = docs_to_data(docs)\n            self.status = data\n            return data\n        return []\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "collection_name": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "collection_name",
        "value": "",
        "display_name": "Collection Name",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "content_payload_key": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "content_payload_key",
        "value": "page_content",
        "display_name": "Content Payload Key",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "distance_func": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "Cosine",
          "Euclidean",
          "Dot Product"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "distance_func",
        "value": "Cosine",
        "display_name": "Distance Function",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "grpc_port": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "grpc_port",
        "value": 6334,
        "display_name": "gRPC Port",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "host": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "host",
        "value": "localhost",
        "display_name": "Host",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "metadata_payload_key": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "metadata_payload_key",
        "value": "metadata",
        "display_name": "Metadata Payload Key",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "number_of_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "number_of_results",
        "value": 4,
        "display_name": "Number of Results",
        "advanced": true,
        "dynamic": false,
        "info": "Number of results to return.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "path": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "path",
        "value": "",
        "display_name": "Path",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "port": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "port",
        "value": 6333,
        "display_name": "Port",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "prefix": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "prefix",
        "value": "",
        "display_name": "Prefix",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "search_query": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "Enter a query...",
        "show": true,
        "name": "search_query",
        "value": "",
        "display_name": "Search Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Enter a query to run a similarity search.",
        "title_case": false,
        "type": "query",
        "_input_type": "QueryInput"
      },
      "should_cache_vector_store": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "should_cache_vector_store",
        "value": true,
        "display_name": "Cache Vector Store",
        "advanced": true,
        "dynamic": false,
        "info": "If True, the vector store will be cached for the current build of the component. This is useful for components that have multiple output methods and want to share the same vector store.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "timeout": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "timeout",
        "value": "",
        "display_name": "Timeout",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "url": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "url",
        "value": "",
        "display_name": "URL",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      }
    },
    "description": "Qdrant Vector Store with search capabilities",
    "icon": "Qdrant",
    "base_classes": [
      "Data",
      "DataFrame"
    ],
    "display_name": "Qdrant",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "search_results",
        "display_name": "Search Results",
        "method": "search_documents",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "collection_name"
        ],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "collection_name",
      "host",
      "port",
      "grpc_port",
      "api_key",
      "prefix",
      "timeout",
      "path",
      "url",
      "distance_func",
      "content_payload_key",
      "metadata_payload_key",
      "ingest_data",
      "search_query",
      "should_cache_vector_store",
      "embedding",
      "number_of_results"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "AstraDB": {
    "template": {
      "_type": "Component",
      "embedding_model": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": false,
        "name": "embedding_model",
        "value": "",
        "display_name": "Embedding Model",
        "advanced": false,
        "input_types": [
          "Embeddings"
        ],
        "dynamic": false,
        "info": "Specify the Embedding Model. Not required for Astra Vectorize collections.",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "ingest_data": {
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "ingest_data",
        "value": "",
        "display_name": "Ingest Data",
        "advanced": false,
        "input_types": [
          "Data",
          "DataFrame"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "advanced_search_filter": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "advanced_search_filter",
        "value": {},
        "display_name": "Search Metadata Filter",
        "advanced": true,
        "dynamic": false,
        "info": "Optional dictionary of filters to apply to the search query.",
        "title_case": false,
        "type": "NestedDict",
        "_input_type": "NestedDictInput"
      },
      "api_endpoint": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": false,
        "name": "api_endpoint",
        "value": "",
        "display_name": "Astra DB API Endpoint",
        "advanced": false,
        "dynamic": false,
        "info": "The API Endpoint for the Astra DB instance. Supercedes database selection.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "astradb_vectorstore_kwargs": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "astradb_vectorstore_kwargs",
        "value": {},
        "display_name": "AstraDBVectorStore Parameters",
        "advanced": true,
        "dynamic": false,
        "info": "Optional dictionary of additional parameters for the AstraDBVectorStore.",
        "title_case": false,
        "type": "NestedDict",
        "_input_type": "NestedDictInput"
      },
      "autodetect_collection": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "autodetect_collection",
        "value": true,
        "display_name": "Autodetect Collection",
        "advanced": true,
        "dynamic": false,
        "info": "Boolean flag to determine whether to autodetect the collection.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "import re\nfrom collections import defaultdict\nfrom dataclasses import asdict, dataclass, field\n\nfrom astrapy import DataAPIClient, Database\nfrom astrapy.data.info.reranking import RerankServiceOptions\nfrom astrapy.info import CollectionDescriptor, CollectionLexicalOptions, CollectionRerankOptions\nfrom langchain_astradb import AstraDBVectorStore, VectorServiceOptions\nfrom langchain_astradb.utils.astradb import HybridSearchMode, _AstraDBCollectionEnvironment\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.base.vectorstores.vector_store_connection_decorator import vector_store_connection\nfrom langflow.helpers import docs_to_data\nfrom langflow.inputs import FloatInput, NestedDictInput\nfrom langflow.io import (\n    BoolInput,\n    DropdownInput,\n    HandleInput,\n    IntInput,\n    QueryInput,\n    SecretStrInput,\n    StrInput,\n)\nfrom langflow.schema import Data\nfrom langflow.utils.version import get_version_info\n\n\n@vector_store_connection\nclass AstraDBVectorStoreComponent(LCVectorStoreComponent):\n    display_name: str = \"Astra DB\"\n    description: str = \"Ingest and search documents in Astra DB\"\n    documentation: str = \"https://docs.datastax.com/en/langflow/astra-components.html\"\n    name = \"AstraDB\"\n    icon: str = \"AstraDB\"\n\n    _cached_vector_store: AstraDBVectorStore | None = None\n\n    @dataclass\n    class NewDatabaseInput:\n        functionality: str = \"create\"\n        fields: dict[str, dict] = field(\n            default_factory=lambda: {\n                \"data\": {\n                    \"node\": {\n                        \"name\": \"create_database\",\n                        \"description\": \"Please allow several minutes for creation to complete.\",\n                        \"display_name\": \"Create new database\",\n                        \"field_order\": [\"01_new_database_name\", \"02_cloud_provider\", \"03_region\"],\n                        \"template\": {\n                            \"01_new_database_name\": StrInput(\n                                name=\"new_database_name\",\n                                display_name=\"Name\",\n                                info=\"Name of the new database to create in Astra DB.\",\n                                required=True,\n                            ),\n                            \"02_cloud_provider\": DropdownInput(\n                                name=\"cloud_provider\",\n                                display_name=\"Cloud provider\",\n                                info=\"Cloud provider for the new database.\",\n                                options=[],\n                                required=True,\n                                real_time_refresh=True,\n                            ),\n                            \"03_region\": DropdownInput(\n                                name=\"region\",\n                                display_name=\"Region\",\n                                info=\"Region for the new database.\",\n                                options=[],\n                                required=True,\n                            ),\n                        },\n                    },\n                }\n            }\n        )\n\n    @dataclass\n    class NewCollectionInput:\n        functionality: str = \"create\"\n        fields: dict[str, dict] = field(\n            default_factory=lambda: {\n                \"data\": {\n                    \"node\": {\n                        \"name\": \"create_collection\",\n                        \"description\": \"Please allow several seconds for creation to complete.\",\n                        \"display_name\": \"Create new collection\",\n                        \"field_order\": [\n                            \"01_new_collection_name\",\n                            \"02_embedding_generation_provider\",\n                            \"03_embedding_generation_model\",\n                            \"04_dimension\",\n                        ],\n                        \"template\": {\n                            \"01_new_collection_name\": StrInput(\n                                name=\"new_collection_name\",\n                                display_name=\"Name\",\n                                info=\"Name of the new collection to create in Astra DB.\",\n                                required=True,\n                            ),\n                            \"02_embedding_generation_provider\": DropdownInput(\n                                name=\"embedding_generation_provider\",\n                                display_name=\"Embedding generation method\",\n                                info=\"Provider to use for generating embeddings.\",\n                                helper_text=(\n                                    \"To create collections with more embedding provider options, go to \"\n                                    '<a class=\"underline\" href=\"https://astra.datastax.com/\" target=\" _blank\" '\n                                    'rel=\"noopener noreferrer\">your database in Astra DB</a>'\n                                ),\n                                real_time_refresh=True,\n                                required=True,\n                                options=[],\n                            ),\n                            \"03_embedding_generation_model\": DropdownInput(\n                                name=\"embedding_generation_model\",\n                                display_name=\"Embedding model\",\n                                info=\"Model to use for generating embeddings.\",\n                                real_time_refresh=True,\n                                options=[],\n                            ),\n                            \"04_dimension\": IntInput(\n                                name=\"dimension\",\n                                display_name=\"Dimensions\",\n                                info=\"Dimensions of the embeddings to generate.\",\n                                value=None,\n                            ),\n                        },\n                    },\n                }\n            }\n        )\n\n    inputs = [\n        SecretStrInput(\n            name=\"token\",\n            display_name=\"Astra DB Application Token\",\n            info=\"Authentication token for accessing Astra DB.\",\n            value=\"ASTRA_DB_APPLICATION_TOKEN\",\n            required=True,\n            real_time_refresh=True,\n            input_types=[],\n        ),\n        DropdownInput(\n            name=\"environment\",\n            display_name=\"Environment\",\n            info=\"The environment for the Astra DB API Endpoint.\",\n            options=[\"prod\", \"test\", \"dev\"],\n            value=\"prod\",\n            advanced=True,\n            real_time_refresh=True,\n            combobox=True,\n        ),\n        DropdownInput(\n            name=\"database_name\",\n            display_name=\"Database\",\n            info=\"The Database name for the Astra DB instance.\",\n            required=True,\n            refresh_button=True,\n            real_time_refresh=True,\n            dialog_inputs=asdict(NewDatabaseInput()),\n            combobox=True,\n        ),\n        StrInput(\n            name=\"api_endpoint\",\n            display_name=\"Astra DB API Endpoint\",\n            info=\"The API Endpoint for the Astra DB instance. Supercedes database selection.\",\n            show=False,\n        ),\n        DropdownInput(\n            name=\"keyspace\",\n            display_name=\"Keyspace\",\n            info=\"Optional keyspace within Astra DB to use for the collection.\",\n            advanced=True,\n            options=[],\n            real_time_refresh=True,\n        ),\n        DropdownInput(\n            name=\"collection_name\",\n            display_name=\"Collection\",\n            info=\"The name of the collection within Astra DB where the vectors will be stored.\",\n            required=True,\n            refresh_button=True,\n            real_time_refresh=True,\n            dialog_inputs=asdict(NewCollectionInput()),\n            combobox=True,\n            show=False,\n        ),\n        HandleInput(\n            name=\"embedding_model\",\n            display_name=\"Embedding Model\",\n            input_types=[\"Embeddings\"],\n            info=\"Specify the Embedding Model. Not required for Astra Vectorize collections.\",\n            required=False,\n            show=False,\n        ),\n        *LCVectorStoreComponent.inputs,\n        DropdownInput(\n            name=\"search_method\",\n            display_name=\"Search Method\",\n            info=(\n                \"Determine how your content is matched: Vector finds semantic similarity, \"\n                \"and Hybrid Search (suggested) combines both approaches \"\n                \"with a reranker.\"\n            ),\n            options=[\"Hybrid Search\", \"Vector Search\"],  # TODO: Restore Lexical Search?\n            options_metadata=[{\"icon\": \"SearchHybrid\"}, {\"icon\": \"SearchVector\"}],\n            value=\"Vector Search\",\n            advanced=True,\n            real_time_refresh=True,\n        ),\n        DropdownInput(\n            name=\"reranker\",\n            display_name=\"Reranker\",\n            info=\"Post-retrieval model that re-scores results for optimal relevance ranking.\",\n            show=False,\n            toggle=True,\n        ),\n        QueryInput(\n            name=\"lexical_terms\",\n            display_name=\"Lexical Terms\",\n            info=\"Add additional terms/keywords to augment search precision.\",\n            placeholder=\"Enter terms to search...\",\n            separator=\" \",\n            show=False,\n            value=\"\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Search Results\",\n            info=\"Number of search results to return.\",\n            advanced=True,\n            value=4,\n        ),\n        DropdownInput(\n            name=\"search_type\",\n            display_name=\"Search Type\",\n            info=\"Search type to use\",\n            options=[\"Similarity\", \"Similarity with score threshold\", \"MMR (Max Marginal Relevance)\"],\n            value=\"Similarity\",\n            advanced=True,\n        ),\n        FloatInput(\n            name=\"search_score_threshold\",\n            display_name=\"Search Score Threshold\",\n            info=\"Minimum similarity score threshold for search results. \"\n            \"(when using 'Similarity with score threshold')\",\n            value=0,\n            advanced=True,\n        ),\n        NestedDictInput(\n            name=\"advanced_search_filter\",\n            display_name=\"Search Metadata Filter\",\n            info=\"Optional dictionary of filters to apply to the search query.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"autodetect_collection\",\n            display_name=\"Autodetect Collection\",\n            info=\"Boolean flag to determine whether to autodetect the collection.\",\n            advanced=True,\n            value=True,\n        ),\n        StrInput(\n            name=\"content_field\",\n            display_name=\"Content Field\",\n            info=\"Field to use as the text content field for the vector store.\",\n            advanced=True,\n        ),\n        StrInput(\n            name=\"deletion_field\",\n            display_name=\"Deletion Based On Field\",\n            info=\"When this parameter is provided, documents in the target collection with \"\n            \"metadata field values matching the input metadata field value will be deleted \"\n            \"before new data is loaded.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"ignore_invalid_documents\",\n            display_name=\"Ignore Invalid Documents\",\n            info=\"Boolean flag to determine whether to ignore invalid documents at runtime.\",\n            advanced=True,\n        ),\n        NestedDictInput(\n            name=\"astradb_vectorstore_kwargs\",\n            display_name=\"AstraDBVectorStore Parameters\",\n            info=\"Optional dictionary of additional parameters for the AstraDBVectorStore.\",\n            advanced=True,\n        ),\n    ]\n\n    @classmethod\n    def map_cloud_providers(cls):\n        # TODO: Programmatically fetch the regions for each cloud provider\n        return {\n            \"dev\": {\n                \"Amazon Web Services\": {\n                    \"id\": \"aws\",\n                    \"regions\": [\"us-west-2\"],\n                },\n                \"Google Cloud Platform\": {\n                    \"id\": \"gcp\",\n                    \"regions\": [\"us-central1\", \"europe-west4\"],\n                },\n            },\n            \"test\": {\n                \"Google Cloud Platform\": {\n                    \"id\": \"gcp\",\n                    \"regions\": [\"us-central1\"],\n                },\n            },\n            \"prod\": {\n                \"Amazon Web Services\": {\n                    \"id\": \"aws\",\n                    \"regions\": [\"us-east-2\", \"ap-south-1\", \"eu-west-1\"],\n                },\n                \"Google Cloud Platform\": {\n                    \"id\": \"gcp\",\n                    \"regions\": [\"us-east1\"],\n                },\n                \"Microsoft Azure\": {\n                    \"id\": \"azure\",\n                    \"regions\": [\"westus3\"],\n                },\n            },\n        }\n\n    @classmethod\n    def get_vectorize_providers(cls, token: str, environment: str | None = None, api_endpoint: str | None = None):\n        try:\n            # Get the admin object\n            client = DataAPIClient(environment=environment)\n            admin_client = client.get_admin()\n            db_admin = admin_client.get_database_admin(api_endpoint, token=token)\n\n            # Get the list of embedding providers\n            embedding_providers = db_admin.find_embedding_providers()\n\n            vectorize_providers_mapping = {}\n            # Map the provider display name to the provider key and models\n            for provider_key, provider_data in embedding_providers.embedding_providers.items():\n                # Get the provider display name and models\n                display_name = provider_data.display_name\n                models = [model.name for model in provider_data.models]\n\n                # Build our mapping\n                vectorize_providers_mapping[display_name] = [provider_key, models]\n\n            # Sort the resulting dictionary\n            return defaultdict(list, dict(sorted(vectorize_providers_mapping.items())))\n        except Exception as _:  # noqa: BLE001\n            return {}\n\n    @classmethod\n    async def create_database_api(\n        cls,\n        new_database_name: str,\n        cloud_provider: str,\n        region: str,\n        token: str,\n        environment: str | None = None,\n        keyspace: str | None = None,\n    ):\n        client = DataAPIClient(environment=environment)\n\n        # Get the admin object\n        admin_client = client.get_admin(token=token)\n\n        # Get the environment, set to prod if null like\n        my_env = environment or \"prod\"\n\n        # Raise a value error if name isn't provided\n        if not new_database_name:\n            msg = \"Database name is required to create a new database.\"\n            raise ValueError(msg)\n\n        # Call the create database function\n        return await admin_client.async_create_database(\n            name=new_database_name,\n            cloud_provider=cls.map_cloud_providers()[my_env][cloud_provider][\"id\"],\n            region=region,\n            keyspace=keyspace,\n            wait_until_active=False,\n        )\n\n    @classmethod\n    async def create_collection_api(\n        cls,\n        new_collection_name: str,\n        token: str,\n        api_endpoint: str,\n        environment: str | None = None,\n        keyspace: str | None = None,\n        dimension: int | None = None,\n        embedding_generation_provider: str | None = None,\n        embedding_generation_model: str | None = None,\n        reranker: str | None = None,\n    ):\n        # Build vectorize options, if needed\n        vectorize_options = None\n        if not dimension:\n            providers = cls.get_vectorize_providers(token=token, environment=environment, api_endpoint=api_endpoint)\n            vectorize_options = VectorServiceOptions(\n                provider=providers.get(embedding_generation_provider, [None, []])[0],\n                model_name=embedding_generation_model,\n            )\n\n        # Raise a value error if name isn't provided\n        if not new_collection_name:\n            msg = \"Collection name is required to create a new collection.\"\n            raise ValueError(msg)\n\n        # Define the base arguments being passed to the create collection function\n        base_args = {\n            \"collection_name\": new_collection_name,\n            \"token\": token,\n            \"api_endpoint\": api_endpoint,\n            \"keyspace\": keyspace,\n            \"environment\": environment,\n            \"embedding_dimension\": dimension,\n            \"collection_vector_service_options\": vectorize_options,\n        }\n\n        # Add optional arguments only if environment is \"dev\"\n        if environment == \"dev\" and reranker:  # TODO: Remove conditional check soon\n            # Split the reranker field into a provider a model name\n            provider, _ = reranker.split(\"/\")\n            base_args[\"collection_rerank\"] = CollectionRerankOptions(\n                service=RerankServiceOptions(provider=provider, model_name=reranker),\n            )\n            base_args[\"collection_lexical\"] = CollectionLexicalOptions(analyzer=\"STANDARD\")\n\n        _AstraDBCollectionEnvironment(**base_args)\n\n    @classmethod\n    def get_database_list_static(cls, token: str, environment: str | None = None):\n        client = DataAPIClient(environment=environment)\n\n        # Get the admin object\n        admin_client = client.get_admin(token=token)\n\n        # Get the list of databases\n        db_list = admin_client.list_databases()\n\n        # Generate the api endpoint for each database\n        db_info_dict = {}\n        for db in db_list:\n            try:\n                # Get the API endpoint for the database\n                api_endpoint = db.regions[0].api_endpoint\n\n                # Get the number of collections\n                try:\n                    # Get the number of collections in the database\n                    num_collections = len(\n                        client.get_database(\n                            api_endpoint,\n                            token=token,\n                        ).list_collection_names()\n                    )\n                except Exception:  # noqa: BLE001\n                    if db.status != \"PENDING\":\n                        continue\n                    num_collections = 0\n\n                # Add the database to the dictionary\n                db_info_dict[db.name] = {\n                    \"api_endpoint\": api_endpoint,\n                    \"keyspaces\": db.keyspaces,\n                    \"collections\": num_collections,\n                    \"status\": db.status if db.status != \"ACTIVE\" else None,\n                    \"org_id\": db.org_id if db.org_id else None,\n                }\n            except Exception:  # noqa: BLE001, S110\n                pass\n\n        return db_info_dict\n\n    def get_database_list(self):\n        return self.get_database_list_static(\n            token=self.token,\n            environment=self.environment,\n        )\n\n    @classmethod\n    def get_api_endpoint_static(\n        cls,\n        token: str,\n        environment: str | None = None,\n        api_endpoint: str | None = None,\n        database_name: str | None = None,\n    ):\n        # If the api_endpoint is set, return it\n        if api_endpoint:\n            return api_endpoint\n\n        # Check if the database_name is like a url\n        if database_name and database_name.startswith(\"https://\"):\n            return database_name\n\n        # If the database is not set, nothing we can do.\n        if not database_name:\n            return None\n\n        # Grab the database object\n        db = cls.get_database_list_static(token=token, environment=environment).get(database_name)\n        if not db:\n            return None\n\n        # Otherwise, get the URL from the database list\n        return db.get(\"api_endpoint\")\n\n    def get_api_endpoint(self):\n        return self.get_api_endpoint_static(\n            token=self.token,\n            environment=self.environment,\n            api_endpoint=self.api_endpoint,\n            database_name=self.database_name,\n        )\n\n    @classmethod\n    def get_database_id_static(cls, api_endpoint: str) -> str | None:\n        # Pattern matches standard UUID format: 8-4-4-4-12 hexadecimal characters\n        uuid_pattern = r\"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\"\n        match = re.search(uuid_pattern, api_endpoint)\n\n        return match.group(0) if match else None\n\n    def get_database_id(self):\n        return self.get_database_id_static(api_endpoint=self.get_api_endpoint())\n\n    def get_keyspace(self):\n        keyspace = self.keyspace\n\n        if keyspace:\n            return keyspace.strip()\n\n        return \"default_keyspace\"\n\n    def get_database_object(self, api_endpoint: str | None = None):\n        try:\n            client = DataAPIClient(environment=self.environment)\n\n            return client.get_database(\n                api_endpoint or self.get_api_endpoint(),\n                token=self.token,\n                keyspace=self.get_keyspace(),\n            )\n        except Exception as e:\n            msg = f\"Error fetching database object: {e}\"\n            raise ValueError(msg) from e\n\n    def collection_data(self, collection_name: str, database: Database | None = None):\n        try:\n            if not database:\n                client = DataAPIClient(environment=self.environment)\n\n                database = client.get_database(\n                    self.get_api_endpoint(),\n                    token=self.token,\n                    keyspace=self.get_keyspace(),\n                )\n\n            collection = database.get_collection(collection_name)\n\n            return collection.estimated_document_count()\n        except Exception as e:  # noqa: BLE001\n            self.log(f\"Error checking collection data: {e}\")\n\n            return None\n\n    def _initialize_database_options(self):\n        try:\n            return [\n                {\n                    \"name\": name,\n                    \"status\": info[\"status\"],\n                    \"collections\": info[\"collections\"],\n                    \"api_endpoint\": info[\"api_endpoint\"],\n                    \"keyspaces\": info[\"keyspaces\"],\n                    \"org_id\": info[\"org_id\"],\n                }\n                for name, info in self.get_database_list().items()\n            ]\n        except Exception as e:\n            msg = f\"Error fetching database options: {e}\"\n            raise ValueError(msg) from e\n\n    @classmethod\n    def get_provider_icon(cls, collection: CollectionDescriptor | None = None, provider_name: str | None = None) -> str:\n        # Get the provider name from the collection\n        provider_name = provider_name or (\n            collection.definition.vector.service.provider\n            if (\n                collection\n                and collection.definition\n                and collection.definition.vector\n                and collection.definition.vector.service\n            )\n            else None\n        )\n\n        # If there is no provider, use the vector store icon\n        if not provider_name or provider_name.lower() == \"bring your own\":\n            return \"vectorstores\"\n\n        # Map provider casings\n        case_map = {\n            \"nvidia\": \"NVIDIA\",\n            \"openai\": \"OpenAI\",\n            \"amazon bedrock\": \"AmazonBedrockEmbeddings\",\n            \"azure openai\": \"AzureOpenAiEmbeddings\",\n            \"cohere\": \"Cohere\",\n            \"jina ai\": \"JinaAI\",\n            \"mistral ai\": \"MistralAI\",\n            \"upstage\": \"Upstage\",\n            \"voyage ai\": \"VoyageAI\",\n        }\n\n        # Adjust the casing on some like nvidia\n        return case_map[provider_name.lower()] if provider_name.lower() in case_map else provider_name.title()\n\n    def _initialize_collection_options(self, api_endpoint: str | None = None):\n        # Nothing to generate if we don't have an API endpoint yet\n        api_endpoint = api_endpoint or self.get_api_endpoint()\n        if not api_endpoint:\n            return []\n\n        # Retrieve the database object\n        database = self.get_database_object(api_endpoint=api_endpoint)\n\n        # Get the list of collections\n        collection_list = database.list_collections(keyspace=self.get_keyspace())\n\n        # Return the list of collections and metadata associated\n        return [\n            {\n                \"name\": col.name,\n                \"records\": self.collection_data(collection_name=col.name, database=database),\n                \"provider\": (\n                    col.definition.vector.service.provider\n                    if col.definition.vector and col.definition.vector.service\n                    else None\n                ),\n                \"icon\": self.get_provider_icon(collection=col),\n                \"model\": (\n                    col.definition.vector.service.model_name\n                    if col.definition.vector and col.definition.vector.service\n                    else None\n                ),\n            }\n            for col in collection_list\n        ]\n\n    def reset_provider_options(self, build_config: dict) -> dict:\n        \"\"\"Reset provider options and related configurations in the build_config dictionary.\"\"\"\n        # Extract template path for cleaner access\n        template = build_config[\"collection_name\"][\"dialog_inputs\"][\"fields\"][\"data\"][\"node\"][\"template\"]\n\n        # Get vectorize providers\n        vectorize_providers_api = self.get_vectorize_providers(\n            token=self.token,\n            environment=self.environment,\n            api_endpoint=build_config[\"api_endpoint\"][\"value\"],\n        )\n\n        # Create a new dictionary with \"Bring your own\" first\n        vectorize_providers: dict[str, list[list[str]]] = {\"Bring your own\": [[], []]}\n\n        # Add the remaining items (only Nvidia) from the original dictionary\n        vectorize_providers.update(\n            {\n                k: v\n                for k, v in vectorize_providers_api.items()\n                if k.lower() in [\"nvidia\"]  # TODO: Eventually support more\n            }\n        )\n\n        # Set provider options\n        provider_field = \"02_embedding_generation_provider\"\n        template[provider_field][\"options\"] = list(vectorize_providers.keys())\n\n        # Add metadata for each provider option\n        template[provider_field][\"options_metadata\"] = [\n            {\"icon\": self.get_provider_icon(provider_name=provider)} for provider in template[provider_field][\"options\"]\n        ]\n\n        # Get selected embedding provider\n        embedding_provider = template[provider_field][\"value\"]\n        is_bring_your_own = embedding_provider and embedding_provider == \"Bring your own\"\n\n        # Configure embedding model field\n        model_field = \"03_embedding_generation_model\"\n        template[model_field].update(\n            {\n                \"options\": vectorize_providers.get(embedding_provider, [[], []])[1],\n                \"placeholder\": \"Bring your own\" if is_bring_your_own else None,\n                \"readonly\": is_bring_your_own,\n                \"required\": not is_bring_your_own,\n                \"value\": None,\n            }\n        )\n\n        # If this is a bring your own, set dimensions to 0\n        return self.reset_dimension_field(build_config)\n\n    def reset_dimension_field(self, build_config: dict) -> dict:\n        \"\"\"Reset dimension field options based on provided configuration.\"\"\"\n        # Extract template path for cleaner access\n        template = build_config[\"collection_name\"][\"dialog_inputs\"][\"fields\"][\"data\"][\"node\"][\"template\"]\n\n        # Get selected embedding model\n        provider_field = \"02_embedding_generation_provider\"\n        embedding_provider = template[provider_field][\"value\"]\n        is_bring_your_own = embedding_provider and embedding_provider == \"Bring your own\"\n\n        # Configure dimension field\n        dimension_field = \"04_dimension\"\n        dimension_value = 1024 if not is_bring_your_own else None  # TODO: Dynamically figure this out\n        template[dimension_field].update(\n            {\n                \"placeholder\": dimension_value,\n                \"value\": dimension_value,\n                \"readonly\": not is_bring_your_own,\n                \"required\": is_bring_your_own,\n            }\n        )\n\n        return build_config\n\n    def reset_collection_list(self, build_config: dict) -> dict:\n        \"\"\"Reset collection list options based on provided configuration.\"\"\"\n        # Get collection options\n        collection_options = self._initialize_collection_options(api_endpoint=build_config[\"api_endpoint\"][\"value\"])\n        # Update collection configuration\n        collection_config = build_config[\"collection_name\"]\n        collection_config.update(\n            {\n                \"options\": [col[\"name\"] for col in collection_options],\n                \"options_metadata\": [{k: v for k, v in col.items() if k != \"name\"} for col in collection_options],\n            }\n        )\n\n        # Reset selected collection if not in options\n        if collection_config[\"value\"] not in collection_config[\"options\"]:\n            collection_config[\"value\"] = \"\"\n\n        # Set advanced status based on database selection\n        collection_config[\"show\"] = bool(build_config[\"database_name\"][\"value\"])\n\n        return build_config\n\n    def reset_database_list(self, build_config: dict) -> dict:\n        \"\"\"Reset database list options and related configurations.\"\"\"\n        # Get database options\n        database_options = self._initialize_database_options()\n\n        # Update cloud provider options\n        env = self.environment\n        template = build_config[\"database_name\"][\"dialog_inputs\"][\"fields\"][\"data\"][\"node\"][\"template\"]\n        template[\"02_cloud_provider\"][\"options\"] = list(self.map_cloud_providers()[env].keys())\n\n        # Update database configuration\n        database_config = build_config[\"database_name\"]\n        database_config.update(\n            {\n                \"options\": [db[\"name\"] for db in database_options],\n                \"options_metadata\": [{k: v for k, v in db.items() if k != \"name\"} for db in database_options],\n            }\n        )\n\n        # Reset selections if value not in options\n        if database_config[\"value\"] not in database_config[\"options\"]:\n            database_config[\"value\"] = \"\"\n            build_config[\"api_endpoint\"][\"value\"] = \"\"\n            build_config[\"collection_name\"][\"show\"] = False\n\n        # Set advanced status based on token presence\n        database_config[\"show\"] = bool(build_config[\"token\"][\"value\"])\n\n        return build_config\n\n    def reset_build_config(self, build_config: dict) -> dict:\n        \"\"\"Reset all build configuration options to default empty state.\"\"\"\n        # Reset database configuration\n        database_config = build_config[\"database_name\"]\n        database_config.update({\"options\": [], \"options_metadata\": [], \"value\": \"\", \"show\": False})\n        build_config[\"api_endpoint\"][\"value\"] = \"\"\n\n        # Reset collection configuration\n        collection_config = build_config[\"collection_name\"]\n        collection_config.update({\"options\": [], \"options_metadata\": [], \"value\": \"\", \"show\": False})\n\n        return build_config\n\n    def _handle_hybrid_search_options(self, build_config: dict) -> dict:\n        \"\"\"Set hybrid search options in the build configuration.\"\"\"\n        # Detect what hybrid options are available\n        # Get the admin object\n        client = DataAPIClient(environment=self.environment)\n        admin_client = client.get_admin()\n        db_admin = admin_client.get_database_admin(self.get_api_endpoint(), token=self.token)\n\n        # We will try to get the reranking providers to see if its hybrid emabled\n        try:\n            providers = db_admin.find_reranking_providers()\n            build_config[\"reranker\"][\"options\"] = [\n                model.name for provider_data in providers.reranking_providers.values() for model in provider_data.models\n            ]\n            build_config[\"reranker\"][\"options_metadata\"] = [\n                {\"icon\": self.get_provider_icon(provider_name=model.name.split(\"/\")[0])}\n                for provider in providers.reranking_providers.values()\n                for model in provider.models\n            ]\n            build_config[\"reranker\"][\"value\"] = build_config[\"reranker\"][\"options\"][0]\n\n            # Set the default search field to hybrid search\n            build_config[\"search_method\"][\"show\"] = True\n            build_config[\"search_method\"][\"options\"] = [\"Hybrid Search\", \"Vector Search\"]\n            build_config[\"search_method\"][\"value\"] = \"Hybrid Search\"\n        except Exception as _:  # noqa: BLE001\n            build_config[\"reranker\"][\"options\"] = []\n            build_config[\"reranker\"][\"options_metadata\"] = []\n\n            # Set the default search field to vector search\n            build_config[\"search_method\"][\"show\"] = False\n            build_config[\"search_method\"][\"options\"] = [\"Vector Search\"]\n            build_config[\"search_method\"][\"value\"] = \"Vector Search\"\n\n        # Set reranker and lexical terms options based on search method\n        build_config[\"reranker\"][\"toggle_value\"] = True\n        build_config[\"reranker\"][\"show\"] = build_config[\"search_method\"][\"value\"] == \"Hybrid Search\"\n        build_config[\"reranker\"][\"toggle_disable\"] = build_config[\"search_method\"][\"value\"] == \"Hybrid Search\"\n        if build_config[\"reranker\"][\"show\"]:\n            build_config[\"search_type\"][\"value\"] = \"Similarity\"\n\n        return build_config\n\n    async def update_build_config(self, build_config: dict, field_value: str, field_name: str | None = None) -> dict:\n        \"\"\"Update build configuration based on field name and value.\"\"\"\n        # Early return if no token provided\n        if not self.token:\n            return self.reset_build_config(build_config)\n\n        # Database creation callback\n        if field_name == \"database_name\" and isinstance(field_value, dict):\n            if \"01_new_database_name\" in field_value:\n                await self._create_new_database(build_config, field_value)\n                return self.reset_collection_list(build_config)\n            return self._update_cloud_regions(build_config, field_value)\n\n        # Collection creation callback\n        if field_name == \"collection_name\" and isinstance(field_value, dict):\n            # Case 1: New collection creation\n            if \"01_new_collection_name\" in field_value:\n                await self._create_new_collection(build_config, field_value)\n                return build_config\n\n            # Case 2: Update embedding provider options\n            if \"02_embedding_generation_provider\" in field_value:\n                return self.reset_provider_options(build_config)\n\n            # Case 3: Update dimension field\n            if \"03_embedding_generation_model\" in field_value:\n                return self.reset_dimension_field(build_config)\n\n        # Initial execution or token/environment change\n        first_run = field_name == \"collection_name\" and not field_value and not build_config[\"database_name\"][\"options\"]\n        if first_run or field_name in {\"token\", \"environment\"}:\n            return self.reset_database_list(build_config)\n\n        # Database selection change\n        if field_name == \"database_name\" and not isinstance(field_value, dict):\n            return self._handle_database_selection(build_config, field_value)\n\n        # Keyspace selection change\n        if field_name == \"keyspace\":\n            return self.reset_collection_list(build_config)\n\n        # Collection selection change\n        if field_name == \"collection_name\" and not isinstance(field_value, dict):\n            return self._handle_collection_selection(build_config, field_value)\n\n        # Search method selection change\n        if field_name == \"search_method\":\n            is_vector_search = field_value == \"Vector Search\"\n            is_autodetect = build_config[\"autodetect_collection\"][\"value\"]\n\n            # Configure lexical terms (same for both cases)\n            build_config[\"lexical_terms\"][\"show\"] = not is_vector_search\n            build_config[\"lexical_terms\"][\"value\"] = \"\" if is_vector_search else build_config[\"lexical_terms\"][\"value\"]\n\n            # Disable reranker disabling if hybrid search is selected\n            build_config[\"reranker\"][\"toggle_disable\"] = not is_vector_search\n            build_config[\"reranker\"][\"toggle_value\"] = True\n            build_config[\"reranker\"][\"value\"] = build_config[\"reranker\"][\"options\"][0]\n\n            # Toggle search type and score threshold based on search method\n            build_config[\"search_type\"][\"show\"] = is_vector_search\n            build_config[\"search_score_threshold\"][\"show\"] = is_vector_search\n\n            # Make sure the search_type is set to \"Similarity\"\n            if not is_vector_search or is_autodetect:\n                build_config[\"search_type\"][\"value\"] = \"Similarity\"\n\n        return build_config\n\n    async def _create_new_database(self, build_config: dict, field_value: dict) -> None:\n        \"\"\"Create a new database and update build config options.\"\"\"\n        try:\n            await self.create_database_api(\n                new_database_name=field_value[\"01_new_database_name\"],\n                token=self.token,\n                keyspace=self.get_keyspace(),\n                environment=self.environment,\n                cloud_provider=field_value[\"02_cloud_provider\"],\n                region=field_value[\"03_region\"],\n            )\n        except Exception as e:\n            msg = f\"Error creating database: {e}\"\n            raise ValueError(msg) from e\n\n        build_config[\"database_name\"][\"options\"].append(field_value[\"01_new_database_name\"])\n        build_config[\"database_name\"][\"options_metadata\"].append(\n            {\n                \"status\": \"PENDING\",\n                \"collections\": 0,\n                \"api_endpoint\": None,\n                \"keyspaces\": [self.get_keyspace()],\n                \"org_id\": None,\n            }\n        )\n\n    def _update_cloud_regions(self, build_config: dict, field_value: dict) -> dict:\n        \"\"\"Update cloud provider regions in build config.\"\"\"\n        env = self.environment\n        cloud_provider = field_value[\"02_cloud_provider\"]\n\n        # Update the region options based on the selected cloud provider\n        template = build_config[\"database_name\"][\"dialog_inputs\"][\"fields\"][\"data\"][\"node\"][\"template\"]\n        template[\"03_region\"][\"options\"] = self.map_cloud_providers()[env][cloud_provider][\"regions\"]\n\n        # Reset the the 03_region value if it's not in the new options\n        if template[\"03_region\"][\"value\"] not in template[\"03_region\"][\"options\"]:\n            template[\"03_region\"][\"value\"] = None\n\n        return build_config\n\n    async def _create_new_collection(self, build_config: dict, field_value: dict) -> None:\n        \"\"\"Create a new collection and update build config options.\"\"\"\n        embedding_provider = field_value.get(\"02_embedding_generation_provider\")\n        try:\n            await self.create_collection_api(\n                new_collection_name=field_value[\"01_new_collection_name\"],\n                token=self.token,\n                api_endpoint=build_config[\"api_endpoint\"][\"value\"],\n                environment=self.environment,\n                keyspace=self.get_keyspace(),\n                dimension=field_value.get(\"04_dimension\") if embedding_provider == \"Bring your own\" else None,\n                embedding_generation_provider=embedding_provider,\n                embedding_generation_model=field_value.get(\"03_embedding_generation_model\"),\n                reranker=self.reranker,\n            )\n        except Exception as e:\n            msg = f\"Error creating collection: {e}\"\n            raise ValueError(msg) from e\n\n        provider = embedding_provider.lower() if embedding_provider and embedding_provider != \"Bring your own\" else None\n        build_config[\"collection_name\"].update(\n            {\n                \"value\": field_value[\"01_new_collection_name\"],\n                \"options\": build_config[\"collection_name\"][\"options\"] + [field_value[\"01_new_collection_name\"]],\n            }\n        )\n        build_config[\"embedding_model\"][\"show\"] = not bool(provider)\n        build_config[\"embedding_model\"][\"required\"] = not bool(provider)\n        build_config[\"collection_name\"][\"options_metadata\"].append(\n            {\n                \"records\": 0,\n                \"provider\": provider,\n                \"icon\": self.get_provider_icon(provider_name=provider),\n                \"model\": field_value.get(\"03_embedding_generation_model\"),\n            }\n        )\n\n        # Make sure we always show the reranker options if the collection is hybrid enabled\n        # And right now they always are\n        build_config[\"lexical_terms\"][\"show\"] = True\n\n    def _handle_database_selection(self, build_config: dict, field_value: str) -> dict:\n        \"\"\"Handle database selection and update related configurations.\"\"\"\n        build_config = self.reset_database_list(build_config)\n\n        # Reset collection list if database selection changes\n        if field_value not in build_config[\"database_name\"][\"options\"]:\n            build_config[\"database_name\"][\"value\"] = \"\"\n            return build_config\n\n        # Get the api endpoint for the selected database\n        index = build_config[\"database_name\"][\"options\"].index(field_value)\n        build_config[\"api_endpoint\"][\"value\"] = build_config[\"database_name\"][\"options_metadata\"][index][\"api_endpoint\"]\n\n        # Get the org_id for the selected database\n        org_id = build_config[\"database_name\"][\"options_metadata\"][index][\"org_id\"]\n        if not org_id:\n            return build_config\n\n        # Update the list of keyspaces based on the db info\n        build_config[\"keyspace\"][\"options\"] = build_config[\"database_name\"][\"options_metadata\"][index][\"keyspaces\"]\n        build_config[\"keyspace\"][\"value\"] = (\n            build_config[\"keyspace\"][\"options\"] and build_config[\"keyspace\"][\"options\"][0]\n            if build_config[\"keyspace\"][\"value\"] not in build_config[\"keyspace\"][\"options\"]\n            else build_config[\"keyspace\"][\"value\"]\n        )\n\n        # Get the database id for the selected database\n        db_id = self.get_database_id_static(api_endpoint=build_config[\"api_endpoint\"][\"value\"])\n        keyspace = self.get_keyspace()\n\n        # Update the helper text for the embedding provider field\n        template = build_config[\"collection_name\"][\"dialog_inputs\"][\"fields\"][\"data\"][\"node\"][\"template\"]\n        template[\"02_embedding_generation_provider\"][\"helper_text\"] = (\n            \"To create collections with more embedding provider options, go to \"\n            f'<a class=\"underline\" target=\"_blank\" rel=\"noopener noreferrer\" '\n            f'href=\"https://astra.datastax.com/org/{org_id}/database/{db_id}/data-explorer?createCollection=1&namespace={keyspace}\">'\n            \"your database in Astra DB</a>.\"\n        )\n\n        # Reset provider options\n        build_config = self.reset_provider_options(build_config)\n\n        # Handle hybrid search options\n        build_config = self._handle_hybrid_search_options(build_config)\n\n        return self.reset_collection_list(build_config)\n\n    def _handle_collection_selection(self, build_config: dict, field_value: str) -> dict:\n        \"\"\"Handle collection selection and update embedding options.\"\"\"\n        build_config[\"autodetect_collection\"][\"value\"] = True\n        build_config = self.reset_collection_list(build_config)\n\n        # Reset embedding model if collection selection changes\n        if field_value and field_value not in build_config[\"collection_name\"][\"options\"]:\n            build_config[\"collection_name\"][\"options\"].append(field_value)\n            build_config[\"collection_name\"][\"options_metadata\"].append(\n                {\n                    \"records\": 0,\n                    \"provider\": None,\n                    \"icon\": \"vectorstores\",\n                    \"model\": None,\n                }\n            )\n            build_config[\"autodetect_collection\"][\"value\"] = False\n\n        if not field_value:\n            return build_config\n\n        # Get the selected collection index\n        index = build_config[\"collection_name\"][\"options\"].index(field_value)\n\n        # Set the provider of the selected collection\n        provider = build_config[\"collection_name\"][\"options_metadata\"][index][\"provider\"]\n        build_config[\"embedding_model\"][\"show\"] = not bool(provider)\n        build_config[\"embedding_model\"][\"required\"] = not bool(provider)\n\n        # Grab the collection object\n        database = self.get_database_object(api_endpoint=build_config[\"api_endpoint\"][\"value\"])\n        collection = database.get_collection(\n            name=field_value,\n            keyspace=build_config[\"keyspace\"][\"value\"],\n        )\n\n        # Check if hybrid and lexical are enabled\n        col_options = collection.options()\n        hyb_enabled = col_options.rerank and col_options.rerank.enabled\n        lex_enabled = col_options.lexical and col_options.lexical.enabled\n        user_hyb_enabled = build_config[\"search_method\"][\"value\"] == \"Hybrid Search\"\n\n        # Show lexical terms if the collection is hybrid enabled\n        build_config[\"lexical_terms\"][\"show\"] = hyb_enabled and lex_enabled and user_hyb_enabled\n\n        return build_config\n\n    @check_cached_vector_store\n    def build_vector_store(self):\n        try:\n            from langchain_astradb import AstraDBVectorStore\n        except ImportError as e:\n            msg = (\n                \"Could not import langchain Astra DB integration package. \"\n                \"Please install it with `pip install langchain-astradb`.\"\n            )\n            raise ImportError(msg) from e\n\n        # Get the embedding model and additional params\n        embedding_params = {\"embedding\": self.embedding_model} if self.embedding_model else {}\n\n        # Get the additional parameters\n        additional_params = self.astradb_vectorstore_kwargs or {}\n\n        # Get Langflow version and platform information\n        __version__ = get_version_info()[\"version\"]\n        langflow_prefix = \"\"\n        # if os.getenv(\"AWS_EXECUTION_ENV\") == \"AWS_ECS_FARGATE\":  # TODO: More precise way of detecting\n        #     langflow_prefix = \"ds-\"\n\n        # Get the database object\n        database = self.get_database_object()\n        autodetect = self.collection_name in database.list_collection_names() and self.autodetect_collection\n\n        # Bundle up the auto-detect parameters\n        autodetect_params = {\n            \"autodetect_collection\": autodetect,\n            \"content_field\": (\n                self.content_field\n                if self.content_field and embedding_params\n                else (\n                    \"page_content\"\n                    if embedding_params\n                    and self.collection_data(collection_name=self.collection_name, database=database) == 0\n                    else None\n                )\n            ),\n            \"ignore_invalid_documents\": self.ignore_invalid_documents,\n        }\n\n        # Choose HybridSearchMode based on the selected param\n        hybrid_search_mode = HybridSearchMode.DEFAULT if self.search_method == \"Hybrid Search\" else HybridSearchMode.OFF\n\n        # Attempt to build the Vector Store object\n        try:\n            vector_store = AstraDBVectorStore(\n                # Astra DB Authentication Parameters\n                token=self.token,\n                api_endpoint=database.api_endpoint,\n                namespace=database.keyspace,\n                collection_name=self.collection_name,\n                environment=self.environment,\n                # Hybrid Search Parameters\n                hybrid_search=hybrid_search_mode,\n                # Astra DB Usage Tracking Parameters\n                ext_callers=[(f\"{langflow_prefix}langflow\", __version__)],\n                # Astra DB Vector Store Parameters\n                **autodetect_params,\n                **embedding_params,\n                **additional_params,\n            )\n        except Exception as e:\n            msg = f\"Error initializing AstraDBVectorStore: {e}\"\n            raise ValueError(msg) from e\n\n        # Add documents to the vector store\n        self._add_documents_to_vector_store(vector_store)\n\n        return vector_store\n\n    def _add_documents_to_vector_store(self, vector_store) -> None:\n        self.ingest_data = self._prepare_ingest_data()\n\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                msg = \"Vector Store Inputs must be Data objects.\"\n                raise TypeError(msg)\n\n        if documents and self.deletion_field:\n            self.log(f\"Deleting documents where {self.deletion_field}\")\n            try:\n                database = self.get_database_object()\n                collection = database.get_collection(self.collection_name, keyspace=database.keyspace)\n                delete_values = list({doc.metadata[self.deletion_field] for doc in documents})\n                self.log(f\"Deleting documents where {self.deletion_field} matches {delete_values}.\")\n                collection.delete_many({f\"metadata.{self.deletion_field}\": {\"$in\": delete_values}})\n            except Exception as e:\n                msg = f\"Error deleting documents from AstraDBVectorStore based on '{self.deletion_field}': {e}\"\n                raise ValueError(msg) from e\n\n        if documents:\n            self.log(f\"Adding {len(documents)} documents to the Vector Store.\")\n            try:\n                vector_store.add_documents(documents)\n            except Exception as e:\n                msg = f\"Error adding documents to AstraDBVectorStore: {e}\"\n                raise ValueError(msg) from e\n        else:\n            self.log(\"No documents to add to the Vector Store.\")\n\n    def _map_search_type(self) -> str:\n        search_type_mapping = {\n            \"Similarity with score threshold\": \"similarity_score_threshold\",\n            \"MMR (Max Marginal Relevance)\": \"mmr\",\n        }\n\n        return search_type_mapping.get(self.search_type, \"similarity\")\n\n    def _build_search_args(self):\n        # Clean up the search query\n        query = self.search_query if isinstance(self.search_query, str) and self.search_query.strip() else None\n        lexical_terms = self.lexical_terms or None\n\n        # Check if we have a search query, and if so set the args\n        if query:\n            args = {\n                \"query\": query,\n                \"search_type\": self._map_search_type(),\n                \"k\": self.number_of_results,\n                \"score_threshold\": self.search_score_threshold,\n                \"lexical_query\": lexical_terms,\n            }\n        elif self.advanced_search_filter:\n            args = {\n                \"n\": self.number_of_results,\n            }\n        else:\n            return {}\n\n        filter_arg = self.advanced_search_filter or {}\n        if filter_arg:\n            args[\"filter\"] = filter_arg\n\n        return args\n\n    def search_documents(self, vector_store=None) -> list[Data]:\n        vector_store = vector_store or self.build_vector_store()\n\n        self.log(f\"Search input: {self.search_query}\")\n        self.log(f\"Search type: {self.search_type}\")\n        self.log(f\"Number of results: {self.number_of_results}\")\n        self.log(f\"store.hybrid_search: {vector_store.hybrid_search}\")\n        self.log(f\"Lexical terms: {self.lexical_terms}\")\n        self.log(f\"Reranker: {self.reranker}\")\n\n        try:\n            search_args = self._build_search_args()\n        except Exception as e:\n            msg = f\"Error in AstraDBVectorStore._build_search_args: {e}\"\n            raise ValueError(msg) from e\n\n        if not search_args:\n            self.log(\"No search input or filters provided. Skipping search.\")\n            return []\n\n        docs = []\n        search_method = \"search\" if \"query\" in search_args else \"metadata_search\"\n\n        try:\n            self.log(f\"Calling vector_store.{search_method} with args: {search_args}\")\n            docs = getattr(vector_store, search_method)(**search_args)\n        except Exception as e:\n            msg = f\"Error performing {search_method} in AstraDBVectorStore: {e}\"\n            raise ValueError(msg) from e\n\n        self.log(f\"Retrieved documents: {len(docs)}\")\n\n        data = docs_to_data(docs)\n        self.log(f\"Converted documents to data: {len(data)}\")\n        self.status = data\n\n        return data\n\n    def get_retriever_kwargs(self):\n        search_args = self._build_search_args()\n\n        return {\n            \"search_type\": self._map_search_type(),\n            \"search_kwargs\": search_args,\n        }\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "collection_name": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [],
        "options_metadata": [],
        "combobox": true,
        "dialog_inputs": {
          "functionality": "create",
          "fields": {
            "data": {
              "node": {
                "name": "create_collection",
                "description": "Please allow several seconds for creation to complete.",
                "display_name": "Create new collection",
                "field_order": [
                  "01_new_collection_name",
                  "02_embedding_generation_provider",
                  "03_embedding_generation_model",
                  "04_dimension"
                ],
                "template": {
                  "01_new_collection_name": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": true,
                    "placeholder": "",
                    "show": true,
                    "name": "new_collection_name",
                    "value": "",
                    "display_name": "Name",
                    "advanced": false,
                    "dynamic": false,
                    "info": "Name of the new collection to create in Astra DB.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "StrInput"
                  },
                  "02_embedding_generation_provider": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "options": [],
                    "options_metadata": [],
                    "combobox": false,
                    "dialog_inputs": {},
                    "toggle": false,
                    "required": true,
                    "placeholder": "",
                    "show": true,
                    "name": "embedding_generation_provider",
                    "value": "",
                    "display_name": "Embedding generation method",
                    "advanced": false,
                    "dynamic": false,
                    "helper_text": "To create collections with more embedding provider options, go to <a class=\"underline\" href=\"https://astra.datastax.com/\" target=\" _blank\" rel=\"noopener noreferrer\">your database in Astra DB</a>",
                    "info": "Provider to use for generating embeddings.",
                    "real_time_refresh": true,
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                  },
                  "03_embedding_generation_model": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "options": [],
                    "options_metadata": [],
                    "combobox": false,
                    "dialog_inputs": {},
                    "toggle": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "embedding_generation_model",
                    "value": "",
                    "display_name": "Embedding model",
                    "advanced": false,
                    "dynamic": false,
                    "info": "Model to use for generating embeddings.",
                    "real_time_refresh": true,
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                  },
                  "04_dimension": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "dimension",
                    "display_name": "Dimensions",
                    "advanced": false,
                    "dynamic": false,
                    "info": "Dimensions of the embeddings to generate.",
                    "title_case": false,
                    "type": "int",
                    "_input_type": "IntInput"
                  }
                }
              }
            }
          }
        },
        "toggle": false,
        "required": true,
        "placeholder": "",
        "show": false,
        "name": "collection_name",
        "value": "",
        "display_name": "Collection",
        "advanced": false,
        "dynamic": false,
        "info": "The name of the collection within Astra DB where the vectors will be stored.",
        "real_time_refresh": true,
        "refresh_button": true,
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "content_field": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "content_field",
        "value": "",
        "display_name": "Content Field",
        "advanced": true,
        "dynamic": false,
        "info": "Field to use as the text content field for the vector store.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "database_name": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [],
        "options_metadata": [],
        "combobox": true,
        "dialog_inputs": {
          "functionality": "create",
          "fields": {
            "data": {
              "node": {
                "name": "create_database",
                "description": "Please allow several minutes for creation to complete.",
                "display_name": "Create new database",
                "field_order": [
                  "01_new_database_name",
                  "02_cloud_provider",
                  "03_region"
                ],
                "template": {
                  "01_new_database_name": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": true,
                    "placeholder": "",
                    "show": true,
                    "name": "new_database_name",
                    "value": "",
                    "display_name": "Name",
                    "advanced": false,
                    "dynamic": false,
                    "info": "Name of the new database to create in Astra DB.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "StrInput"
                  },
                  "02_cloud_provider": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "options": [],
                    "options_metadata": [],
                    "combobox": false,
                    "dialog_inputs": {},
                    "toggle": false,
                    "required": true,
                    "placeholder": "",
                    "show": true,
                    "name": "cloud_provider",
                    "value": "",
                    "display_name": "Cloud provider",
                    "advanced": false,
                    "dynamic": false,
                    "info": "Cloud provider for the new database.",
                    "real_time_refresh": true,
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                  },
                  "03_region": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "options": [],
                    "options_metadata": [],
                    "combobox": false,
                    "dialog_inputs": {},
                    "toggle": false,
                    "required": true,
                    "placeholder": "",
                    "show": true,
                    "name": "region",
                    "value": "",
                    "display_name": "Region",
                    "advanced": false,
                    "dynamic": false,
                    "info": "Region for the new database.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                  }
                }
              }
            }
          }
        },
        "toggle": false,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "database_name",
        "value": "",
        "display_name": "Database",
        "advanced": false,
        "dynamic": false,
        "info": "The Database name for the Astra DB instance.",
        "real_time_refresh": true,
        "refresh_button": true,
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "deletion_field": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "deletion_field",
        "value": "",
        "display_name": "Deletion Based On Field",
        "advanced": true,
        "dynamic": false,
        "info": "When this parameter is provided, documents in the target collection with metadata field values matching the input metadata field value will be deleted before new data is loaded.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "environment": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "prod",
          "test",
          "dev"
        ],
        "options_metadata": [],
        "combobox": true,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "environment",
        "value": "prod",
        "display_name": "Environment",
        "advanced": true,
        "dynamic": false,
        "info": "The environment for the Astra DB API Endpoint.",
        "real_time_refresh": true,
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "ignore_invalid_documents": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "ignore_invalid_documents",
        "value": false,
        "display_name": "Ignore Invalid Documents",
        "advanced": true,
        "dynamic": false,
        "info": "Boolean flag to determine whether to ignore invalid documents at runtime.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "keyspace": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "keyspace",
        "value": "",
        "display_name": "Keyspace",
        "advanced": true,
        "dynamic": false,
        "info": "Optional keyspace within Astra DB to use for the collection.",
        "real_time_refresh": true,
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "lexical_terms": {
        "separator": " ",
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "Enter terms to search...",
        "show": false,
        "name": "lexical_terms",
        "value": "",
        "display_name": "Lexical Terms",
        "advanced": true,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Add additional terms/keywords to augment search precision.",
        "title_case": false,
        "type": "query",
        "_input_type": "QueryInput"
      },
      "number_of_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "number_of_results",
        "value": 4,
        "display_name": "Number of Search Results",
        "advanced": true,
        "dynamic": false,
        "info": "Number of search results to return.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "reranker": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": true,
        "required": false,
        "placeholder": "",
        "show": false,
        "name": "reranker",
        "value": "",
        "display_name": "Reranker",
        "advanced": false,
        "dynamic": false,
        "info": "Post-retrieval model that re-scores results for optimal relevance ranking.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "search_method": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "Hybrid Search",
          "Vector Search"
        ],
        "options_metadata": [
          {
            "icon": "SearchHybrid"
          },
          {
            "icon": "SearchVector"
          }
        ],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_method",
        "value": "Vector Search",
        "display_name": "Search Method",
        "advanced": true,
        "dynamic": false,
        "info": "Determine how your content is matched: Vector finds semantic similarity, and Hybrid Search (suggested) combines both approaches with a reranker.",
        "real_time_refresh": true,
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "search_query": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "Enter a query...",
        "show": true,
        "name": "search_query",
        "value": "",
        "display_name": "Search Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Enter a query to run a similarity search.",
        "title_case": false,
        "type": "query",
        "_input_type": "QueryInput"
      },
      "search_score_threshold": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_score_threshold",
        "value": 0,
        "display_name": "Search Score Threshold",
        "advanced": true,
        "dynamic": false,
        "info": "Minimum similarity score threshold for search results. (when using 'Similarity with score threshold')",
        "title_case": false,
        "type": "float",
        "_input_type": "FloatInput"
      },
      "search_type": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "Similarity",
          "Similarity with score threshold",
          "MMR (Max Marginal Relevance)"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_type",
        "value": "Similarity",
        "display_name": "Search Type",
        "advanced": true,
        "dynamic": false,
        "info": "Search type to use",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "should_cache_vector_store": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "should_cache_vector_store",
        "value": true,
        "display_name": "Cache Vector Store",
        "advanced": true,
        "dynamic": false,
        "info": "If True, the vector store will be cached for the current build of the component. This is useful for components that have multiple output methods and want to share the same vector store.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "token": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "token",
        "value": "ASTRA_DB_APPLICATION_TOKEN",
        "display_name": "Astra DB Application Token",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "Authentication token for accessing Astra DB.",
        "real_time_refresh": true,
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      }
    },
    "description": "Ingest and search documents in Astra DB",
    "icon": "AstraDB",
    "base_classes": [
      "Data",
      "DataFrame",
      "VectorStore"
    ],
    "display_name": "Astra DB",
    "documentation": "https://docs.datastax.com/en/langflow/astra-components.html",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "search_results",
        "display_name": "Search Results",
        "method": "search_documents",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "collection_name",
          "database_name",
          "token"
        ],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "VectorStore"
        ],
        "selected": "VectorStore",
        "name": "vectorstoreconnection",
        "hidden": true,
        "display_name": "Vector Store Connection",
        "method": "as_vector_store",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "token",
      "environment",
      "database_name",
      "api_endpoint",
      "keyspace",
      "collection_name",
      "embedding_model",
      "ingest_data",
      "search_query",
      "should_cache_vector_store",
      "search_method",
      "reranker",
      "lexical_terms",
      "number_of_results",
      "search_type",
      "search_score_threshold",
      "advanced_search_filter",
      "autodetect_collection",
      "content_field",
      "deletion_field",
      "ignore_invalid_documents",
      "astradb_vectorstore_kwargs"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "MongoDBAtlasVector": {
    "template": {
      "_type": "Component",
      "embedding": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "embedding",
        "value": "",
        "display_name": "Embedding",
        "advanced": false,
        "input_types": [
          "Embeddings"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "ingest_data": {
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "ingest_data",
        "value": "",
        "display_name": "Ingest Data",
        "advanced": false,
        "input_types": [
          "Data",
          "DataFrame"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "import tempfile\nimport time\n\nimport certifi\nfrom langchain_community.vectorstores import MongoDBAtlasVectorSearch\nfrom pymongo.collection import Collection\nfrom pymongo.operations import SearchIndexModel\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.io import BoolInput, DropdownInput, HandleInput, IntInput, SecretStrInput, StrInput\nfrom langflow.schema import Data\n\n\nclass MongoVectorStoreComponent(LCVectorStoreComponent):\n    display_name = \"MongoDB Atlas\"\n    description = \"MongoDB Atlas Vector Store with search capabilities\"\n    name = \"MongoDBAtlasVector\"\n    icon = \"MongoDB\"\n    INSERT_MODES = [\"append\", \"overwrite\"]\n    SIMILARITY_OPTIONS = [\"cosine\", \"euclidean\", \"dotProduct\"]\n    QUANTIZATION_OPTIONS = [\"scalar\", \"binary\"]\n    inputs = [\n        SecretStrInput(name=\"mongodb_atlas_cluster_uri\", display_name=\"MongoDB Atlas Cluster URI\", required=True),\n        BoolInput(name=\"enable_mtls\", display_name=\"Enable mTLS\", value=False, advanced=True, required=True),\n        SecretStrInput(\n            name=\"mongodb_atlas_client_cert\",\n            display_name=\"MongoDB Atlas Combined Client Certificate\",\n            required=False,\n            info=\"Client Certificate combined with the private key in the following format:\\n \"\n            \"-----BEGIN PRIVATE KEY-----\\n...\\n -----END PRIVATE KEY-----\\n-----BEGIN CERTIFICATE-----\\n\"\n            \"...\\n-----END CERTIFICATE-----\\n\",\n        ),\n        StrInput(name=\"db_name\", display_name=\"Database Name\", required=True),\n        StrInput(name=\"collection_name\", display_name=\"Collection Name\", required=True),\n        StrInput(\n            name=\"index_name\",\n            display_name=\"Index Name\",\n            required=True,\n            info=\"The name of Atlas Search index, it should be a Vector Search.\",\n        ),\n        *LCVectorStoreComponent.inputs,\n        DropdownInput(\n            name=\"insert_mode\",\n            display_name=\"Insert Mode\",\n            options=INSERT_MODES,\n            value=INSERT_MODES[0],\n            info=\"How to insert new documents into the collection.\",\n            advanced=True,\n        ),\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            value=4,\n            advanced=True,\n        ),\n        StrInput(\n            name=\"index_field\",\n            display_name=\"Index Field\",\n            advanced=True,\n            required=True,\n            info=\"The field to index.\",\n            value=\"embedding\",\n        ),\n        StrInput(\n            name=\"filter_field\", display_name=\"Filter Field\", advanced=True, info=\"The field to filter the index.\"\n        ),\n        IntInput(\n            name=\"number_dimensions\",\n            display_name=\"Number of Dimensions\",\n            info=\"Embedding Context Length.\",\n            value=1536,\n            advanced=True,\n            required=True,\n        ),\n        DropdownInput(\n            name=\"similarity\",\n            display_name=\"Similarity\",\n            options=SIMILARITY_OPTIONS,\n            value=SIMILARITY_OPTIONS[0],\n            info=\"The method used to measure the similarity between vectors.\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"quantization\",\n            display_name=\"Quantization\",\n            options=QUANTIZATION_OPTIONS,\n            value=None,\n            info=\"Quantization reduces memory costs converting 32-bit floats to smaller data types\",\n            advanced=True,\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> MongoDBAtlasVectorSearch:\n        try:\n            from pymongo import MongoClient\n        except ImportError as e:\n            msg = \"Please install pymongo to use MongoDB Atlas Vector Store\"\n            raise ImportError(msg) from e\n\n        # Create temporary files for the client certificate\n        if self.enable_mtls:\n            client_cert_path = None\n            try:\n                client_cert = self.mongodb_atlas_client_cert.replace(\" \", \"\\n\")\n                client_cert = client_cert.replace(\"-----BEGIN\\nPRIVATE\\nKEY-----\", \"-----BEGIN PRIVATE KEY-----\")\n                client_cert = client_cert.replace(\n                    \"-----END\\nPRIVATE\\nKEY-----\\n-----BEGIN\\nCERTIFICATE-----\",\n                    \"-----END PRIVATE KEY-----\\n-----BEGIN CERTIFICATE-----\",\n                )\n                client_cert = client_cert.replace(\"-----END\\nCERTIFICATE-----\", \"-----END CERTIFICATE-----\")\n                with tempfile.NamedTemporaryFile(delete=False) as client_cert_file:\n                    client_cert_file.write(client_cert.encode(\"utf-8\"))\n                    client_cert_path = client_cert_file.name\n\n            except Exception as e:\n                msg = f\"Failed to write certificate to temporary file: {e}\"\n                raise ValueError(msg) from e\n\n        try:\n            mongo_client: MongoClient = (\n                MongoClient(\n                    self.mongodb_atlas_cluster_uri,\n                    tls=True,\n                    tlsCertificateKeyFile=client_cert_path,\n                    tlsCAFile=certifi.where(),\n                )\n                if self.enable_mtls\n                else MongoClient(self.mongodb_atlas_cluster_uri)\n            )\n\n            collection = mongo_client[self.db_name][self.collection_name]\n\n        except Exception as e:\n            msg = f\"Failed to connect to MongoDB Atlas: {e}\"\n            raise ValueError(msg) from e\n\n        # Convert DataFrame to Data if needed using parent's method\n        self.ingest_data = self._prepare_ingest_data()\n\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                documents.append(_input)\n\n        if documents:\n            self.__insert_mode(collection)\n\n            return MongoDBAtlasVectorSearch.from_documents(\n                documents=documents, embedding=self.embedding, collection=collection, index_name=self.index_name\n            )\n        return MongoDBAtlasVectorSearch(embedding=self.embedding, collection=collection, index_name=self.index_name)\n\n    def search_documents(self) -> list[Data]:\n        from bson.objectid import ObjectId\n\n        vector_store = self.build_vector_store()\n\n        self.verify_search_index(vector_store._collection)\n\n        if self.search_query and isinstance(self.search_query, str):\n            docs = vector_store.similarity_search(\n                query=self.search_query,\n                k=self.number_of_results,\n            )\n            for doc in docs:\n                doc.metadata = {\n                    key: str(value) if isinstance(value, ObjectId) else value for key, value in doc.metadata.items()\n                }\n\n            data = docs_to_data(docs)\n            self.status = data\n            return data\n        return []\n\n    def __insert_mode(self, collection: Collection) -> None:\n        if self.insert_mode == \"overwrite\":\n            collection.delete_many({})  # Delete all documents while preserving collection structure\n\n    def verify_search_index(self, collection: Collection) -> None:\n        \"\"\"Verify if the search index exists, if not, create it.\n\n        Args:\n            collection (Collection): The collection to verify the search index on.\n        \"\"\"\n        indexes = collection.list_search_indexes()\n\n        index_names_types = {idx[\"name\"]: idx[\"type\"] for idx in indexes}\n        index_names = list(index_names_types.keys())\n        index_type = index_names_types.get(self.index_name)\n        if self.index_name not in index_names and index_type != \"vectorSearch\":\n            collection.create_search_index(self.__create_index_definition())\n\n            time.sleep(20)  # Give some time for index to be ready\n\n    def __create_index_definition(self) -> SearchIndexModel:\n        fields = [\n            {\n                \"type\": \"vector\",\n                \"path\": self.index_field,\n                \"numDimensions\": self.number_dimensions,\n                \"similarity\": self.similarity,\n                \"quantization\": self.quantization,\n            }\n        ]\n        if self.filter_field:\n            fields.append({\"type\": \"filter\", \"path\": self.filter_field})\n        return SearchIndexModel(definition={\"fields\": fields}, name=self.index_name, type=\"vectorSearch\")\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "collection_name": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "collection_name",
        "value": "",
        "display_name": "Collection Name",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "db_name": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "db_name",
        "value": "",
        "display_name": "Database Name",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "enable_mtls": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "enable_mtls",
        "value": false,
        "display_name": "Enable mTLS",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "filter_field": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "filter_field",
        "value": "",
        "display_name": "Filter Field",
        "advanced": true,
        "dynamic": false,
        "info": "The field to filter the index.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "index_field": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "index_field",
        "value": "embedding",
        "display_name": "Index Field",
        "advanced": true,
        "dynamic": false,
        "info": "The field to index.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "index_name": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "index_name",
        "value": "",
        "display_name": "Index Name",
        "advanced": false,
        "dynamic": false,
        "info": "The name of Atlas Search index, it should be a Vector Search.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "insert_mode": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "append",
          "overwrite"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "insert_mode",
        "value": "append",
        "display_name": "Insert Mode",
        "advanced": true,
        "dynamic": false,
        "info": "How to insert new documents into the collection.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "mongodb_atlas_client_cert": {
        "load_from_db": true,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "mongodb_atlas_client_cert",
        "value": "",
        "display_name": "MongoDB Atlas Combined Client Certificate",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "Client Certificate combined with the private key in the following format:\n -----BEGIN PRIVATE KEY-----\n...\n -----END PRIVATE KEY-----\n-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----\n",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "mongodb_atlas_cluster_uri": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "mongodb_atlas_cluster_uri",
        "value": "",
        "display_name": "MongoDB Atlas Cluster URI",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "number_dimensions": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "number_dimensions",
        "value": 1536,
        "display_name": "Number of Dimensions",
        "advanced": true,
        "dynamic": false,
        "info": "Embedding Context Length.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "number_of_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "number_of_results",
        "value": 4,
        "display_name": "Number of Results",
        "advanced": true,
        "dynamic": false,
        "info": "Number of results to return.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "quantization": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "scalar",
          "binary"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "quantization",
        "display_name": "Quantization",
        "advanced": true,
        "dynamic": false,
        "info": "Quantization reduces memory costs converting 32-bit floats to smaller data types",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "search_query": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "Enter a query...",
        "show": true,
        "name": "search_query",
        "value": "",
        "display_name": "Search Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Enter a query to run a similarity search.",
        "title_case": false,
        "type": "query",
        "_input_type": "QueryInput"
      },
      "should_cache_vector_store": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "should_cache_vector_store",
        "value": true,
        "display_name": "Cache Vector Store",
        "advanced": true,
        "dynamic": false,
        "info": "If True, the vector store will be cached for the current build of the component. This is useful for components that have multiple output methods and want to share the same vector store.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "similarity": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "cosine",
          "euclidean",
          "dotProduct"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "similarity",
        "value": "cosine",
        "display_name": "Similarity",
        "advanced": true,
        "dynamic": false,
        "info": "The method used to measure the similarity between vectors.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      }
    },
    "description": "MongoDB Atlas Vector Store with search capabilities",
    "icon": "MongoDB",
    "base_classes": [
      "Data",
      "DataFrame"
    ],
    "display_name": "MongoDB Atlas",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "search_results",
        "display_name": "Search Results",
        "method": "search_documents",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "collection_name",
          "db_name",
          "enable_mtls",
          "index_field",
          "index_name",
          "mongodb_atlas_cluster_uri",
          "number_dimensions"
        ],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "mongodb_atlas_cluster_uri",
      "enable_mtls",
      "mongodb_atlas_client_cert",
      "db_name",
      "collection_name",
      "index_name",
      "ingest_data",
      "search_query",
      "should_cache_vector_store",
      "insert_mode",
      "embedding",
      "number_of_results",
      "index_field",
      "filter_field",
      "number_dimensions",
      "similarity",
      "quantization"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "FAISS": {
    "template": {
      "_type": "Component",
      "embedding": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "embedding",
        "value": "",
        "display_name": "Embedding",
        "advanced": false,
        "input_types": [
          "Embeddings"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "ingest_data": {
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "ingest_data",
        "value": "",
        "display_name": "Ingest Data",
        "advanced": false,
        "input_types": [
          "Data",
          "DataFrame"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "allow_dangerous_deserialization": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "allow_dangerous_deserialization",
        "value": true,
        "display_name": "Allow Dangerous Deserialization",
        "advanced": true,
        "dynamic": false,
        "info": "Set to True to allow loading pickle files from untrusted sources. Only enable this if you trust the source of the data.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from pathlib import Path\n\nfrom langchain_community.vectorstores import FAISS\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.io import BoolInput, HandleInput, IntInput, StrInput\nfrom langflow.schema import Data\n\n\nclass FaissVectorStoreComponent(LCVectorStoreComponent):\n    \"\"\"FAISS Vector Store with search capabilities.\"\"\"\n\n    display_name: str = \"FAISS\"\n    description: str = \"FAISS Vector Store with search capabilities\"\n    name = \"FAISS\"\n    icon = \"FAISS\"\n\n    inputs = [\n        StrInput(\n            name=\"index_name\",\n            display_name=\"Index Name\",\n            value=\"langflow_index\",\n        ),\n        StrInput(\n            name=\"persist_directory\",\n            display_name=\"Persist Directory\",\n            info=\"Path to save the FAISS index. It will be relative to where Langflow is running.\",\n        ),\n        *LCVectorStoreComponent.inputs,\n        BoolInput(\n            name=\"allow_dangerous_deserialization\",\n            display_name=\"Allow Dangerous Deserialization\",\n            info=\"Set to True to allow loading pickle files from untrusted sources. \"\n            \"Only enable this if you trust the source of the data.\",\n            advanced=True,\n            value=True,\n        ),\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            advanced=True,\n            value=4,\n        ),\n    ]\n\n    @staticmethod\n    def resolve_path(path: str) -> str:\n        \"\"\"Resolve the path relative to the Langflow root.\n\n        Args:\n            path: The path to resolve\n        Returns:\n            str: The resolved path as a string\n        \"\"\"\n        return str(Path(path).resolve())\n\n    def get_persist_directory(self) -> Path:\n        \"\"\"Returns the resolved persist directory path or the current directory if not set.\"\"\"\n        if self.persist_directory:\n            return Path(self.resolve_path(self.persist_directory))\n        return Path()\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> FAISS:\n        \"\"\"Builds the FAISS object.\"\"\"\n        path = self.get_persist_directory()\n        path.mkdir(parents=True, exist_ok=True)\n\n        # Convert DataFrame to Data if needed using parent's method\n        self.ingest_data = self._prepare_ingest_data()\n\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                documents.append(_input)\n\n        faiss = FAISS.from_documents(documents=documents, embedding=self.embedding)\n        faiss.save_local(str(path), self.index_name)\n        return faiss\n\n    def search_documents(self) -> list[Data]:\n        \"\"\"Search for documents in the FAISS vector store.\"\"\"\n        path = self.get_persist_directory()\n        index_path = path / f\"{self.index_name}.faiss\"\n\n        if not index_path.exists():\n            vector_store = self.build_vector_store()\n        else:\n            vector_store = FAISS.load_local(\n                folder_path=str(path),\n                embeddings=self.embedding,\n                index_name=self.index_name,\n                allow_dangerous_deserialization=self.allow_dangerous_deserialization,\n            )\n\n        if not vector_store:\n            msg = \"Failed to load the FAISS index.\"\n            raise ValueError(msg)\n\n        if self.search_query and isinstance(self.search_query, str) and self.search_query.strip():\n            docs = vector_store.similarity_search(\n                query=self.search_query,\n                k=self.number_of_results,\n            )\n            return docs_to_data(docs)\n        return []\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "index_name": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "index_name",
        "value": "langflow_index",
        "display_name": "Index Name",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "number_of_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "number_of_results",
        "value": 4,
        "display_name": "Number of Results",
        "advanced": true,
        "dynamic": false,
        "info": "Number of results to return.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "persist_directory": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "persist_directory",
        "value": "",
        "display_name": "Persist Directory",
        "advanced": false,
        "dynamic": false,
        "info": "Path to save the FAISS index. It will be relative to where Langflow is running.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "search_query": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "Enter a query...",
        "show": true,
        "name": "search_query",
        "value": "",
        "display_name": "Search Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Enter a query to run a similarity search.",
        "title_case": false,
        "type": "query",
        "_input_type": "QueryInput"
      },
      "should_cache_vector_store": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "should_cache_vector_store",
        "value": true,
        "display_name": "Cache Vector Store",
        "advanced": true,
        "dynamic": false,
        "info": "If True, the vector store will be cached for the current build of the component. This is useful for components that have multiple output methods and want to share the same vector store.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      }
    },
    "description": "FAISS Vector Store with search capabilities",
    "icon": "FAISS",
    "base_classes": [
      "Data",
      "DataFrame"
    ],
    "display_name": "FAISS",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "search_results",
        "display_name": "Search Results",
        "method": "search_documents",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "index_name",
      "persist_directory",
      "ingest_data",
      "search_query",
      "should_cache_vector_store",
      "allow_dangerous_deserialization",
      "embedding",
      "number_of_results"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "LocalDB": {
    "template": {
      "_type": "Component",
      "embedding": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "embedding",
        "value": "",
        "display_name": "Embedding",
        "advanced": false,
        "input_types": [
          "Embeddings"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "ingest_data": {
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "ingest_data",
        "value": "",
        "display_name": "Ingest Data",
        "advanced": false,
        "input_types": [
          "Data",
          "DataFrame"
        ],
        "dynamic": false,
        "info": "Data to store. It will be embedded and indexed for semantic search.",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "allow_duplicates": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "allow_duplicates",
        "value": false,
        "display_name": "Allow Duplicates",
        "advanced": true,
        "dynamic": false,
        "info": "If false, will not add documents that are already in the Vector Store.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from copy import deepcopy\nfrom pathlib import Path\n\nfrom langchain_chroma import Chroma\nfrom loguru import logger\nfrom typing_extensions import override\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.base.vectorstores.utils import chroma_collection_to_data\nfrom langflow.inputs.inputs import MultilineInput\nfrom langflow.io import BoolInput, DropdownInput, HandleInput, IntInput, MessageTextInput, TabInput\nfrom langflow.schema import Data, DataFrame\nfrom langflow.template.field.base import Output\n\n\nclass LocalDBComponent(LCVectorStoreComponent):\n    \"\"\"Chroma Vector Store with search capabilities.\"\"\"\n\n    display_name: str = \"Local DB\"\n    description: str = \"Local Vector Store with search capabilities\"\n    name = \"LocalDB\"\n    icon = \"database\"\n\n    inputs = [\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Ingest\", \"Retrieve\"],\n            info=\"Select the operation mode\",\n            value=\"Ingest\",\n            real_time_refresh=True,\n            show=True,\n        ),\n        MessageTextInput(\n            name=\"collection_name\",\n            display_name=\"Collection Name\",\n            value=\"langflow\",\n        ),\n        MessageTextInput(\n            name=\"persist_directory\",\n            display_name=\"Persist Directory\",\n            info=(\n                \"Custom base directory to save the vector store. \"\n                \"Collections will be stored under '{directory}/vector_stores/{collection_name}'. \"\n                \"If not specified, it will use your system's cache folder.\"\n            ),\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"existing_collections\",\n            display_name=\"Existing Collections\",\n            options=[],  # Will be populated dynamically\n            info=\"Select a previously created collection to search through its stored data.\",\n            show=False,\n            combobox=True,\n        ),\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n        BoolInput(\n            name=\"allow_duplicates\",\n            display_name=\"Allow Duplicates\",\n            advanced=True,\n            info=\"If false, will not add documents that are already in the Vector Store.\",\n        ),\n        DropdownInput(\n            name=\"search_type\",\n            display_name=\"Search Type\",\n            options=[\"Similarity\", \"MMR\"],\n            value=\"Similarity\",\n            advanced=True,\n        ),\n        HandleInput(\n            name=\"ingest_data\",\n            display_name=\"Ingest Data\",\n            input_types=[\"Data\", \"DataFrame\"],\n            is_list=True,\n            info=\"Data to store. It will be embedded and indexed for semantic search.\",\n            show=True,\n        ),\n        MultilineInput(\n            name=\"search_query\",\n            display_name=\"Search Query\",\n            tool_mode=True,\n            info=\"Enter text to search for similar content in the selected collection.\",\n            show=False,\n        ),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            advanced=True,\n            value=10,\n        ),\n        IntInput(\n            name=\"limit\",\n            display_name=\"Limit\",\n            advanced=True,\n            info=\"Limit the number of records to compare when Allow Duplicates is False.\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"DataFrame\", name=\"dataframe\", method=\"as_dataframe\"),\n    ]\n\n    def get_vector_store_directory(self, base_dir: str | Path) -> Path:\n        \"\"\"Get the full directory path for a collection.\"\"\"\n        # Ensure base_dir is a Path object\n        base_dir = Path(base_dir)\n        # Create the full path: base_dir/vector_stores/collection_name\n        full_path = base_dir / \"vector_stores\" / self.collection_name\n        # Create the directory if it doesn't exist\n        full_path.mkdir(parents=True, exist_ok=True)\n        return full_path\n\n    def get_default_persist_dir(self) -> str:\n        \"\"\"Get the default persist directory from cache.\"\"\"\n        from langflow.services.cache.utils import CACHE_DIR\n\n        return str(self.get_vector_store_directory(CACHE_DIR))\n\n    def list_existing_collections(self) -> list[str]:\n        \"\"\"List existing vector store collections from the persist directory.\"\"\"\n        from langflow.services.cache.utils import CACHE_DIR\n\n        # Get the base directory (either custom or cache)\n        base_dir = Path(self.persist_directory) if self.persist_directory else Path(CACHE_DIR)\n        # Get the vector_stores subdirectory\n        vector_stores_dir = base_dir / \"vector_stores\"\n        if not vector_stores_dir.exists():\n            return []\n\n        return [d.name for d in vector_stores_dir.iterdir() if d.is_dir()]\n\n    def update_build_config(self, build_config: dict, field_value: str, field_name: str | None = None) -> dict:\n        \"\"\"Update the build configuration when the mode changes.\"\"\"\n        if field_name == \"mode\":\n            # Hide all dynamic fields by default\n            dynamic_fields = [\n                \"ingest_data\",\n                \"search_query\",\n                \"search_type\",\n                \"number_of_results\",\n                \"existing_collections\",\n                \"collection_name\",\n                \"embedding\",\n                \"allow_duplicates\",\n                \"limit\",\n            ]\n            for field in dynamic_fields:\n                if field in build_config:\n                    build_config[field][\"show\"] = False\n\n            # Show/hide fields based on selected mode\n            if field_value == \"Ingest\":\n                if \"ingest_data\" in build_config:\n                    build_config[\"ingest_data\"][\"show\"] = True\n                if \"collection_name\" in build_config:\n                    build_config[\"collection_name\"][\"show\"] = True\n                    build_config[\"collection_name\"][\"display_name\"] = \"Name Your Collection\"\n                if \"persist\" in build_config:\n                    build_config[\"persist\"][\"show\"] = True\n                if \"persist_directory\" in build_config:\n                    build_config[\"persist_directory\"][\"show\"] = True\n                if \"embedding\" in build_config:\n                    build_config[\"embedding\"][\"show\"] = True\n                if \"allow_duplicates\" in build_config:\n                    build_config[\"allow_duplicates\"][\"show\"] = True\n                if \"limit\" in build_config:\n                    build_config[\"limit\"][\"show\"] = True\n            elif field_value == \"Retrieve\":\n                if \"persist\" in build_config:\n                    build_config[\"persist\"][\"show\"] = False\n                build_config[\"search_query\"][\"show\"] = True\n                build_config[\"search_type\"][\"show\"] = True\n                build_config[\"number_of_results\"][\"show\"] = True\n                build_config[\"embedding\"][\"show\"] = True\n                build_config[\"collection_name\"][\"show\"] = False\n                # Show existing collections dropdown and update its options\n                if \"existing_collections\" in build_config:\n                    build_config[\"existing_collections\"][\"show\"] = True\n                    build_config[\"existing_collections\"][\"options\"] = self.list_existing_collections()\n                # Hide collection_name in Retrieve mode since we use existing_collections\n        elif field_name == \"existing_collections\":\n            # Update collection_name when an existing collection is selected\n            if \"collection_name\" in build_config:\n                build_config[\"collection_name\"][\"value\"] = field_value\n\n        return build_config\n\n    @override\n    @check_cached_vector_store\n    def build_vector_store(self) -> Chroma:\n        \"\"\"Builds the Chroma object.\"\"\"\n        try:\n            from langchain_chroma import Chroma\n        except ImportError as e:\n            msg = \"Could not import Chroma integration package. Please install it with `pip install langchain-chroma`.\"\n            raise ImportError(msg) from e\n        # Chroma settings\n        # chroma_settings = None\n        if self.existing_collections:\n            self.collection_name = self.existing_collections\n\n        # Use user-provided directory or default cache directory\n        if self.persist_directory:\n            base_dir = self.resolve_path(self.persist_directory)\n            persist_directory = str(self.get_vector_store_directory(base_dir))\n            logger.debug(f\"Using custom persist directory: {persist_directory}\")\n        else:\n            persist_directory = self.get_default_persist_dir()\n            logger.debug(f\"Using default persist directory: {persist_directory}\")\n\n        chroma = Chroma(\n            persist_directory=persist_directory,\n            client=None,\n            embedding_function=self.embedding,\n            collection_name=self.collection_name,\n        )\n\n        self._add_documents_to_vector_store(chroma)\n        self.status = chroma_collection_to_data(chroma.get(limit=self.limit))\n        return chroma\n\n    def _add_documents_to_vector_store(self, vector_store: \"Chroma\") -> None:\n        \"\"\"Adds documents to the Vector Store.\"\"\"\n        ingest_data: list | Data | DataFrame = self.ingest_data\n        if not ingest_data:\n            self.status = \"\"\n            return\n\n        # Convert DataFrame to Data if needed using parent's method\n        ingest_data = self._prepare_ingest_data()\n\n        stored_documents_without_id = []\n        if self.allow_duplicates:\n            stored_data = []\n        else:\n            stored_data = chroma_collection_to_data(vector_store.get(limit=self.limit))\n            for value in deepcopy(stored_data):\n                del value.id\n                stored_documents_without_id.append(value)\n\n        documents = []\n        for _input in ingest_data or []:\n            if isinstance(_input, Data):\n                if _input not in stored_documents_without_id:\n                    documents.append(_input.to_lc_document())\n            else:\n                msg = \"Vector Store Inputs must be Data objects.\"\n                raise TypeError(msg)\n\n        if documents and self.embedding is not None:\n            self.log(f\"Adding {len(documents)} documents to the Vector Store.\")\n            vector_store.add_documents(documents)\n        else:\n            self.log(\"No documents to add to the Vector Store.\")\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "collection_name": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "collection_name",
        "value": "langflow",
        "display_name": "Collection Name",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "existing_collections": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [],
        "options_metadata": [],
        "combobox": true,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": false,
        "name": "existing_collections",
        "value": "",
        "display_name": "Existing Collections",
        "advanced": false,
        "dynamic": false,
        "info": "Select a previously created collection to search through its stored data.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "limit": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "limit",
        "value": "",
        "display_name": "Limit",
        "advanced": true,
        "dynamic": false,
        "info": "Limit the number of records to compare when Allow Duplicates is False.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "mode": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "Ingest",
          "Retrieve"
        ],
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "mode",
        "value": "Ingest",
        "display_name": "Mode",
        "advanced": false,
        "dynamic": false,
        "info": "Select the operation mode",
        "real_time_refresh": true,
        "title_case": false,
        "type": "tab",
        "_input_type": "TabInput"
      },
      "number_of_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "number_of_results",
        "value": 10,
        "display_name": "Number of Results",
        "advanced": true,
        "dynamic": false,
        "info": "Number of results to return.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "persist_directory": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "persist_directory",
        "value": "",
        "display_name": "Persist Directory",
        "advanced": true,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Custom base directory to save the vector store. Collections will be stored under '{directory}/vector_stores/{collection_name}'. If not specified, it will use your system's cache folder.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "search_query": {
        "tool_mode": true,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": false,
        "name": "search_query",
        "value": "",
        "display_name": "Search Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Enter text to search for similar content in the selected collection.",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "search_type": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "Similarity",
          "MMR"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_type",
        "value": "Similarity",
        "display_name": "Search Type",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      }
    },
    "description": "Local Vector Store with search capabilities",
    "icon": "database",
    "base_classes": [
      "DataFrame"
    ],
    "display_name": "Local DB",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "mode",
      "collection_name",
      "persist_directory",
      "existing_collections",
      "embedding",
      "allow_duplicates",
      "search_type",
      "ingest_data",
      "search_query",
      "number_of_results",
      "limit"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "pgvector": {
    "template": {
      "_type": "Component",
      "embedding": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "embedding",
        "value": "",
        "display_name": "Embedding",
        "advanced": false,
        "input_types": [
          "Embeddings"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "ingest_data": {
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "ingest_data",
        "value": "",
        "display_name": "Ingest Data",
        "advanced": false,
        "input_types": [
          "Data",
          "DataFrame"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain_community.vectorstores import PGVector\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.io import HandleInput, IntInput, SecretStrInput, StrInput\nfrom langflow.schema import Data\nfrom langflow.utils.connection_string_parser import transform_connection_string\n\n\nclass PGVectorStoreComponent(LCVectorStoreComponent):\n    display_name = \"PGVector\"\n    description = \"PGVector Vector Store with search capabilities\"\n    name = \"pgvector\"\n    icon = \"cpu\"\n\n    inputs = [\n        SecretStrInput(name=\"pg_server_url\", display_name=\"PostgreSQL Server Connection String\", required=True),\n        StrInput(name=\"collection_name\", display_name=\"Table\", required=True),\n        *LCVectorStoreComponent.inputs,\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"], required=True),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            value=4,\n            advanced=True,\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> PGVector:\n        # Convert DataFrame to Data if needed using parent's method\n        self.ingest_data = self._prepare_ingest_data()\n\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                documents.append(_input)\n\n        connection_string_parsed = transform_connection_string(self.pg_server_url)\n\n        if documents:\n            pgvector = PGVector.from_documents(\n                embedding=self.embedding,\n                documents=documents,\n                collection_name=self.collection_name,\n                connection_string=connection_string_parsed,\n            )\n        else:\n            pgvector = PGVector.from_existing_index(\n                embedding=self.embedding,\n                collection_name=self.collection_name,\n                connection_string=connection_string_parsed,\n            )\n\n        return pgvector\n\n    def search_documents(self) -> list[Data]:\n        vector_store = self.build_vector_store()\n\n        if self.search_query and isinstance(self.search_query, str) and self.search_query.strip():\n            docs = vector_store.similarity_search(\n                query=self.search_query,\n                k=self.number_of_results,\n            )\n\n            data = docs_to_data(docs)\n            self.status = data\n            return data\n        return []\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "collection_name": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "collection_name",
        "value": "",
        "display_name": "Table",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "number_of_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "number_of_results",
        "value": 4,
        "display_name": "Number of Results",
        "advanced": true,
        "dynamic": false,
        "info": "Number of results to return.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "pg_server_url": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "pg_server_url",
        "value": "",
        "display_name": "PostgreSQL Server Connection String",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "search_query": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "Enter a query...",
        "show": true,
        "name": "search_query",
        "value": "",
        "display_name": "Search Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Enter a query to run a similarity search.",
        "title_case": false,
        "type": "query",
        "_input_type": "QueryInput"
      },
      "should_cache_vector_store": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "should_cache_vector_store",
        "value": true,
        "display_name": "Cache Vector Store",
        "advanced": true,
        "dynamic": false,
        "info": "If True, the vector store will be cached for the current build of the component. This is useful for components that have multiple output methods and want to share the same vector store.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      }
    },
    "description": "PGVector Vector Store with search capabilities",
    "icon": "cpu",
    "base_classes": [
      "Data",
      "DataFrame"
    ],
    "display_name": "PGVector",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "search_results",
        "display_name": "Search Results",
        "method": "search_documents",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "collection_name",
          "embedding",
          "pg_server_url"
        ],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "pg_server_url",
      "collection_name",
      "ingest_data",
      "search_query",
      "should_cache_vector_store",
      "embedding",
      "number_of_results"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "Redis": {
    "template": {
      "_type": "Component",
      "embedding": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "embedding",
        "value": "",
        "display_name": "Embedding",
        "advanced": false,
        "input_types": [
          "Embeddings"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "ingest_data": {
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "ingest_data",
        "value": "",
        "display_name": "Ingest Data",
        "advanced": false,
        "input_types": [
          "Data",
          "DataFrame"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from pathlib import Path\n\nfrom langchain.text_splitter import CharacterTextSplitter\nfrom langchain_community.vectorstores.redis import Redis\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.io import HandleInput, IntInput, SecretStrInput, StrInput\nfrom langflow.schema import Data\n\n\nclass RedisVectorStoreComponent(LCVectorStoreComponent):\n    \"\"\"A custom component for implementing a Vector Store using Redis.\"\"\"\n\n    display_name: str = \"Redis\"\n    description: str = \"Implementation of Vector Store using Redis\"\n    name = \"Redis\"\n    icon = \"Redis\"\n\n    inputs = [\n        SecretStrInput(name=\"redis_server_url\", display_name=\"Redis Server Connection String\", required=True),\n        StrInput(\n            name=\"redis_index_name\",\n            display_name=\"Redis Index\",\n        ),\n        StrInput(name=\"code\", display_name=\"Code\", advanced=True),\n        StrInput(\n            name=\"schema\",\n            display_name=\"Schema\",\n        ),\n        *LCVectorStoreComponent.inputs,\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            value=4,\n            advanced=True,\n        ),\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> Redis:\n        # Convert DataFrame to Data if needed using parent's method\n        self.ingest_data = self._prepare_ingest_data()\n\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                documents.append(_input)\n        Path(\"docuemnts.txt\").write_text(str(documents), encoding=\"utf-8\")\n\n        if not documents:\n            if self.schema is None:\n                msg = \"If no documents are provided, a schema must be provided.\"\n                raise ValueError(msg)\n            redis_vs = Redis.from_existing_index(\n                embedding=self.embedding,\n                index_name=self.redis_index_name,\n                schema=self.schema,\n                key_prefix=None,\n                redis_url=self.redis_server_url,\n            )\n        else:\n            text_splitter = CharacterTextSplitter(chunk_size=1000, chunk_overlap=0)\n            docs = text_splitter.split_documents(documents)\n            redis_vs = Redis.from_documents(\n                documents=docs,\n                embedding=self.embedding,\n                redis_url=self.redis_server_url,\n                index_name=self.redis_index_name,\n            )\n        return redis_vs\n\n    def search_documents(self) -> list[Data]:\n        vector_store = self.build_vector_store()\n\n        if self.search_query and isinstance(self.search_query, str) and self.search_query.strip():\n            docs = vector_store.similarity_search(\n                query=self.search_query,\n                k=self.number_of_results,\n            )\n\n            data = docs_to_data(docs)\n            self.status = data\n            return data\n        return []\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "number_of_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "number_of_results",
        "value": 4,
        "display_name": "Number of Results",
        "advanced": true,
        "dynamic": false,
        "info": "Number of results to return.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "redis_index_name": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "redis_index_name",
        "value": "",
        "display_name": "Redis Index",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "redis_server_url": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "redis_server_url",
        "value": "",
        "display_name": "Redis Server Connection String",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "schema": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "schema",
        "value": "",
        "display_name": "Schema",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "search_query": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "Enter a query...",
        "show": true,
        "name": "search_query",
        "value": "",
        "display_name": "Search Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Enter a query to run a similarity search.",
        "title_case": false,
        "type": "query",
        "_input_type": "QueryInput"
      },
      "should_cache_vector_store": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "should_cache_vector_store",
        "value": true,
        "display_name": "Cache Vector Store",
        "advanced": true,
        "dynamic": false,
        "info": "If True, the vector store will be cached for the current build of the component. This is useful for components that have multiple output methods and want to share the same vector store.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      }
    },
    "description": "Implementation of Vector Store using Redis",
    "icon": "Redis",
    "base_classes": [
      "Data",
      "DataFrame"
    ],
    "display_name": "Redis",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "search_results",
        "display_name": "Search Results",
        "method": "search_documents",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "redis_server_url"
        ],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "redis_server_url",
      "redis_index_name",
      "code",
      "schema",
      "ingest_data",
      "search_query",
      "should_cache_vector_store",
      "number_of_results",
      "embedding"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "Vectara": {
    "template": {
      "_type": "Component",
      "embedding": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "embedding",
        "value": "",
        "display_name": "Embedding",
        "advanced": false,
        "input_types": [
          "Embeddings"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "ingest_data": {
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "ingest_data",
        "value": "",
        "display_name": "Ingest Data",
        "advanced": false,
        "input_types": [
          "Data",
          "DataFrame"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from typing import TYPE_CHECKING\n\nfrom langchain_community.vectorstores import Vectara\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.io import HandleInput, IntInput, SecretStrInput, StrInput\nfrom langflow.schema import Data, DataFrame\n\nif TYPE_CHECKING:\n    from langchain_community.vectorstores import Vectara\n\n\nclass VectaraVectorStoreComponent(LCVectorStoreComponent):\n    \"\"\"Vectara Vector Store with search capabilities.\"\"\"\n\n    display_name: str = \"Vectara\"\n    description: str = \"Vectara Vector Store with search capabilities\"\n    name = \"Vectara\"\n    icon = \"Vectara\"\n\n    inputs = [\n        StrInput(name=\"vectara_customer_id\", display_name=\"Vectara Customer ID\", required=True),\n        StrInput(name=\"vectara_corpus_id\", display_name=\"Vectara Corpus ID\", required=True),\n        SecretStrInput(name=\"vectara_api_key\", display_name=\"Vectara API Key\", required=True),\n        HandleInput(\n            name=\"embedding\",\n            display_name=\"Embedding\",\n            input_types=[\"Embeddings\"],\n        ),\n        *LCVectorStoreComponent.inputs,\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            value=4,\n            advanced=True,\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> \"Vectara\":\n        \"\"\"Builds the Vectara object.\"\"\"\n        try:\n            from langchain_community.vectorstores import Vectara\n        except ImportError as e:\n            msg = \"Could not import Vectara. Please install it with `pip install langchain-community`.\"\n            raise ImportError(msg) from e\n\n        vectara = Vectara(\n            vectara_customer_id=self.vectara_customer_id,\n            vectara_corpus_id=self.vectara_corpus_id,\n            vectara_api_key=self.vectara_api_key,\n        )\n\n        self._add_documents_to_vector_store(vectara)\n        return vectara\n\n    def _add_documents_to_vector_store(self, vector_store: \"Vectara\") -> None:\n        \"\"\"Adds documents to the Vector Store.\"\"\"\n        ingest_data: list | Data | DataFrame = self.ingest_data\n        if not ingest_data:\n            self.status = \"No documents to add to Vectara\"\n            return\n\n        # Convert DataFrame to Data if needed using parent's method\n        ingest_data = self._prepare_ingest_data()\n\n        documents = []\n        for _input in ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                documents.append(_input)\n\n        if documents:\n            self.log(f\"Adding {len(documents)} documents to Vectara.\")\n            vector_store.add_documents(documents)\n            self.status = f\"Added {len(documents)} documents to Vectara\"\n        else:\n            self.log(\"No documents to add to Vectara.\")\n            self.status = \"No valid documents to add to Vectara\"\n\n    def search_documents(self) -> list[Data]:\n        vector_store = self.build_vector_store()\n\n        if self.search_query and isinstance(self.search_query, str) and self.search_query.strip():\n            docs = vector_store.similarity_search(\n                query=self.search_query,\n                k=self.number_of_results,\n            )\n\n            data = docs_to_data(docs)\n            self.status = f\"Found {len(data)} results for the query: {self.search_query}\"\n            return data\n        self.status = \"No search query provided\"\n        return []\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "number_of_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "number_of_results",
        "value": 4,
        "display_name": "Number of Results",
        "advanced": true,
        "dynamic": false,
        "info": "Number of results to return.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "search_query": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "Enter a query...",
        "show": true,
        "name": "search_query",
        "value": "",
        "display_name": "Search Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Enter a query to run a similarity search.",
        "title_case": false,
        "type": "query",
        "_input_type": "QueryInput"
      },
      "should_cache_vector_store": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "should_cache_vector_store",
        "value": true,
        "display_name": "Cache Vector Store",
        "advanced": true,
        "dynamic": false,
        "info": "If True, the vector store will be cached for the current build of the component. This is useful for components that have multiple output methods and want to share the same vector store.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "vectara_api_key": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "vectara_api_key",
        "value": "",
        "display_name": "Vectara API Key",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "vectara_corpus_id": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "vectara_corpus_id",
        "value": "",
        "display_name": "Vectara Corpus ID",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "vectara_customer_id": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "vectara_customer_id",
        "value": "",
        "display_name": "Vectara Customer ID",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      }
    },
    "description": "Vectara Vector Store with search capabilities",
    "icon": "Vectara",
    "base_classes": [
      "Data",
      "DataFrame"
    ],
    "display_name": "Vectara",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "search_results",
        "display_name": "Search Results",
        "method": "search_documents",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "vectara_api_key",
          "vectara_corpus_id",
          "vectara_customer_id"
        ],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "vectara_customer_id",
      "vectara_corpus_id",
      "vectara_api_key",
      "embedding",
      "ingest_data",
      "search_query",
      "should_cache_vector_store",
      "number_of_results"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "Graph RAG": {
    "template": {
      "_type": "Component",
      "embedding_model": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "embedding_model",
        "value": "",
        "display_name": "Embedding Model",
        "advanced": false,
        "input_types": [
          "Embeddings"
        ],
        "dynamic": false,
        "info": "Specify the Embedding Model. Not required for Astra Vectorize collections.",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "vector_store": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "vector_store",
        "value": "",
        "display_name": "Vector Store Connection",
        "advanced": false,
        "input_types": [
          "VectorStore"
        ],
        "dynamic": false,
        "info": "Connection to Vector Store.",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "import inspect\nfrom abc import ABC\n\nimport graph_retriever.strategies as strategies_module\nfrom langchain_graph_retriever import GraphRetriever\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent\nfrom langflow.helpers import docs_to_data\nfrom langflow.inputs import DropdownInput, HandleInput, MultilineInput, NestedDictInput, StrInput\nfrom langflow.schema import Data\n\n\ndef traversal_strategies() -> list[str]:\n    \"\"\"Retrieves a list of class names from the strategies_module.\n\n    This function uses the `inspect` module to get all the class members\n    from the `strategies_module` and returns their names as a list of strings.\n\n    Returns:\n        list[str]: A list of strategy class names.\n    \"\"\"\n    classes = inspect.getmembers(strategies_module, inspect.isclass)\n    return [name for name, cls in classes if ABC not in cls.__bases__]\n\n\nclass GraphRAGComponent(LCVectorStoreComponent):\n    \"\"\"GraphRAGComponent is a component for performing Graph RAG traversal in a vector store.\n\n    Attributes:\n        display_name (str): The display name of the component.\n        description (str): A brief description of the component.\n        name (str): The name of the component.\n        icon (str): The icon representing the component.\n        inputs (list): A list of input configurations for the component.\n\n    Methods:\n        _build_search_args():\n            Builds the arguments required for the search operation.\n        search_documents() -> list[Data]:\n            Searches for documents using the specified strategy, edge definition, and query.\n        _edge_definition_from_input() -> tuple:\n            Processes the edge definition input and returns it as a tuple.\n    \"\"\"\n\n    display_name: str = \"Graph RAG\"\n    description: str = \"Graph RAG traversal for vector store.\"\n    name = \"Graph RAG\"\n    icon: str = \"AstraDB\"\n\n    inputs = [\n        HandleInput(\n            name=\"embedding_model\",\n            display_name=\"Embedding Model\",\n            input_types=[\"Embeddings\"],\n            info=\"Specify the Embedding Model. Not required for Astra Vectorize collections.\",\n            required=False,\n        ),\n        HandleInput(\n            name=\"vector_store\",\n            display_name=\"Vector Store Connection\",\n            input_types=[\"VectorStore\"],\n            info=\"Connection to Vector Store.\",\n        ),\n        StrInput(\n            name=\"edge_definition\",\n            display_name=\"Edge Definition\",\n            info=\"Edge definition for the graph traversal.\",\n        ),\n        DropdownInput(\n            name=\"strategy\",\n            display_name=\"Traversal Strategies\",\n            options=traversal_strategies(),\n        ),\n        MultilineInput(\n            name=\"search_query\",\n            display_name=\"Search Query\",\n            tool_mode=True,\n        ),\n        NestedDictInput(\n            name=\"graphrag_strategy_kwargs\",\n            display_name=\"Strategy Parameters\",\n            info=(\n                \"Optional dictionary of additional parameters for the retrieval strategy. \"\n                \"Please see https://datastax.github.io/graph-rag/reference/graph_retriever/strategies/ for details.\"\n            ),\n            advanced=True,\n        ),\n    ]\n\n    def search_documents(self) -> list[Data]:\n        \"\"\"Searches for documents using the graph retriever based on the selected strategy, edge definition, and query.\n\n        Returns:\n            list[Data]: A list of retrieved documents.\n\n        Raises:\n            AttributeError: If there is an issue with attribute access.\n            TypeError: If there is a type mismatch.\n            ValueError: If there is a value error.\n        \"\"\"\n        additional_params = self.graphrag_strategy_kwargs or {}\n\n        # Invoke the graph retriever based on the selected strategy, edge definition, and query\n        strategy_class = getattr(strategies_module, self.strategy)\n        retriever = GraphRetriever(\n            store=self.vector_store,\n            edges=[self._evaluate_edge_definition_input()],\n            strategy=strategy_class(**additional_params),\n        )\n\n        return docs_to_data(retriever.invoke(self.search_query))\n\n    def _edge_definition_from_input(self) -> tuple:\n        \"\"\"Generates the edge definition from the input data.\n\n        Returns:\n            tuple: A tuple representing the edge definition.\n        \"\"\"\n        values = self.edge_definition.split(\",\")\n        values = [value.strip() for value in values]\n\n        return tuple(values)\n\n    def _evaluate_edge_definition_input(self) -> tuple:\n        from graph_retriever.edges.metadata import Id\n\n        \"\"\"Evaluates the edge definition, converting any function calls from strings.\n\n        Args:\n            edge_definition (tuple): The edge definition to evaluate.\n\n        Returns:\n            tuple: The evaluated edge definition.\n        \"\"\"\n        evaluated_values = []\n        for value in self._edge_definition_from_input():\n            if value == \"Id()\":\n                evaluated_values.append(Id())  # Evaluate Id() as a function call\n            else:\n                evaluated_values.append(value)\n        return tuple(evaluated_values)\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "edge_definition": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "edge_definition",
        "value": "",
        "display_name": "Edge Definition",
        "advanced": false,
        "dynamic": false,
        "info": "Edge definition for the graph traversal.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "graphrag_strategy_kwargs": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "graphrag_strategy_kwargs",
        "value": {},
        "display_name": "Strategy Parameters",
        "advanced": true,
        "dynamic": false,
        "info": "Optional dictionary of additional parameters for the retrieval strategy. Please see https://datastax.github.io/graph-rag/reference/graph_retriever/strategies/ for details.",
        "title_case": false,
        "type": "NestedDict",
        "_input_type": "NestedDictInput"
      },
      "search_query": {
        "tool_mode": true,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_query",
        "value": "",
        "display_name": "Search Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "strategy": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "Eager",
          "Mmr",
          "NodeTracker",
          "Scored"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "strategy",
        "value": "",
        "display_name": "Traversal Strategies",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      }
    },
    "description": "Graph RAG traversal for vector store.",
    "icon": "AstraDB",
    "base_classes": [
      "Data",
      "DataFrame"
    ],
    "display_name": "Graph RAG",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "search_results",
        "display_name": "Search Results",
        "method": "search_documents",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "embedding_model",
      "vector_store",
      "edge_definition",
      "strategy",
      "search_query",
      "graphrag_strategy_kwargs"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "Weaviate": {
    "template": {
      "_type": "Component",
      "embedding": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "embedding",
        "value": "",
        "display_name": "Embedding",
        "advanced": false,
        "input_types": [
          "Embeddings"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "ingest_data": {
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "ingest_data",
        "value": "",
        "display_name": "Ingest Data",
        "advanced": false,
        "input_types": [
          "Data",
          "DataFrame"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "api_key": {
        "load_from_db": true,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "api_key",
        "value": "",
        "display_name": "API Key",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "import weaviate\nfrom langchain_community.vectorstores import Weaviate\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.io import BoolInput, HandleInput, IntInput, SecretStrInput, StrInput\nfrom langflow.schema import Data\n\n\nclass WeaviateVectorStoreComponent(LCVectorStoreComponent):\n    display_name = \"Weaviate\"\n    description = \"Weaviate Vector Store with search capabilities\"\n    name = \"Weaviate\"\n    icon = \"Weaviate\"\n\n    inputs = [\n        StrInput(name=\"url\", display_name=\"Weaviate URL\", value=\"http://localhost:8080\", required=True),\n        SecretStrInput(name=\"api_key\", display_name=\"API Key\", required=False),\n        StrInput(\n            name=\"index_name\",\n            display_name=\"Index Name\",\n            required=True,\n            info=\"Requires capitalized index name.\",\n        ),\n        StrInput(name=\"text_key\", display_name=\"Text Key\", value=\"text\", advanced=True),\n        *LCVectorStoreComponent.inputs,\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            value=4,\n            advanced=True,\n        ),\n        BoolInput(name=\"search_by_text\", display_name=\"Search By Text\", advanced=True),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> Weaviate:\n        if self.api_key:\n            auth_config = weaviate.AuthApiKey(api_key=self.api_key)\n            client = weaviate.Client(url=self.url, auth_client_secret=auth_config)\n        else:\n            client = weaviate.Client(url=self.url)\n\n        if self.index_name != self.index_name.capitalize():\n            msg = f\"Weaviate requires the index name to be capitalized. Use: {self.index_name.capitalize()}\"\n            raise ValueError(msg)\n\n        # Convert DataFrame to Data if needed using parent's method\n        self.ingest_data = self._prepare_ingest_data()\n\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                documents.append(_input)\n\n        if documents and self.embedding:\n            return Weaviate.from_documents(\n                client=client,\n                index_name=self.index_name,\n                documents=documents,\n                embedding=self.embedding,\n                by_text=self.search_by_text,\n            )\n\n        return Weaviate(\n            client=client,\n            index_name=self.index_name,\n            text_key=self.text_key,\n            embedding=self.embedding,\n            by_text=self.search_by_text,\n        )\n\n    def search_documents(self) -> list[Data]:\n        vector_store = self.build_vector_store()\n\n        if self.search_query and isinstance(self.search_query, str) and self.search_query.strip():\n            docs = vector_store.similarity_search(\n                query=self.search_query,\n                k=self.number_of_results,\n            )\n\n            data = docs_to_data(docs)\n            self.status = data\n            return data\n        return []\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "index_name": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "index_name",
        "value": "",
        "display_name": "Index Name",
        "advanced": false,
        "dynamic": false,
        "info": "Requires capitalized index name.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "number_of_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "number_of_results",
        "value": 4,
        "display_name": "Number of Results",
        "advanced": true,
        "dynamic": false,
        "info": "Number of results to return.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "search_by_text": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_by_text",
        "value": false,
        "display_name": "Search By Text",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "search_query": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "Enter a query...",
        "show": true,
        "name": "search_query",
        "value": "",
        "display_name": "Search Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Enter a query to run a similarity search.",
        "title_case": false,
        "type": "query",
        "_input_type": "QueryInput"
      },
      "should_cache_vector_store": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "should_cache_vector_store",
        "value": true,
        "display_name": "Cache Vector Store",
        "advanced": true,
        "dynamic": false,
        "info": "If True, the vector store will be cached for the current build of the component. This is useful for components that have multiple output methods and want to share the same vector store.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "text_key": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "text_key",
        "value": "text",
        "display_name": "Text Key",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "url": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "url",
        "value": "http://localhost:8080",
        "display_name": "Weaviate URL",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      }
    },
    "description": "Weaviate Vector Store with search capabilities",
    "icon": "Weaviate",
    "base_classes": [
      "Data",
      "DataFrame"
    ],
    "display_name": "Weaviate",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "search_results",
        "display_name": "Search Results",
        "method": "search_documents",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "index_name",
          "url"
        ],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "url",
      "api_key",
      "index_name",
      "text_key",
      "ingest_data",
      "search_query",
      "should_cache_vector_store",
      "embedding",
      "number_of_results",
      "search_by_text"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "AstraDBGraph": {
    "template": {
      "_type": "Component",
      "embedding_model": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "embedding_model",
        "value": "",
        "display_name": "Embedding Model",
        "advanced": false,
        "input_types": [
          "Embeddings"
        ],
        "dynamic": false,
        "info": "Allows an embedding model configuration.",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "ingest_data": {
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "ingest_data",
        "value": "",
        "display_name": "Ingest Data",
        "advanced": false,
        "input_types": [
          "Data",
          "DataFrame"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "api_endpoint": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "api_endpoint",
        "value": "ASTRA_DB_API_ENDPOINT",
        "display_name": "API Endpoint",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "API endpoint URL for the Astra DB service.",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "batch_size": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "batch_size",
        "value": "",
        "display_name": "Batch Size",
        "advanced": true,
        "dynamic": false,
        "info": "Optional number of data to process in a single batch.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "bulk_delete_concurrency": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "bulk_delete_concurrency",
        "value": "",
        "display_name": "Bulk Delete Concurrency",
        "advanced": true,
        "dynamic": false,
        "info": "Optional concurrency level for bulk delete operations.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "bulk_insert_batch_concurrency": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "bulk_insert_batch_concurrency",
        "value": "",
        "display_name": "Bulk Insert Batch Concurrency",
        "advanced": true,
        "dynamic": false,
        "info": "Optional concurrency level for bulk insert operations.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "bulk_insert_overwrite_concurrency": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "bulk_insert_overwrite_concurrency",
        "value": "",
        "display_name": "Bulk Insert Overwrite Concurrency",
        "advanced": true,
        "dynamic": false,
        "info": "Optional concurrency level for bulk insert operations that overwrite existing data.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "import os\n\nimport orjson\nfrom astrapy.admin import parse_api_endpoint\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers import docs_to_data\nfrom langflow.inputs import (\n    BoolInput,\n    DictInput,\n    DropdownInput,\n    FloatInput,\n    HandleInput,\n    IntInput,\n    SecretStrInput,\n    StrInput,\n)\nfrom langflow.schema import Data\n\n\nclass AstraDBGraphVectorStoreComponent(LCVectorStoreComponent):\n    display_name: str = \"Astra DB Graph\"\n    description: str = \"Implementation of Graph Vector Store using Astra DB\"\n    name = \"AstraDBGraph\"\n    icon: str = \"AstraDB\"\n\n    inputs = [\n        SecretStrInput(\n            name=\"token\",\n            display_name=\"Astra DB Application Token\",\n            info=\"Authentication token for accessing Astra DB.\",\n            value=\"ASTRA_DB_APPLICATION_TOKEN\",\n            required=True,\n            advanced=os.getenv(\"ASTRA_ENHANCED\", \"false\").lower() == \"true\",\n        ),\n        SecretStrInput(\n            name=\"api_endpoint\",\n            display_name=\"Database\" if os.getenv(\"ASTRA_ENHANCED\", \"false\").lower() == \"true\" else \"API Endpoint\",\n            info=\"API endpoint URL for the Astra DB service.\",\n            value=\"ASTRA_DB_API_ENDPOINT\",\n            required=True,\n        ),\n        StrInput(\n            name=\"collection_name\",\n            display_name=\"Collection Name\",\n            info=\"The name of the collection within Astra DB where the vectors will be stored.\",\n            required=True,\n        ),\n        StrInput(\n            name=\"metadata_incoming_links_key\",\n            display_name=\"Metadata incoming links key\",\n            info=\"Metadata key used for incoming links.\",\n            advanced=True,\n        ),\n        *LCVectorStoreComponent.inputs,\n        StrInput(\n            name=\"keyspace\",\n            display_name=\"Keyspace\",\n            info=\"Optional keyspace within Astra DB to use for the collection.\",\n            advanced=True,\n        ),\n        HandleInput(\n            name=\"embedding_model\",\n            display_name=\"Embedding Model\",\n            input_types=[\"Embeddings\"],\n            info=\"Allows an embedding model configuration.\",\n        ),\n        DropdownInput(\n            name=\"metric\",\n            display_name=\"Metric\",\n            info=\"Optional distance metric for vector comparisons in the vector store.\",\n            options=[\"cosine\", \"dot_product\", \"euclidean\"],\n            value=\"cosine\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"batch_size\",\n            display_name=\"Batch Size\",\n            info=\"Optional number of data to process in a single batch.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"bulk_insert_batch_concurrency\",\n            display_name=\"Bulk Insert Batch Concurrency\",\n            info=\"Optional concurrency level for bulk insert operations.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"bulk_insert_overwrite_concurrency\",\n            display_name=\"Bulk Insert Overwrite Concurrency\",\n            info=\"Optional concurrency level for bulk insert operations that overwrite existing data.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"bulk_delete_concurrency\",\n            display_name=\"Bulk Delete Concurrency\",\n            info=\"Optional concurrency level for bulk delete operations.\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"setup_mode\",\n            display_name=\"Setup Mode\",\n            info=\"Configuration mode for setting up the vector store, with options like 'Sync', or 'Off'.\",\n            options=[\"Sync\", \"Off\"],\n            advanced=True,\n            value=\"Sync\",\n        ),\n        BoolInput(\n            name=\"pre_delete_collection\",\n            display_name=\"Pre Delete Collection\",\n            info=\"Boolean flag to determine whether to delete the collection before creating a new one.\",\n            advanced=True,\n            value=False,\n        ),\n        StrInput(\n            name=\"metadata_indexing_include\",\n            display_name=\"Metadata Indexing Include\",\n            info=\"Optional list of metadata fields to include in the indexing.\",\n            advanced=True,\n            list=True,\n        ),\n        StrInput(\n            name=\"metadata_indexing_exclude\",\n            display_name=\"Metadata Indexing Exclude\",\n            info=\"Optional list of metadata fields to exclude from the indexing.\",\n            advanced=True,\n            list=True,\n        ),\n        StrInput(\n            name=\"collection_indexing_policy\",\n            display_name=\"Collection Indexing Policy\",\n            info='Optional JSON string for the \"indexing\" field of the collection. '\n            \"See https://docs.datastax.com/en/astra-db-serverless/api-reference/collections.html#the-indexing-option\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            advanced=True,\n            value=4,\n        ),\n        DropdownInput(\n            name=\"search_type\",\n            display_name=\"Search Type\",\n            info=\"Search type to use\",\n            options=[\n                \"Similarity\",\n                \"Similarity with score threshold\",\n                \"MMR (Max Marginal Relevance)\",\n                \"Graph Traversal\",\n                \"MMR (Max Marginal Relevance) Graph Traversal\",\n            ],\n            value=\"MMR (Max Marginal Relevance) Graph Traversal\",\n            advanced=True,\n        ),\n        FloatInput(\n            name=\"search_score_threshold\",\n            display_name=\"Search Score Threshold\",\n            info=\"Minimum similarity score threshold for search results. \"\n            \"(when using 'Similarity with score threshold')\",\n            value=0,\n            advanced=True,\n        ),\n        DictInput(\n            name=\"search_filter\",\n            display_name=\"Search Metadata Filter\",\n            info=\"Optional dictionary of filters to apply to the search query.\",\n            advanced=True,\n            is_list=True,\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self):\n        try:\n            from langchain_astradb import AstraDBGraphVectorStore\n            from langchain_astradb.utils.astradb import SetupMode\n        except ImportError as e:\n            msg = (\n                \"Could not import langchain Astra DB integration package. \"\n                \"Please install it with `pip install langchain-astradb`.\"\n            )\n            raise ImportError(msg) from e\n\n        try:\n            if not self.setup_mode:\n                self.setup_mode = self._inputs[\"setup_mode\"].options[0]\n\n            setup_mode_value = SetupMode[self.setup_mode.upper()]\n        except KeyError as e:\n            msg = f\"Invalid setup mode: {self.setup_mode}\"\n            raise ValueError(msg) from e\n\n        try:\n            self.log(f\"Initializing Graph Vector Store {self.collection_name}\")\n\n            vector_store = AstraDBGraphVectorStore(\n                embedding=self.embedding_model,\n                collection_name=self.collection_name,\n                metadata_incoming_links_key=self.metadata_incoming_links_key or \"incoming_links\",\n                token=self.token,\n                api_endpoint=self.api_endpoint,\n                namespace=self.keyspace or None,\n                environment=parse_api_endpoint(self.api_endpoint).environment if self.api_endpoint else None,\n                metric=self.metric or None,\n                batch_size=self.batch_size or None,\n                bulk_insert_batch_concurrency=self.bulk_insert_batch_concurrency or None,\n                bulk_insert_overwrite_concurrency=self.bulk_insert_overwrite_concurrency or None,\n                bulk_delete_concurrency=self.bulk_delete_concurrency or None,\n                setup_mode=setup_mode_value,\n                pre_delete_collection=self.pre_delete_collection,\n                metadata_indexing_include=[s for s in self.metadata_indexing_include if s] or None,\n                metadata_indexing_exclude=[s for s in self.metadata_indexing_exclude if s] or None,\n                collection_indexing_policy=orjson.loads(self.collection_indexing_policy.encode(\"utf-8\"))\n                if self.collection_indexing_policy\n                else None,\n            )\n        except Exception as e:\n            msg = f\"Error initializing AstraDBGraphVectorStore: {e}\"\n            raise ValueError(msg) from e\n\n        self.log(f\"Vector Store initialized: {vector_store.astra_env.collection_name}\")\n        self._add_documents_to_vector_store(vector_store)\n\n        return vector_store\n\n    def _add_documents_to_vector_store(self, vector_store) -> None:\n        self.ingest_data = self._prepare_ingest_data()\n\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                msg = \"Vector Store Inputs must be Data objects.\"\n                raise TypeError(msg)\n\n        if documents:\n            self.log(f\"Adding {len(documents)} documents to the Vector Store.\")\n            try:\n                vector_store.add_documents(documents)\n            except Exception as e:\n                msg = f\"Error adding documents to AstraDBGraphVectorStore: {e}\"\n                raise ValueError(msg) from e\n        else:\n            self.log(\"No documents to add to the Vector Store.\")\n\n    def _map_search_type(self) -> str:\n        match self.search_type:\n            case \"Similarity\":\n                return \"similarity\"\n            case \"Similarity with score threshold\":\n                return \"similarity_score_threshold\"\n            case \"MMR (Max Marginal Relevance)\":\n                return \"mmr\"\n            case \"Graph Traversal\":\n                return \"traversal\"\n            case \"MMR (Max Marginal Relevance) Graph Traversal\":\n                return \"mmr_traversal\"\n            case _:\n                return \"similarity\"\n\n    def _build_search_args(self):\n        args = {\n            \"k\": self.number_of_results,\n            \"score_threshold\": self.search_score_threshold,\n        }\n\n        if self.search_filter:\n            clean_filter = {k: v for k, v in self.search_filter.items() if k and v}\n            if len(clean_filter) > 0:\n                args[\"filter\"] = clean_filter\n        return args\n\n    def search_documents(self, vector_store=None) -> list[Data]:\n        if not vector_store:\n            vector_store = self.build_vector_store()\n\n        self.log(\"Searching for documents in AstraDBGraphVectorStore.\")\n        self.log(f\"Search query: {self.search_query}\")\n        self.log(f\"Search type: {self.search_type}\")\n        self.log(f\"Number of results: {self.number_of_results}\")\n\n        if self.search_query and isinstance(self.search_query, str) and self.search_query.strip():\n            try:\n                search_type = self._map_search_type()\n                search_args = self._build_search_args()\n\n                docs = vector_store.search(query=self.search_query, search_type=search_type, **search_args)\n\n                # Drop links from the metadata. At this point the links don't add any value for building the\n                # context and haven't been restored to json which causes the conversion to fail.\n                self.log(\"Removing links from metadata.\")\n                for doc in docs:\n                    if \"links\" in doc.metadata:\n                        doc.metadata.pop(\"links\")\n\n            except Exception as e:\n                msg = f\"Error performing search in AstraDBGraphVectorStore: {e}\"\n                raise ValueError(msg) from e\n\n            self.log(f\"Retrieved documents: {len(docs)}\")\n\n            data = docs_to_data(docs)\n\n            self.log(f\"Converted documents to data: {len(data)}\")\n\n            self.status = data\n            return data\n        self.log(\"No search input provided. Skipping search.\")\n        return []\n\n    def get_retriever_kwargs(self):\n        search_args = self._build_search_args()\n        return {\n            \"search_type\": self._map_search_type(),\n            \"search_kwargs\": search_args,\n        }\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "collection_indexing_policy": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "collection_indexing_policy",
        "value": "",
        "display_name": "Collection Indexing Policy",
        "advanced": true,
        "dynamic": false,
        "info": "Optional JSON string for the \"indexing\" field of the collection. See https://docs.datastax.com/en/astra-db-serverless/api-reference/collections.html#the-indexing-option",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "collection_name": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "collection_name",
        "value": "",
        "display_name": "Collection Name",
        "advanced": false,
        "dynamic": false,
        "info": "The name of the collection within Astra DB where the vectors will be stored.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "keyspace": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "keyspace",
        "value": "",
        "display_name": "Keyspace",
        "advanced": true,
        "dynamic": false,
        "info": "Optional keyspace within Astra DB to use for the collection.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "metadata_incoming_links_key": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "metadata_incoming_links_key",
        "value": "",
        "display_name": "Metadata incoming links key",
        "advanced": true,
        "dynamic": false,
        "info": "Metadata key used for incoming links.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "metadata_indexing_exclude": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "metadata_indexing_exclude",
        "value": "",
        "display_name": "Metadata Indexing Exclude",
        "advanced": true,
        "dynamic": false,
        "info": "Optional list of metadata fields to exclude from the indexing.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "metadata_indexing_include": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "metadata_indexing_include",
        "value": "",
        "display_name": "Metadata Indexing Include",
        "advanced": true,
        "dynamic": false,
        "info": "Optional list of metadata fields to include in the indexing.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "metric": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "cosine",
          "dot_product",
          "euclidean"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "metric",
        "value": "cosine",
        "display_name": "Metric",
        "advanced": true,
        "dynamic": false,
        "info": "Optional distance metric for vector comparisons in the vector store.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "number_of_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "number_of_results",
        "value": 4,
        "display_name": "Number of Results",
        "advanced": true,
        "dynamic": false,
        "info": "Number of results to return.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "pre_delete_collection": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "pre_delete_collection",
        "value": false,
        "display_name": "Pre Delete Collection",
        "advanced": true,
        "dynamic": false,
        "info": "Boolean flag to determine whether to delete the collection before creating a new one.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "search_filter": {
        "tool_mode": false,
        "trace_as_input": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_filter",
        "value": {},
        "display_name": "Search Metadata Filter",
        "advanced": true,
        "dynamic": false,
        "info": "Optional dictionary of filters to apply to the search query.",
        "title_case": false,
        "type": "dict",
        "_input_type": "DictInput"
      },
      "search_query": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "Enter a query...",
        "show": true,
        "name": "search_query",
        "value": "",
        "display_name": "Search Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Enter a query to run a similarity search.",
        "title_case": false,
        "type": "query",
        "_input_type": "QueryInput"
      },
      "search_score_threshold": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_score_threshold",
        "value": 0,
        "display_name": "Search Score Threshold",
        "advanced": true,
        "dynamic": false,
        "info": "Minimum similarity score threshold for search results. (when using 'Similarity with score threshold')",
        "title_case": false,
        "type": "float",
        "_input_type": "FloatInput"
      },
      "search_type": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "Similarity",
          "Similarity with score threshold",
          "MMR (Max Marginal Relevance)",
          "Graph Traversal",
          "MMR (Max Marginal Relevance) Graph Traversal"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_type",
        "value": "MMR (Max Marginal Relevance) Graph Traversal",
        "display_name": "Search Type",
        "advanced": true,
        "dynamic": false,
        "info": "Search type to use",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "setup_mode": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "Sync",
          "Off"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "setup_mode",
        "value": "Sync",
        "display_name": "Setup Mode",
        "advanced": true,
        "dynamic": false,
        "info": "Configuration mode for setting up the vector store, with options like 'Sync', or 'Off'.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "should_cache_vector_store": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "should_cache_vector_store",
        "value": true,
        "display_name": "Cache Vector Store",
        "advanced": true,
        "dynamic": false,
        "info": "If True, the vector store will be cached for the current build of the component. This is useful for components that have multiple output methods and want to share the same vector store.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "token": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "token",
        "value": "ASTRA_DB_APPLICATION_TOKEN",
        "display_name": "Astra DB Application Token",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "Authentication token for accessing Astra DB.",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      }
    },
    "description": "Implementation of Graph Vector Store using Astra DB",
    "icon": "AstraDB",
    "base_classes": [
      "Data",
      "DataFrame"
    ],
    "display_name": "Astra DB Graph",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "search_results",
        "display_name": "Search Results",
        "method": "search_documents",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "api_endpoint",
          "collection_name",
          "token"
        ],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "token",
      "api_endpoint",
      "collection_name",
      "metadata_incoming_links_key",
      "ingest_data",
      "search_query",
      "should_cache_vector_store",
      "keyspace",
      "embedding_model",
      "metric",
      "batch_size",
      "bulk_insert_batch_concurrency",
      "bulk_insert_overwrite_concurrency",
      "bulk_delete_concurrency",
      "setup_mode",
      "pre_delete_collection",
      "metadata_indexing_include",
      "metadata_indexing_exclude",
      "collection_indexing_policy",
      "number_of_results",
      "search_type",
      "search_score_threshold",
      "search_filter"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "HCD": {
    "template": {
      "_type": "Component",
      "embedding": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "embedding",
        "value": "",
        "display_name": "Embedding or Astra Vectorize",
        "advanced": false,
        "input_types": [
          "Embeddings",
          "dict"
        ],
        "dynamic": false,
        "info": "Allows either an embedding model or an Astra Vectorize configuration.",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "ingest_data": {
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "ingest_data",
        "value": "",
        "display_name": "Ingest Data",
        "advanced": false,
        "input_types": [
          "Data",
          "DataFrame"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "api_endpoint": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "api_endpoint",
        "value": "HCD_API_ENDPOINT",
        "display_name": "HCD API Endpoint",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "API endpoint URL for the HCD service.",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "batch_size": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "batch_size",
        "value": "",
        "display_name": "Batch Size",
        "advanced": true,
        "dynamic": false,
        "info": "Optional number of data to process in a single batch.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "bulk_delete_concurrency": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "bulk_delete_concurrency",
        "value": "",
        "display_name": "Bulk Delete Concurrency",
        "advanced": true,
        "dynamic": false,
        "info": "Optional concurrency level for bulk delete operations.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "bulk_insert_batch_concurrency": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "bulk_insert_batch_concurrency",
        "value": "",
        "display_name": "Bulk Insert Batch Concurrency",
        "advanced": true,
        "dynamic": false,
        "info": "Optional concurrency level for bulk insert operations.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "bulk_insert_overwrite_concurrency": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "bulk_insert_overwrite_concurrency",
        "value": "",
        "display_name": "Bulk Insert Overwrite Concurrency",
        "advanced": true,
        "dynamic": false,
        "info": "Optional concurrency level for bulk insert operations that overwrite existing data.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "ca_certificate": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "ca_certificate",
        "value": "",
        "display_name": "CA Certificate",
        "advanced": true,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Optional CA certificate for TLS connections to HCD.",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers import docs_to_data\nfrom langflow.inputs import DictInput, FloatInput\nfrom langflow.io import (\n    BoolInput,\n    DropdownInput,\n    HandleInput,\n    IntInput,\n    MultilineInput,\n    SecretStrInput,\n    StrInput,\n)\nfrom langflow.schema import Data\n\n\nclass HCDVectorStoreComponent(LCVectorStoreComponent):\n    display_name: str = \"Hyper-Converged Database\"\n    description: str = \"Implementation of Vector Store using Hyper-Converged Database (HCD) with search capabilities\"\n    name = \"HCD\"\n    icon: str = \"HCD\"\n\n    inputs = [\n        StrInput(\n            name=\"collection_name\",\n            display_name=\"Collection Name\",\n            info=\"The name of the collection within HCD where the vectors will be stored.\",\n            required=True,\n        ),\n        StrInput(\n            name=\"username\",\n            display_name=\"HCD Username\",\n            info=\"Authentication username for accessing HCD.\",\n            value=\"hcd-superuser\",\n            required=True,\n        ),\n        SecretStrInput(\n            name=\"password\",\n            display_name=\"HCD Password\",\n            info=\"Authentication password for accessing HCD.\",\n            value=\"HCD_PASSWORD\",\n            required=True,\n        ),\n        SecretStrInput(\n            name=\"api_endpoint\",\n            display_name=\"HCD API Endpoint\",\n            info=\"API endpoint URL for the HCD service.\",\n            value=\"HCD_API_ENDPOINT\",\n            required=True,\n        ),\n        *LCVectorStoreComponent.inputs,\n        StrInput(\n            name=\"namespace\",\n            display_name=\"Namespace\",\n            info=\"Optional namespace within HCD to use for the collection.\",\n            value=\"default_namespace\",\n            advanced=True,\n        ),\n        MultilineInput(\n            name=\"ca_certificate\",\n            display_name=\"CA Certificate\",\n            info=\"Optional CA certificate for TLS connections to HCD.\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"metric\",\n            display_name=\"Metric\",\n            info=\"Optional distance metric for vector comparisons in the vector store.\",\n            options=[\"cosine\", \"dot_product\", \"euclidean\"],\n            advanced=True,\n        ),\n        IntInput(\n            name=\"batch_size\",\n            display_name=\"Batch Size\",\n            info=\"Optional number of data to process in a single batch.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"bulk_insert_batch_concurrency\",\n            display_name=\"Bulk Insert Batch Concurrency\",\n            info=\"Optional concurrency level for bulk insert operations.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"bulk_insert_overwrite_concurrency\",\n            display_name=\"Bulk Insert Overwrite Concurrency\",\n            info=\"Optional concurrency level for bulk insert operations that overwrite existing data.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"bulk_delete_concurrency\",\n            display_name=\"Bulk Delete Concurrency\",\n            info=\"Optional concurrency level for bulk delete operations.\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"setup_mode\",\n            display_name=\"Setup Mode\",\n            info=\"Configuration mode for setting up the vector store, with options like 'Sync', 'Async', or 'Off'.\",\n            options=[\"Sync\", \"Async\", \"Off\"],\n            advanced=True,\n            value=\"Sync\",\n        ),\n        BoolInput(\n            name=\"pre_delete_collection\",\n            display_name=\"Pre Delete Collection\",\n            info=\"Boolean flag to determine whether to delete the collection before creating a new one.\",\n            advanced=True,\n        ),\n        StrInput(\n            name=\"metadata_indexing_include\",\n            display_name=\"Metadata Indexing Include\",\n            info=\"Optional list of metadata fields to include in the indexing.\",\n            advanced=True,\n        ),\n        HandleInput(\n            name=\"embedding\",\n            display_name=\"Embedding or Astra Vectorize\",\n            input_types=[\"Embeddings\", \"dict\"],\n            # TODO: This should be optional, but need to refactor langchain-astradb first.\n            info=\"Allows either an embedding model or an Astra Vectorize configuration.\",\n        ),\n        StrInput(\n            name=\"metadata_indexing_exclude\",\n            display_name=\"Metadata Indexing Exclude\",\n            info=\"Optional list of metadata fields to exclude from the indexing.\",\n            advanced=True,\n        ),\n        StrInput(\n            name=\"collection_indexing_policy\",\n            display_name=\"Collection Indexing Policy\",\n            info=\"Optional dictionary defining the indexing policy for the collection.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            advanced=True,\n            value=4,\n        ),\n        DropdownInput(\n            name=\"search_type\",\n            display_name=\"Search Type\",\n            info=\"Search type to use\",\n            options=[\"Similarity\", \"Similarity with score threshold\", \"MMR (Max Marginal Relevance)\"],\n            value=\"Similarity\",\n            advanced=True,\n        ),\n        FloatInput(\n            name=\"search_score_threshold\",\n            display_name=\"Search Score Threshold\",\n            info=\"Minimum similarity score threshold for search results. \"\n            \"(when using 'Similarity with score threshold')\",\n            value=0,\n            advanced=True,\n        ),\n        DictInput(\n            name=\"search_filter\",\n            display_name=\"Search Metadata Filter\",\n            info=\"Optional dictionary of filters to apply to the search query.\",\n            advanced=True,\n            is_list=True,\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self):\n        try:\n            from langchain_astradb import AstraDBVectorStore\n            from langchain_astradb.utils.astradb import SetupMode\n        except ImportError as e:\n            msg = (\n                \"Could not import langchain Astra DB integration package. \"\n                \"Please install it with `pip install langchain-astradb`.\"\n            )\n            raise ImportError(msg) from e\n\n        try:\n            from astrapy.authentication import UsernamePasswordTokenProvider\n            from astrapy.constants import Environment\n        except ImportError as e:\n            msg = \"Could not import astrapy integration package. Please install it with `pip install astrapy`.\"\n            raise ImportError(msg) from e\n\n        try:\n            if not self.setup_mode:\n                self.setup_mode = self._inputs[\"setup_mode\"].options[0]\n\n            setup_mode_value = SetupMode[self.setup_mode.upper()]\n        except KeyError as e:\n            msg = f\"Invalid setup mode: {self.setup_mode}\"\n            raise ValueError(msg) from e\n\n        if not isinstance(self.embedding, dict):\n            embedding_dict = {\"embedding\": self.embedding}\n        else:\n            from astrapy.info import VectorServiceOptions\n\n            dict_options = self.embedding.get(\"collection_vector_service_options\", {})\n            dict_options[\"authentication\"] = {\n                k: v for k, v in dict_options.get(\"authentication\", {}).items() if k and v\n            }\n            dict_options[\"parameters\"] = {k: v for k, v in dict_options.get(\"parameters\", {}).items() if k and v}\n            embedding_dict = {\"collection_vector_service_options\": VectorServiceOptions.from_dict(dict_options)}\n            collection_embedding_api_key = self.embedding.get(\"collection_embedding_api_key\")\n            if collection_embedding_api_key:\n                embedding_dict[\"collection_embedding_api_key\"] = collection_embedding_api_key\n\n        token_provider = UsernamePasswordTokenProvider(self.username, self.password)\n        vector_store_kwargs = {\n            **embedding_dict,\n            \"collection_name\": self.collection_name,\n            \"token\": token_provider,\n            \"api_endpoint\": self.api_endpoint,\n            \"namespace\": self.namespace,\n            \"metric\": self.metric or None,\n            \"batch_size\": self.batch_size or None,\n            \"bulk_insert_batch_concurrency\": self.bulk_insert_batch_concurrency or None,\n            \"bulk_insert_overwrite_concurrency\": self.bulk_insert_overwrite_concurrency or None,\n            \"bulk_delete_concurrency\": self.bulk_delete_concurrency or None,\n            \"setup_mode\": setup_mode_value,\n            \"pre_delete_collection\": self.pre_delete_collection or False,\n            \"environment\": Environment.HCD,\n        }\n\n        if self.metadata_indexing_include:\n            vector_store_kwargs[\"metadata_indexing_include\"] = self.metadata_indexing_include\n        elif self.metadata_indexing_exclude:\n            vector_store_kwargs[\"metadata_indexing_exclude\"] = self.metadata_indexing_exclude\n        elif self.collection_indexing_policy:\n            vector_store_kwargs[\"collection_indexing_policy\"] = self.collection_indexing_policy\n\n        try:\n            vector_store = AstraDBVectorStore(**vector_store_kwargs)\n        except Exception as e:\n            msg = f\"Error initializing AstraDBVectorStore: {e}\"\n            raise ValueError(msg) from e\n\n        self._add_documents_to_vector_store(vector_store)\n        return vector_store\n\n    def _add_documents_to_vector_store(self, vector_store) -> None:\n        # Convert DataFrame to Data if needed using parent's method\n        self.ingest_data = self._prepare_ingest_data()\n\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                msg = \"Vector Store Inputs must be Data objects.\"\n                raise TypeError(msg)\n\n        if documents:\n            self.log(f\"Adding {len(documents)} documents to the Vector Store.\")\n            try:\n                vector_store.add_documents(documents)\n            except Exception as e:\n                msg = f\"Error adding documents to AstraDBVectorStore: {e}\"\n                raise ValueError(msg) from e\n        else:\n            self.log(\"No documents to add to the Vector Store.\")\n\n    def _map_search_type(self) -> str:\n        if self.search_type == \"Similarity with score threshold\":\n            return \"similarity_score_threshold\"\n        if self.search_type == \"MMR (Max Marginal Relevance)\":\n            return \"mmr\"\n        return \"similarity\"\n\n    def _build_search_args(self):\n        args = {\n            \"k\": self.number_of_results,\n            \"score_threshold\": self.search_score_threshold,\n        }\n\n        if self.search_filter:\n            clean_filter = {k: v for k, v in self.search_filter.items() if k and v}\n            if len(clean_filter) > 0:\n                args[\"filter\"] = clean_filter\n        return args\n\n    def search_documents(self) -> list[Data]:\n        vector_store = self.build_vector_store()\n\n        self.log(f\"Search query: {self.search_query}\")\n        self.log(f\"Search type: {self.search_type}\")\n        self.log(f\"Number of results: {self.number_of_results}\")\n\n        if self.search_query and isinstance(self.search_query, str) and self.search_query.strip():\n            try:\n                search_type = self._map_search_type()\n                search_args = self._build_search_args()\n\n                docs = vector_store.search(query=self.search_query, search_type=search_type, **search_args)\n            except Exception as e:\n                msg = f\"Error performing search in AstraDBVectorStore: {e}\"\n                raise ValueError(msg) from e\n\n            self.log(f\"Retrieved documents: {len(docs)}\")\n\n            data = docs_to_data(docs)\n            self.log(f\"Converted documents to data: {len(data)}\")\n            self.status = data\n            return data\n        self.log(\"No search input provided. Skipping search.\")\n        return []\n\n    def get_retriever_kwargs(self):\n        search_args = self._build_search_args()\n        return {\n            \"search_type\": self._map_search_type(),\n            \"search_kwargs\": search_args,\n        }\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "collection_indexing_policy": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "collection_indexing_policy",
        "value": "",
        "display_name": "Collection Indexing Policy",
        "advanced": true,
        "dynamic": false,
        "info": "Optional dictionary defining the indexing policy for the collection.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "collection_name": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "collection_name",
        "value": "",
        "display_name": "Collection Name",
        "advanced": false,
        "dynamic": false,
        "info": "The name of the collection within HCD where the vectors will be stored.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "metadata_indexing_exclude": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "metadata_indexing_exclude",
        "value": "",
        "display_name": "Metadata Indexing Exclude",
        "advanced": true,
        "dynamic": false,
        "info": "Optional list of metadata fields to exclude from the indexing.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "metadata_indexing_include": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "metadata_indexing_include",
        "value": "",
        "display_name": "Metadata Indexing Include",
        "advanced": true,
        "dynamic": false,
        "info": "Optional list of metadata fields to include in the indexing.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "metric": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "cosine",
          "dot_product",
          "euclidean"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "metric",
        "value": "",
        "display_name": "Metric",
        "advanced": true,
        "dynamic": false,
        "info": "Optional distance metric for vector comparisons in the vector store.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "namespace": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "namespace",
        "value": "default_namespace",
        "display_name": "Namespace",
        "advanced": true,
        "dynamic": false,
        "info": "Optional namespace within HCD to use for the collection.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "number_of_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "number_of_results",
        "value": 4,
        "display_name": "Number of Results",
        "advanced": true,
        "dynamic": false,
        "info": "Number of results to return.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "password": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "password",
        "value": "HCD_PASSWORD",
        "display_name": "HCD Password",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "Authentication password for accessing HCD.",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "pre_delete_collection": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "pre_delete_collection",
        "value": false,
        "display_name": "Pre Delete Collection",
        "advanced": true,
        "dynamic": false,
        "info": "Boolean flag to determine whether to delete the collection before creating a new one.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "search_filter": {
        "tool_mode": false,
        "trace_as_input": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_filter",
        "value": {},
        "display_name": "Search Metadata Filter",
        "advanced": true,
        "dynamic": false,
        "info": "Optional dictionary of filters to apply to the search query.",
        "title_case": false,
        "type": "dict",
        "_input_type": "DictInput"
      },
      "search_query": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "Enter a query...",
        "show": true,
        "name": "search_query",
        "value": "",
        "display_name": "Search Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Enter a query to run a similarity search.",
        "title_case": false,
        "type": "query",
        "_input_type": "QueryInput"
      },
      "search_score_threshold": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_score_threshold",
        "value": 0,
        "display_name": "Search Score Threshold",
        "advanced": true,
        "dynamic": false,
        "info": "Minimum similarity score threshold for search results. (when using 'Similarity with score threshold')",
        "title_case": false,
        "type": "float",
        "_input_type": "FloatInput"
      },
      "search_type": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "Similarity",
          "Similarity with score threshold",
          "MMR (Max Marginal Relevance)"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_type",
        "value": "Similarity",
        "display_name": "Search Type",
        "advanced": true,
        "dynamic": false,
        "info": "Search type to use",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "setup_mode": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "Sync",
          "Async",
          "Off"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "setup_mode",
        "value": "Sync",
        "display_name": "Setup Mode",
        "advanced": true,
        "dynamic": false,
        "info": "Configuration mode for setting up the vector store, with options like 'Sync', 'Async', or 'Off'.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "should_cache_vector_store": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "should_cache_vector_store",
        "value": true,
        "display_name": "Cache Vector Store",
        "advanced": true,
        "dynamic": false,
        "info": "If True, the vector store will be cached for the current build of the component. This is useful for components that have multiple output methods and want to share the same vector store.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "username": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "username",
        "value": "hcd-superuser",
        "display_name": "HCD Username",
        "advanced": false,
        "dynamic": false,
        "info": "Authentication username for accessing HCD.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      }
    },
    "description": "Implementation of Vector Store using Hyper-Converged Database (HCD) with search capabilities",
    "icon": "HCD",
    "base_classes": [
      "Data",
      "DataFrame"
    ],
    "display_name": "Hyper-Converged Database",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "search_results",
        "display_name": "Search Results",
        "method": "search_documents",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "api_endpoint",
          "collection_name",
          "password",
          "username"
        ],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "collection_name",
      "username",
      "password",
      "api_endpoint",
      "ingest_data",
      "search_query",
      "should_cache_vector_store",
      "namespace",
      "ca_certificate",
      "metric",
      "batch_size",
      "bulk_insert_batch_concurrency",
      "bulk_insert_overwrite_concurrency",
      "bulk_delete_concurrency",
      "setup_mode",
      "pre_delete_collection",
      "metadata_indexing_include",
      "embedding",
      "metadata_indexing_exclude",
      "collection_indexing_policy",
      "number_of_results",
      "search_type",
      "search_score_threshold",
      "search_filter"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "VectaraSelfQueryRetriver": {
    "template": {
      "_type": "CustomComponent",
      "llm": {
        "type": "LanguageModel",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": false,
        "fileTypes": [],
        "file_path": "",
        "name": "llm",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "vectorstore": {
        "type": "VectorStore",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": false,
        "fileTypes": [],
        "file_path": "",
        "name": "vectorstore",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "import json\nfrom typing import cast\n\nfrom langchain.chains.query_constructor.base import AttributeInfo\nfrom langchain.retrievers.self_query.base import SelfQueryRetriever\nfrom langchain_core.vectorstores import VectorStore\n\nfrom langflow.custom import CustomComponent\nfrom langflow.field_typing import Retriever\nfrom langflow.field_typing.constants import LanguageModel\n\n\nclass VectaraSelfQueryRetriverComponent(CustomComponent):\n    \"\"\"A custom component for implementing Vectara Self Query Retriever using a vector store.\"\"\"\n\n    display_name: str = \"Vectara Self Query Retriever for Vectara Vector Store\"\n    description: str = \"Implementation of Vectara Self Query Retriever\"\n    name = \"VectaraSelfQueryRetriver\"\n    icon = \"Vectara\"\n    legacy = True\n\n    field_config = {\n        \"code\": {\"show\": True},\n        \"vectorstore\": {\"display_name\": \"Vector Store\", \"info\": \"Input Vectara Vectore Store\"},\n        \"llm\": {\"display_name\": \"LLM\", \"info\": \"For self query retriever\"},\n        \"document_content_description\": {\n            \"display_name\": \"Document Content Description\",\n            \"info\": \"For self query retriever\",\n        },\n        \"metadata_field_info\": {\n            \"display_name\": \"Metadata Field Info\",\n            \"info\": \"Each metadata field info is a string in the form of key value pair dictionary containing \"\n            \"additional search metadata.\\n\"\n            'Example input: {\"name\":\"speech\",\"description\":\"what name of the speech\",\"type\":'\n            '\"string or list[string]\"}.\\n'\n            \"The keys should remain constant(name, description, type)\",\n        },\n    }\n\n    def build(\n        self,\n        vectorstore: VectorStore,\n        document_content_description: str,\n        llm: LanguageModel,\n        metadata_field_info: list[str],\n    ) -> Retriever:\n        metadata_field_obj = []\n\n        for meta in metadata_field_info:\n            meta_obj = json.loads(meta)\n            if \"name\" not in meta_obj or \"description\" not in meta_obj or \"type\" not in meta_obj:\n                msg = \"Incorrect metadata field info format.\"\n                raise ValueError(msg)\n            attribute_info = AttributeInfo(\n                name=meta_obj[\"name\"],\n                description=meta_obj[\"description\"],\n                type=meta_obj[\"type\"],\n            )\n            metadata_field_obj.append(attribute_info)\n\n        return cast(\n            \"Retriever\",\n            SelfQueryRetriever.from_llm(\n                llm, vectorstore, document_content_description, metadata_field_obj, verbose=True\n            ),\n        )\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "document_content_description": {
        "type": "str",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": false,
        "fileTypes": [],
        "file_path": "",
        "name": "document_content_description",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "load_from_db": false,
        "title_case": false,
        "input_types": [
          "Text"
        ]
      },
      "metadata_field_info": {
        "type": "str",
        "required": true,
        "placeholder": "",
        "list": true,
        "show": true,
        "multiline": false,
        "fileTypes": [],
        "file_path": "",
        "name": "metadata_field_info",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "load_from_db": false,
        "title_case": false,
        "input_types": [
          "Text"
        ]
      }
    },
    "description": "Implementation of Vectara Self Query Retriever",
    "icon": "Vectara",
    "base_classes": [
      "Retriever"
    ],
    "display_name": "Vectara Self Query Retriever for Vectara Vector Store",
    "documentation": "",
    "minimized": false,
    "custom_fields": {
      "vectorstore": null,
      "document_content_description": null,
      "llm": null,
      "metadata_field_info": null
    },
    "output_types": [
      "Retriever"
    ],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Retriever"
        ],
        "selected": "Retriever",
        "name": "retriever",
        "hidden": null,
        "display_name": "Retriever",
        "method": null,
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": null,
        "allows_loop": false,
        "options": null,
        "tool_mode": true
      }
    ],
    "field_order": [],
    "beta": false,
    "legacy": true,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "Chroma": {
    "template": {
      "_type": "Component",
      "embedding": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "embedding",
        "value": "",
        "display_name": "Embedding",
        "advanced": false,
        "input_types": [
          "Embeddings"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "ingest_data": {
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "ingest_data",
        "value": "",
        "display_name": "Ingest Data",
        "advanced": false,
        "input_types": [
          "Data",
          "DataFrame"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "allow_duplicates": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "allow_duplicates",
        "value": false,
        "display_name": "Allow Duplicates",
        "advanced": true,
        "dynamic": false,
        "info": "If false, will not add documents that are already in the Vector Store.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "chroma_server_cors_allow_origins": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "chroma_server_cors_allow_origins",
        "value": "",
        "display_name": "Server CORS Allow Origins",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "chroma_server_grpc_port": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "chroma_server_grpc_port",
        "value": "",
        "display_name": "Server gRPC Port",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "chroma_server_host": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "chroma_server_host",
        "value": "",
        "display_name": "Server Host",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "chroma_server_http_port": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "chroma_server_http_port",
        "value": "",
        "display_name": "Server HTTP Port",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "chroma_server_ssl_enabled": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "chroma_server_ssl_enabled",
        "value": false,
        "display_name": "Server SSL Enabled",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from copy import deepcopy\n\nfrom chromadb.config import Settings\nfrom langchain_chroma import Chroma\nfrom typing_extensions import override\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.base.vectorstores.utils import chroma_collection_to_data\nfrom langflow.io import BoolInput, DropdownInput, HandleInput, IntInput, StrInput\nfrom langflow.schema import Data, DataFrame\n\n\nclass ChromaVectorStoreComponent(LCVectorStoreComponent):\n    \"\"\"Chroma Vector Store with search capabilities.\"\"\"\n\n    display_name: str = \"Chroma DB\"\n    description: str = \"Chroma Vector Store with search capabilities\"\n    name = \"Chroma\"\n    icon = \"Chroma\"\n\n    inputs = [\n        StrInput(\n            name=\"collection_name\",\n            display_name=\"Collection Name\",\n            value=\"langflow\",\n        ),\n        StrInput(\n            name=\"persist_directory\",\n            display_name=\"Persist Directory\",\n        ),\n        *LCVectorStoreComponent.inputs,\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n        StrInput(\n            name=\"chroma_server_cors_allow_origins\",\n            display_name=\"Server CORS Allow Origins\",\n            advanced=True,\n        ),\n        StrInput(\n            name=\"chroma_server_host\",\n            display_name=\"Server Host\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"chroma_server_http_port\",\n            display_name=\"Server HTTP Port\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"chroma_server_grpc_port\",\n            display_name=\"Server gRPC Port\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"chroma_server_ssl_enabled\",\n            display_name=\"Server SSL Enabled\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"allow_duplicates\",\n            display_name=\"Allow Duplicates\",\n            advanced=True,\n            info=\"If false, will not add documents that are already in the Vector Store.\",\n        ),\n        DropdownInput(\n            name=\"search_type\",\n            display_name=\"Search Type\",\n            options=[\"Similarity\", \"MMR\"],\n            value=\"Similarity\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            advanced=True,\n            value=10,\n        ),\n        IntInput(\n            name=\"limit\",\n            display_name=\"Limit\",\n            advanced=True,\n            info=\"Limit the number of records to compare when Allow Duplicates is False.\",\n        ),\n    ]\n\n    @override\n    @check_cached_vector_store\n    def build_vector_store(self) -> Chroma:\n        \"\"\"Builds the Chroma object.\"\"\"\n        try:\n            from chromadb import Client\n            from langchain_chroma import Chroma\n        except ImportError as e:\n            msg = \"Could not import Chroma integration package. Please install it with `pip install langchain-chroma`.\"\n            raise ImportError(msg) from e\n        # Chroma settings\n        chroma_settings = None\n        client = None\n        if self.chroma_server_host:\n            chroma_settings = Settings(\n                chroma_server_cors_allow_origins=self.chroma_server_cors_allow_origins or [],\n                chroma_server_host=self.chroma_server_host,\n                chroma_server_http_port=self.chroma_server_http_port or None,\n                chroma_server_grpc_port=self.chroma_server_grpc_port or None,\n                chroma_server_ssl_enabled=self.chroma_server_ssl_enabled,\n            )\n            client = Client(settings=chroma_settings)\n\n        # Check persist_directory and expand it if it is a relative path\n        persist_directory = self.resolve_path(self.persist_directory) if self.persist_directory is not None else None\n\n        chroma = Chroma(\n            persist_directory=persist_directory,\n            client=client,\n            embedding_function=self.embedding,\n            collection_name=self.collection_name,\n        )\n\n        self._add_documents_to_vector_store(chroma)\n        self.status = chroma_collection_to_data(chroma.get(limit=self.limit))\n        return chroma\n\n    def _add_documents_to_vector_store(self, vector_store: \"Chroma\") -> None:\n        \"\"\"Adds documents to the Vector Store.\"\"\"\n        ingest_data: list | Data | DataFrame = self.ingest_data\n        if not ingest_data:\n            self.status = \"\"\n            return\n\n        # Convert DataFrame to Data if needed using parent's method\n        ingest_data = self._prepare_ingest_data()\n\n        stored_documents_without_id = []\n        if self.allow_duplicates:\n            stored_data = []\n        else:\n            stored_data = chroma_collection_to_data(vector_store.get(limit=self.limit))\n            for value in deepcopy(stored_data):\n                del value.id\n                stored_documents_without_id.append(value)\n\n        documents = []\n        for _input in ingest_data or []:\n            if isinstance(_input, Data):\n                if _input not in stored_documents_without_id:\n                    documents.append(_input.to_lc_document())\n            else:\n                msg = \"Vector Store Inputs must be Data objects.\"\n                raise TypeError(msg)\n\n        if documents and self.embedding is not None:\n            self.log(f\"Adding {len(documents)} documents to the Vector Store.\")\n            vector_store.add_documents(documents)\n        else:\n            self.log(\"No documents to add to the Vector Store.\")\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "collection_name": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "collection_name",
        "value": "langflow",
        "display_name": "Collection Name",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "limit": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "limit",
        "value": "",
        "display_name": "Limit",
        "advanced": true,
        "dynamic": false,
        "info": "Limit the number of records to compare when Allow Duplicates is False.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "number_of_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "number_of_results",
        "value": 10,
        "display_name": "Number of Results",
        "advanced": true,
        "dynamic": false,
        "info": "Number of results to return.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "persist_directory": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "persist_directory",
        "value": "",
        "display_name": "Persist Directory",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "search_query": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "Enter a query...",
        "show": true,
        "name": "search_query",
        "value": "",
        "display_name": "Search Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Enter a query to run a similarity search.",
        "title_case": false,
        "type": "query",
        "_input_type": "QueryInput"
      },
      "search_type": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "Similarity",
          "MMR"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_type",
        "value": "Similarity",
        "display_name": "Search Type",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "should_cache_vector_store": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "should_cache_vector_store",
        "value": true,
        "display_name": "Cache Vector Store",
        "advanced": true,
        "dynamic": false,
        "info": "If True, the vector store will be cached for the current build of the component. This is useful for components that have multiple output methods and want to share the same vector store.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      }
    },
    "description": "Chroma Vector Store with search capabilities",
    "icon": "Chroma",
    "base_classes": [
      "Data",
      "DataFrame"
    ],
    "display_name": "Chroma DB",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "search_results",
        "display_name": "Search Results",
        "method": "search_documents",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "collection_name",
      "persist_directory",
      "ingest_data",
      "search_query",
      "should_cache_vector_store",
      "embedding",
      "chroma_server_cors_allow_origins",
      "chroma_server_host",
      "chroma_server_http_port",
      "chroma_server_grpc_port",
      "chroma_server_ssl_enabled",
      "allow_duplicates",
      "search_type",
      "number_of_results",
      "limit"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "Upstash": {
    "template": {
      "_type": "Component",
      "embedding": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "embedding",
        "value": "",
        "display_name": "Embedding",
        "advanced": false,
        "input_types": [
          "Embeddings"
        ],
        "dynamic": false,
        "info": "To use Upstash's embeddings, don't provide an embedding.",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "ingest_data": {
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "ingest_data",
        "value": "",
        "display_name": "Ingest Data",
        "advanced": false,
        "input_types": [
          "Data",
          "DataFrame"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain_community.vectorstores import UpstashVectorStore\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.io import (\n    HandleInput,\n    IntInput,\n    MultilineInput,\n    SecretStrInput,\n    StrInput,\n)\nfrom langflow.schema import Data\n\n\nclass UpstashVectorStoreComponent(LCVectorStoreComponent):\n    display_name = \"Upstash\"\n    description = \"Upstash Vector Store with search capabilities\"\n    name = \"Upstash\"\n    icon = \"Upstash\"\n\n    inputs = [\n        StrInput(\n            name=\"index_url\",\n            display_name=\"Index URL\",\n            info=\"The URL of the Upstash index.\",\n            required=True,\n        ),\n        SecretStrInput(\n            name=\"index_token\",\n            display_name=\"Index Token\",\n            info=\"The token for the Upstash index.\",\n            required=True,\n        ),\n        StrInput(\n            name=\"text_key\",\n            display_name=\"Text Key\",\n            info=\"The key in the record to use as text.\",\n            value=\"text\",\n            advanced=True,\n        ),\n        StrInput(\n            name=\"namespace\",\n            display_name=\"Namespace\",\n            info=\"Leave empty for default namespace.\",\n        ),\n        *LCVectorStoreComponent.inputs,\n        MultilineInput(\n            name=\"metadata_filter\",\n            display_name=\"Metadata Filter\",\n            info=\"Filters documents by metadata. Look at the documentation for more information.\",\n        ),\n        HandleInput(\n            name=\"embedding\",\n            display_name=\"Embedding\",\n            input_types=[\"Embeddings\"],\n            info=\"To use Upstash's embeddings, don't provide an embedding.\",\n        ),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            value=4,\n            advanced=True,\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> UpstashVectorStore:\n        use_upstash_embedding = self.embedding is None\n\n        # Convert DataFrame to Data if needed using parent's method\n        self.ingest_data = self._prepare_ingest_data()\n\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                documents.append(_input)\n\n        if documents:\n            if use_upstash_embedding:\n                upstash_vs = UpstashVectorStore(\n                    embedding=use_upstash_embedding,\n                    text_key=self.text_key,\n                    index_url=self.index_url,\n                    index_token=self.index_token,\n                    namespace=self.namespace,\n                )\n                upstash_vs.add_documents(documents)\n            else:\n                upstash_vs = UpstashVectorStore.from_documents(\n                    documents=documents,\n                    embedding=self.embedding,\n                    text_key=self.text_key,\n                    index_url=self.index_url,\n                    index_token=self.index_token,\n                    namespace=self.namespace,\n                )\n        else:\n            upstash_vs = UpstashVectorStore(\n                embedding=self.embedding or use_upstash_embedding,\n                text_key=self.text_key,\n                index_url=self.index_url,\n                index_token=self.index_token,\n                namespace=self.namespace,\n            )\n\n        return upstash_vs\n\n    def search_documents(self) -> list[Data]:\n        vector_store = self.build_vector_store()\n\n        if self.search_query and isinstance(self.search_query, str) and self.search_query.strip():\n            docs = vector_store.similarity_search(\n                query=self.search_query,\n                k=self.number_of_results,\n                filter=self.metadata_filter,\n            )\n\n            data = docs_to_data(docs)\n            self.status = data\n            return data\n        return []\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "index_token": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "index_token",
        "value": "",
        "display_name": "Index Token",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "The token for the Upstash index.",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "index_url": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "index_url",
        "value": "",
        "display_name": "Index URL",
        "advanced": false,
        "dynamic": false,
        "info": "The URL of the Upstash index.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "metadata_filter": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "metadata_filter",
        "value": "",
        "display_name": "Metadata Filter",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Filters documents by metadata. Look at the documentation for more information.",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "namespace": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "namespace",
        "value": "",
        "display_name": "Namespace",
        "advanced": false,
        "dynamic": false,
        "info": "Leave empty for default namespace.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "number_of_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "number_of_results",
        "value": 4,
        "display_name": "Number of Results",
        "advanced": true,
        "dynamic": false,
        "info": "Number of results to return.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "search_query": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "Enter a query...",
        "show": true,
        "name": "search_query",
        "value": "",
        "display_name": "Search Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Enter a query to run a similarity search.",
        "title_case": false,
        "type": "query",
        "_input_type": "QueryInput"
      },
      "should_cache_vector_store": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "should_cache_vector_store",
        "value": true,
        "display_name": "Cache Vector Store",
        "advanced": true,
        "dynamic": false,
        "info": "If True, the vector store will be cached for the current build of the component. This is useful for components that have multiple output methods and want to share the same vector store.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "text_key": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "text_key",
        "value": "text",
        "display_name": "Text Key",
        "advanced": true,
        "dynamic": false,
        "info": "The key in the record to use as text.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      }
    },
    "description": "Upstash Vector Store with search capabilities",
    "icon": "Upstash",
    "base_classes": [
      "Data",
      "DataFrame"
    ],
    "display_name": "Upstash",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "search_results",
        "display_name": "Search Results",
        "method": "search_documents",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "index_token",
          "index_url"
        ],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "index_url",
      "index_token",
      "text_key",
      "namespace",
      "ingest_data",
      "search_query",
      "should_cache_vector_store",
      "metadata_filter",
      "embedding",
      "number_of_results"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "Couchbase": {
    "template": {
      "_type": "Component",
      "embedding": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "embedding",
        "value": "",
        "display_name": "Embedding",
        "advanced": false,
        "input_types": [
          "Embeddings"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "ingest_data": {
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "ingest_data",
        "value": "",
        "display_name": "Ingest Data",
        "advanced": false,
        "input_types": [
          "Data",
          "DataFrame"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "bucket_name": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "bucket_name",
        "value": "",
        "display_name": "Bucket Name",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from datetime import timedelta\n\nfrom langchain_community.vectorstores import CouchbaseVectorStore\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.io import HandleInput, IntInput, SecretStrInput, StrInput\nfrom langflow.schema import Data\n\n\nclass CouchbaseVectorStoreComponent(LCVectorStoreComponent):\n    display_name = \"Couchbase\"\n    description = \"Couchbase Vector Store with search capabilities\"\n    name = \"Couchbase\"\n    icon = \"Couchbase\"\n\n    inputs = [\n        SecretStrInput(\n            name=\"couchbase_connection_string\", display_name=\"Couchbase Cluster connection string\", required=True\n        ),\n        StrInput(name=\"couchbase_username\", display_name=\"Couchbase username\", required=True),\n        SecretStrInput(name=\"couchbase_password\", display_name=\"Couchbase password\", required=True),\n        StrInput(name=\"bucket_name\", display_name=\"Bucket Name\", required=True),\n        StrInput(name=\"scope_name\", display_name=\"Scope Name\", required=True),\n        StrInput(name=\"collection_name\", display_name=\"Collection Name\", required=True),\n        StrInput(name=\"index_name\", display_name=\"Index Name\", required=True),\n        *LCVectorStoreComponent.inputs,\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            value=4,\n            advanced=True,\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> CouchbaseVectorStore:\n        try:\n            from couchbase.auth import PasswordAuthenticator\n            from couchbase.cluster import Cluster\n            from couchbase.options import ClusterOptions\n        except ImportError as e:\n            msg = \"Failed to import Couchbase dependencies. Install it using `pip install langflow[couchbase] --pre`\"\n            raise ImportError(msg) from e\n\n        try:\n            auth = PasswordAuthenticator(self.couchbase_username, self.couchbase_password)\n            options = ClusterOptions(auth)\n            cluster = Cluster(self.couchbase_connection_string, options)\n\n            cluster.wait_until_ready(timedelta(seconds=5))\n        except Exception as e:\n            msg = f\"Failed to connect to Couchbase: {e}\"\n            raise ValueError(msg) from e\n\n        self.ingest_data = self._prepare_ingest_data()\n\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                documents.append(_input)\n\n        if documents:\n            couchbase_vs = CouchbaseVectorStore.from_documents(\n                documents=documents,\n                cluster=cluster,\n                bucket_name=self.bucket_name,\n                scope_name=self.scope_name,\n                collection_name=self.collection_name,\n                embedding=self.embedding,\n                index_name=self.index_name,\n            )\n\n        else:\n            couchbase_vs = CouchbaseVectorStore(\n                cluster=cluster,\n                bucket_name=self.bucket_name,\n                scope_name=self.scope_name,\n                collection_name=self.collection_name,\n                embedding=self.embedding,\n                index_name=self.index_name,\n            )\n\n        return couchbase_vs\n\n    def search_documents(self) -> list[Data]:\n        vector_store = self.build_vector_store()\n\n        if self.search_query and isinstance(self.search_query, str) and self.search_query.strip():\n            docs = vector_store.similarity_search(\n                query=self.search_query,\n                k=self.number_of_results,\n            )\n\n            data = docs_to_data(docs)\n            self.status = data\n            return data\n        return []\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "collection_name": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "collection_name",
        "value": "",
        "display_name": "Collection Name",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "couchbase_connection_string": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "couchbase_connection_string",
        "value": "",
        "display_name": "Couchbase Cluster connection string",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "couchbase_password": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "couchbase_password",
        "value": "",
        "display_name": "Couchbase password",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "couchbase_username": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "couchbase_username",
        "value": "",
        "display_name": "Couchbase username",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "index_name": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "index_name",
        "value": "",
        "display_name": "Index Name",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "number_of_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "number_of_results",
        "value": 4,
        "display_name": "Number of Results",
        "advanced": true,
        "dynamic": false,
        "info": "Number of results to return.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "scope_name": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "scope_name",
        "value": "",
        "display_name": "Scope Name",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "search_query": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "Enter a query...",
        "show": true,
        "name": "search_query",
        "value": "",
        "display_name": "Search Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Enter a query to run a similarity search.",
        "title_case": false,
        "type": "query",
        "_input_type": "QueryInput"
      },
      "should_cache_vector_store": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "should_cache_vector_store",
        "value": true,
        "display_name": "Cache Vector Store",
        "advanced": true,
        "dynamic": false,
        "info": "If True, the vector store will be cached for the current build of the component. This is useful for components that have multiple output methods and want to share the same vector store.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      }
    },
    "description": "Couchbase Vector Store with search capabilities",
    "icon": "Couchbase",
    "base_classes": [
      "Data",
      "DataFrame"
    ],
    "display_name": "Couchbase",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "search_results",
        "display_name": "Search Results",
        "method": "search_documents",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "bucket_name",
          "collection_name",
          "couchbase_connection_string",
          "couchbase_password",
          "couchbase_username",
          "index_name",
          "scope_name"
        ],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "couchbase_connection_string",
      "couchbase_username",
      "couchbase_password",
      "bucket_name",
      "scope_name",
      "collection_name",
      "index_name",
      "ingest_data",
      "search_query",
      "should_cache_vector_store",
      "embedding",
      "number_of_results"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  }
}