{
  "YouTubeTrendingComponent": {
    "template": {
      "_type": "Component",
      "api_key": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "api_key",
        "value": "",
        "display_name": "YouTube API Key",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "Your YouTube Data API key.",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "category": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "All",
          "Film & Animation",
          "Autos & Vehicles",
          "Music",
          "Pets & Animals",
          "Sports",
          "Travel & Events",
          "Gaming",
          "People & Blogs",
          "Comedy",
          "Entertainment",
          "News & Politics",
          "Education",
          "Science & Technology",
          "Nonprofits & Activism"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "category",
        "value": "All",
        "display_name": "Category",
        "advanced": false,
        "dynamic": false,
        "info": "The category of videos to retrieve.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from contextlib import contextmanager\n\nimport pandas as pd\nfrom googleapiclient.discovery import build\nfrom googleapiclient.errors import HttpError\n\nfrom langflow.custom import Component\nfrom langflow.inputs import BoolInput, DropdownInput, IntInput, SecretStrInput\nfrom langflow.schema import DataFrame\nfrom langflow.template import Output\n\nHTTP_FORBIDDEN = 403\nHTTP_NOT_FOUND = 404\nMAX_API_RESULTS = 50\n\n\nclass YouTubeTrendingComponent(Component):\n    \"\"\"A component that retrieves trending videos from YouTube.\"\"\"\n\n    display_name: str = \"YouTube Trending\"\n    description: str = \"Retrieves trending videos from YouTube with filtering options.\"\n    icon: str = \"YouTube\"\n\n    # Dictionary of country codes and names\n    COUNTRY_CODES = {\n        \"Global\": \"US\",  # Default to US for global\n        \"United States\": \"US\",\n        \"Brazil\": \"BR\",\n        \"United Kingdom\": \"GB\",\n        \"India\": \"IN\",\n        \"Japan\": \"JP\",\n        \"South Korea\": \"KR\",\n        \"Germany\": \"DE\",\n        \"France\": \"FR\",\n        \"Canada\": \"CA\",\n        \"Australia\": \"AU\",\n        \"Spain\": \"ES\",\n        \"Italy\": \"IT\",\n        \"Mexico\": \"MX\",\n        \"Russia\": \"RU\",\n        \"Netherlands\": \"NL\",\n        \"Poland\": \"PL\",\n        \"Argentina\": \"AR\",\n    }\n\n    # Dictionary of video categories\n    VIDEO_CATEGORIES = {\n        \"All\": \"0\",\n        \"Film & Animation\": \"1\",\n        \"Autos & Vehicles\": \"2\",\n        \"Music\": \"10\",\n        \"Pets & Animals\": \"15\",\n        \"Sports\": \"17\",\n        \"Travel & Events\": \"19\",\n        \"Gaming\": \"20\",\n        \"People & Blogs\": \"22\",\n        \"Comedy\": \"23\",\n        \"Entertainment\": \"24\",\n        \"News & Politics\": \"25\",\n        \"Education\": \"27\",\n        \"Science & Technology\": \"28\",\n        \"Nonprofits & Activism\": \"29\",\n    }\n\n    inputs = [\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"YouTube API Key\",\n            info=\"Your YouTube Data API key.\",\n            required=True,\n        ),\n        DropdownInput(\n            name=\"region\",\n            display_name=\"Region\",\n            options=list(COUNTRY_CODES.keys()),\n            value=\"Global\",\n            info=\"The region to get trending videos from.\",\n        ),\n        DropdownInput(\n            name=\"category\",\n            display_name=\"Category\",\n            options=list(VIDEO_CATEGORIES.keys()),\n            value=\"All\",\n            info=\"The category of videos to retrieve.\",\n        ),\n        IntInput(\n            name=\"max_results\",\n            display_name=\"Max Results\",\n            value=10,\n            info=\"Maximum number of trending videos to return (1-50).\",\n        ),\n        BoolInput(\n            name=\"include_statistics\",\n            display_name=\"Include Statistics\",\n            value=True,\n            info=\"Include video statistics (views, likes, comments).\",\n        ),\n        BoolInput(\n            name=\"include_content_details\",\n            display_name=\"Include Content Details\",\n            value=True,\n            info=\"Include video duration and quality info.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"include_thumbnails\",\n            display_name=\"Include Thumbnails\",\n            value=True,\n            info=\"Include video thumbnail URLs.\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(name=\"trending_videos\", display_name=\"Trending Videos\", method=\"get_trending_videos\"),\n    ]\n\n    max_results: int\n\n    def _format_duration(self, duration: str) -> str:\n        \"\"\"Formats ISO 8601 duration to readable format.\"\"\"\n        import re\n\n        # Remove 'PT' from the start of duration\n        duration = duration[2:]\n\n        hours = 0\n        minutes = 0\n        seconds = 0\n\n        # Extract hours, minutes and seconds\n        time_dict = {}\n        for time_unit in [\"H\", \"M\", \"S\"]:\n            match = re.search(r\"(\\d+)\" + time_unit, duration)\n            if match:\n                time_dict[time_unit] = int(match.group(1))\n\n        if \"H\" in time_dict:\n            hours = time_dict[\"H\"]\n        if \"M\" in time_dict:\n            minutes = time_dict[\"M\"]\n        if \"S\" in time_dict:\n            seconds = time_dict[\"S\"]\n\n        # Format the time string\n        if hours > 0:\n            return f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n        return f\"{minutes:02d}:{seconds:02d}\"\n\n    @contextmanager\n    def youtube_client(self):\n        \"\"\"Context manager for YouTube API client.\"\"\"\n        client = build(\"youtube\", \"v3\", developerKey=self.api_key)\n        try:\n            yield client\n        finally:\n            client.close()\n\n    def get_trending_videos(self) -> DataFrame:\n        \"\"\"Retrieves trending videos from YouTube and returns as DataFrame.\"\"\"\n        try:\n            # Validate max_results\n            if not 1 <= self.max_results <= MAX_API_RESULTS:\n                self.max_results = min(max(1, self.max_results), MAX_API_RESULTS)\n\n            # Use context manager for YouTube API client\n            with self.youtube_client() as youtube:\n                # Get country code\n                region_code = self.COUNTRY_CODES[self.region]\n\n                # Prepare API request parts\n                parts = [\"snippet\"]\n                if self.include_statistics:\n                    parts.append(\"statistics\")\n                if self.include_content_details:\n                    parts.append(\"contentDetails\")\n\n                # Prepare API request parameters\n                request_params = {\n                    \"part\": \",\".join(parts),\n                    \"chart\": \"mostPopular\",\n                    \"regionCode\": region_code,\n                    \"maxResults\": self.max_results,\n                }\n\n                # Add category filter if not \"All\"\n                if self.category != \"All\":\n                    request_params[\"videoCategoryId\"] = self.VIDEO_CATEGORIES[self.category]\n\n                # Get trending videos\n                request = youtube.videos().list(**request_params)\n                response = request.execute()\n\n                videos_data = []\n                for item in response.get(\"items\", []):\n                    video_data = {\n                        \"video_id\": item[\"id\"],\n                        \"title\": item[\"snippet\"][\"title\"],\n                        \"description\": item[\"snippet\"][\"description\"],\n                        \"channel_id\": item[\"snippet\"][\"channelId\"],\n                        \"channel_title\": item[\"snippet\"][\"channelTitle\"],\n                        \"published_at\": item[\"snippet\"][\"publishedAt\"],\n                        \"url\": f\"https://www.youtube.com/watch?v={item['id']}\",\n                        \"region\": self.region,\n                        \"category\": self.category,\n                    }\n\n                    # Add thumbnails if requested\n                    if self.include_thumbnails:\n                        for size, thumb in item[\"snippet\"][\"thumbnails\"].items():\n                            video_data[f\"thumbnail_{size}_url\"] = thumb[\"url\"]\n                            video_data[f\"thumbnail_{size}_width\"] = thumb.get(\"width\", 0)\n                            video_data[f\"thumbnail_{size}_height\"] = thumb.get(\"height\", 0)\n\n                    # Add statistics if requested\n                    if self.include_statistics and \"statistics\" in item:\n                        video_data.update(\n                            {\n                                \"view_count\": int(item[\"statistics\"].get(\"viewCount\", 0)),\n                                \"like_count\": int(item[\"statistics\"].get(\"likeCount\", 0)),\n                                \"comment_count\": int(item[\"statistics\"].get(\"commentCount\", 0)),\n                            }\n                        )\n\n                    # Add content details if requested\n                    if self.include_content_details and \"contentDetails\" in item:\n                        content_details = item[\"contentDetails\"]\n                        video_data.update(\n                            {\n                                \"duration\": self._format_duration(content_details[\"duration\"]),\n                                \"definition\": content_details.get(\"definition\", \"hd\").upper(),\n                                \"has_captions\": content_details.get(\"caption\", \"false\") == \"true\",\n                                \"licensed_content\": content_details.get(\"licensedContent\", False),\n                                \"projection\": content_details.get(\"projection\", \"rectangular\"),\n                            }\n                        )\n\n                    videos_data.append(video_data)\n\n                # Convert to DataFrame\n                videos_df = pd.DataFrame(videos_data)\n\n                # Organize columns\n                column_order = [\n                    \"video_id\",\n                    \"title\",\n                    \"channel_id\",\n                    \"channel_title\",\n                    \"category\",\n                    \"region\",\n                    \"published_at\",\n                    \"url\",\n                    \"description\",\n                ]\n\n                if self.include_statistics:\n                    column_order.extend([\"view_count\", \"like_count\", \"comment_count\"])\n\n                if self.include_content_details:\n                    column_order.extend([\"duration\", \"definition\", \"has_captions\", \"licensed_content\", \"projection\"])\n\n                # Add thumbnail columns at the end if included\n                if self.include_thumbnails:\n                    thumbnail_cols = [col for col in videos_df.columns if col.startswith(\"thumbnail_\")]\n                    column_order.extend(sorted(thumbnail_cols))\n\n                # Reorder columns, including any that might not be in column_order\n                remaining_cols = [col for col in videos_df.columns if col not in column_order]\n                videos_df = videos_df[column_order + remaining_cols]\n\n                return DataFrame(videos_df)\n\n        except HttpError as e:\n            error_message = f\"YouTube API error: {e}\"\n            if e.resp.status == HTTP_FORBIDDEN:\n                error_message = \"API quota exceeded or access forbidden.\"\n            elif e.resp.status == HTTP_NOT_FOUND:\n                error_message = \"Resource not found.\"\n\n            return DataFrame(pd.DataFrame({\"error\": [error_message]}))\n\n        except Exception as e:\n            import logging\n\n            logging.exception(\"An unexpected error occurred:\")\n            return DataFrame(pd.DataFrame({\"error\": [str(e)]}))\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "include_content_details": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "include_content_details",
        "value": true,
        "display_name": "Include Content Details",
        "advanced": true,
        "dynamic": false,
        "info": "Include video duration and quality info.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "include_statistics": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "include_statistics",
        "value": true,
        "display_name": "Include Statistics",
        "advanced": false,
        "dynamic": false,
        "info": "Include video statistics (views, likes, comments).",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "include_thumbnails": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "include_thumbnails",
        "value": true,
        "display_name": "Include Thumbnails",
        "advanced": true,
        "dynamic": false,
        "info": "Include video thumbnail URLs.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "max_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "max_results",
        "value": 10,
        "display_name": "Max Results",
        "advanced": false,
        "dynamic": false,
        "info": "Maximum number of trending videos to return (1-50).",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "region": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "Global",
          "United States",
          "Brazil",
          "United Kingdom",
          "India",
          "Japan",
          "South Korea",
          "Germany",
          "France",
          "Canada",
          "Australia",
          "Spain",
          "Italy",
          "Mexico",
          "Russia",
          "Netherlands",
          "Poland",
          "Argentina"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "region",
        "value": "Global",
        "display_name": "Region",
        "advanced": false,
        "dynamic": false,
        "info": "The region to get trending videos from.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      }
    },
    "description": "Retrieves trending videos from YouTube with filtering options.",
    "icon": "YouTube",
    "base_classes": [
      "DataFrame"
    ],
    "display_name": "YouTube Trending",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "trending_videos",
        "display_name": "Trending Videos",
        "method": "get_trending_videos",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "api_key",
      "region",
      "category",
      "max_results",
      "include_statistics",
      "include_content_details",
      "include_thumbnails"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "YouTubeChannelComponent": {
    "template": {
      "_type": "Component",
      "api_key": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "api_key",
        "value": "",
        "display_name": "YouTube API Key",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "Your YouTube Data API key.",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "channel_url": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "channel_url",
        "value": "",
        "display_name": "Channel URL or ID",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The URL or ID of the YouTube channel.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from typing import Any\nfrom urllib.error import HTTPError\n\nimport pandas as pd\nfrom googleapiclient.discovery import build\nfrom googleapiclient.errors import HttpError\n\nfrom langflow.custom import Component\nfrom langflow.inputs import BoolInput, MessageTextInput, SecretStrInput\nfrom langflow.schema import DataFrame\nfrom langflow.template import Output\n\n\nclass YouTubeChannelComponent(Component):\n    \"\"\"A component that retrieves detailed information about YouTube channels.\"\"\"\n\n    display_name: str = \"YouTube Channel\"\n    description: str = \"Retrieves detailed information and statistics about YouTube channels as a DataFrame.\"\n    icon: str = \"YouTube\"\n\n    # Constants\n    CHANNEL_ID_LENGTH = 24\n    QUOTA_EXCEEDED_STATUS = 403\n    NOT_FOUND_STATUS = 404\n    MAX_PLAYLIST_RESULTS = 10\n\n    inputs = [\n        MessageTextInput(\n            name=\"channel_url\",\n            display_name=\"Channel URL or ID\",\n            info=\"The URL or ID of the YouTube channel.\",\n            tool_mode=True,\n            required=True,\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"YouTube API Key\",\n            info=\"Your YouTube Data API key.\",\n            required=True,\n        ),\n        BoolInput(\n            name=\"include_statistics\",\n            display_name=\"Include Statistics\",\n            value=True,\n            info=\"Include channel statistics (views, subscribers, videos).\",\n        ),\n        BoolInput(\n            name=\"include_branding\",\n            display_name=\"Include Branding\",\n            value=True,\n            info=\"Include channel branding settings (banner, thumbnails).\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"include_playlists\",\n            display_name=\"Include Playlists\",\n            value=False,\n            info=\"Include channel's public playlists.\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(name=\"channel_df\", display_name=\"Channel Info\", method=\"get_channel_info\"),\n    ]\n\n    def _extract_channel_id(self, channel_url: str) -> str:\n        \"\"\"Extracts the channel ID from various YouTube channel URL formats.\"\"\"\n        import re\n\n        if channel_url.startswith(\"UC\") and len(channel_url) == self.CHANNEL_ID_LENGTH:\n            return channel_url\n\n        patterns = {\n            \"custom_url\": r\"youtube\\.com\\/c\\/([^\\/\\n?]+)\",\n            \"channel_id\": r\"youtube\\.com\\/channel\\/([^\\/\\n?]+)\",\n            \"user\": r\"youtube\\.com\\/user\\/([^\\/\\n?]+)\",\n            \"handle\": r\"youtube\\.com\\/@([^\\/\\n?]+)\",\n        }\n\n        for pattern_type, pattern in patterns.items():\n            match = re.search(pattern, channel_url)\n            if match:\n                if pattern_type == \"channel_id\":\n                    return match.group(1)\n                return self._get_channel_id_by_name(match.group(1), pattern_type)\n\n        return channel_url\n\n    def _get_channel_id_by_name(self, channel_name: str, identifier_type: str) -> str:\n        \"\"\"Gets the channel ID using the channel name or custom URL.\"\"\"\n        youtube = None\n        try:\n            youtube = build(\"youtube\", \"v3\", developerKey=self.api_key)\n\n            if identifier_type == \"handle\":\n                channel_name = channel_name.lstrip(\"@\")\n\n            request = youtube.search().list(part=\"id\", q=channel_name, type=\"channel\", maxResults=1)\n            response = request.execute()\n\n            if response[\"items\"]:\n                return response[\"items\"][0][\"id\"][\"channelId\"]\n\n            error_msg = f\"Could not find channel ID for: {channel_name}\"\n            raise ValueError(error_msg)\n\n        except (HttpError, HTTPError) as e:\n            error_msg = f\"YouTube API error while getting channel ID: {e!s}\"\n            raise RuntimeError(error_msg) from e\n        except Exception as e:\n            error_msg = f\"Unexpected error while getting channel ID: {e!s}\"\n            raise ValueError(error_msg) from e\n        finally:\n            if youtube:\n                youtube.close()\n\n    def _get_channel_playlists(self, youtube: Any, channel_id: str) -> list[dict[str, Any]]:\n        \"\"\"Gets the public playlists for a channel.\"\"\"\n        try:\n            playlists_request = youtube.playlists().list(\n                part=\"snippet,contentDetails\",\n                channelId=channel_id,\n                maxResults=self.MAX_PLAYLIST_RESULTS,\n            )\n            playlists_response = playlists_request.execute()\n            playlists = []\n\n            for item in playlists_response.get(\"items\", []):\n                playlist_data = {\n                    \"playlist_title\": item[\"snippet\"][\"title\"],\n                    \"playlist_description\": item[\"snippet\"][\"description\"],\n                    \"playlist_id\": item[\"id\"],\n                    \"playlist_video_count\": item[\"contentDetails\"][\"itemCount\"],\n                    \"playlist_published_at\": item[\"snippet\"][\"publishedAt\"],\n                    \"playlist_thumbnail_url\": item[\"snippet\"][\"thumbnails\"][\"default\"][\"url\"],\n                }\n                playlists.append(playlist_data)\n\n            return playlists\n        except (HttpError, HTTPError) as e:\n            return [{\"error\": str(e)}]\n        else:\n            return playlists\n\n    def get_channel_info(self) -> DataFrame:\n        \"\"\"Retrieves channel information and returns it as a DataFrame.\"\"\"\n        youtube = None\n        try:\n            # Get channel ID and initialize YouTube API client\n            channel_id = self._extract_channel_id(self.channel_url)\n            youtube = build(\"youtube\", \"v3\", developerKey=self.api_key)\n\n            # Prepare parts for the API request\n            parts = [\"snippet\", \"contentDetails\"]\n            if self.include_statistics:\n                parts.append(\"statistics\")\n            if self.include_branding:\n                parts.append(\"brandingSettings\")\n\n            # Get channel information\n            channel_response = youtube.channels().list(part=\",\".join(parts), id=channel_id).execute()\n\n            if not channel_response[\"items\"]:\n                return DataFrame(pd.DataFrame({\"error\": [\"Channel not found\"]}))\n\n            channel_info = channel_response[\"items\"][0]\n\n            # Build basic channel data\n            channel_data = {\n                \"title\": [channel_info[\"snippet\"][\"title\"]],\n                \"description\": [channel_info[\"snippet\"][\"description\"]],\n                \"custom_url\": [channel_info[\"snippet\"].get(\"customUrl\", \"\")],\n                \"published_at\": [channel_info[\"snippet\"][\"publishedAt\"]],\n                \"country\": [channel_info[\"snippet\"].get(\"country\", \"Not specified\")],\n                \"channel_id\": [channel_id],\n            }\n\n            # Add thumbnails\n            for size, thumb in channel_info[\"snippet\"][\"thumbnails\"].items():\n                channel_data[f\"thumbnail_{size}\"] = [thumb[\"url\"]]\n\n            # Add statistics if requested\n            if self.include_statistics:\n                stats = channel_info[\"statistics\"]\n                channel_data.update(\n                    {\n                        \"view_count\": [int(stats.get(\"viewCount\", 0))],\n                        \"subscriber_count\": [int(stats.get(\"subscriberCount\", 0))],\n                        \"hidden_subscriber_count\": [stats.get(\"hiddenSubscriberCount\", False)],\n                        \"video_count\": [int(stats.get(\"videoCount\", 0))],\n                    }\n                )\n\n            # Add branding if requested\n            if self.include_branding:\n                branding = channel_info.get(\"brandingSettings\", {})\n                channel_data.update(\n                    {\n                        \"brand_title\": [branding.get(\"channel\", {}).get(\"title\", \"\")],\n                        \"brand_description\": [branding.get(\"channel\", {}).get(\"description\", \"\")],\n                        \"brand_keywords\": [branding.get(\"channel\", {}).get(\"keywords\", \"\")],\n                        \"brand_banner_url\": [branding.get(\"image\", {}).get(\"bannerExternalUrl\", \"\")],\n                    }\n                )\n\n            # Create the initial DataFrame\n            channel_df = pd.DataFrame(channel_data)\n\n            # Add playlists if requested\n            if self.include_playlists:\n                playlists = self._get_channel_playlists(youtube, channel_id)\n                if playlists and \"error\" not in playlists[0]:\n                    # Create a DataFrame for playlists\n                    playlists_df = pd.DataFrame(playlists)\n                    # Join with main DataFrame\n                    channel_df = pd.concat([channel_df] * len(playlists_df), ignore_index=True)\n                    for column in playlists_df.columns:\n                        channel_df[column] = playlists_df[column].to_numpy()\n\n            return DataFrame(channel_df)\n\n        except (HttpError, HTTPError, Exception) as e:\n            return DataFrame(pd.DataFrame({\"error\": [str(e)]}))\n        finally:\n            if youtube:\n                youtube.close()\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "include_branding": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "include_branding",
        "value": true,
        "display_name": "Include Branding",
        "advanced": true,
        "dynamic": false,
        "info": "Include channel branding settings (banner, thumbnails).",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "include_playlists": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "include_playlists",
        "value": false,
        "display_name": "Include Playlists",
        "advanced": true,
        "dynamic": false,
        "info": "Include channel's public playlists.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "include_statistics": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "include_statistics",
        "value": true,
        "display_name": "Include Statistics",
        "advanced": false,
        "dynamic": false,
        "info": "Include channel statistics (views, subscribers, videos).",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      }
    },
    "description": "Retrieves detailed information and statistics about YouTube channels as a DataFrame.",
    "icon": "YouTube",
    "base_classes": [
      "DataFrame"
    ],
    "display_name": "YouTube Channel",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "channel_df",
        "display_name": "Channel Info",
        "method": "get_channel_info",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "channel_url",
      "api_key",
      "include_statistics",
      "include_branding",
      "include_playlists"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "YouTubeTranscripts": {
    "template": {
      "_type": "Component",
      "chunk_size_seconds": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "chunk_size_seconds",
        "value": 60,
        "display_name": "Chunk Size (seconds)",
        "advanced": false,
        "dynamic": false,
        "info": "The size of each transcript chunk in seconds.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "import pandas as pd\nimport youtube_transcript_api\nfrom langchain_community.document_loaders import YoutubeLoader\nfrom langchain_community.document_loaders.youtube import TranscriptFormat\n\nfrom langflow.custom import Component\nfrom langflow.inputs import DropdownInput, IntInput, MultilineInput\nfrom langflow.schema import Data, DataFrame, Message\nfrom langflow.template import Output\n\n\nclass YouTubeTranscriptsComponent(Component):\n    \"\"\"A component that extracts spoken content from YouTube videos as transcripts.\"\"\"\n\n    display_name: str = \"YouTube Transcripts\"\n    description: str = \"Extracts spoken content from YouTube videos with multiple output options.\"\n    icon: str = \"YouTube\"\n    name = \"YouTubeTranscripts\"\n\n    inputs = [\n        MultilineInput(\n            name=\"url\",\n            display_name=\"Video URL\",\n            info=\"Enter the YouTube video URL to get transcripts from.\",\n            tool_mode=True,\n            required=True,\n        ),\n        IntInput(\n            name=\"chunk_size_seconds\",\n            display_name=\"Chunk Size (seconds)\",\n            value=60,\n            info=\"The size of each transcript chunk in seconds.\",\n        ),\n        DropdownInput(\n            name=\"translation\",\n            display_name=\"Translation Language\",\n            advanced=True,\n            options=[\"\", \"en\", \"es\", \"fr\", \"de\", \"it\", \"pt\", \"ru\", \"ja\", \"ko\", \"hi\", \"ar\", \"id\"],\n            info=\"Translate the transcripts to the specified language. Leave empty for no translation.\",\n        ),\n    ]\n\n    outputs = [\n        Output(name=\"dataframe\", display_name=\"Chunks\", method=\"get_dataframe_output\"),\n        Output(name=\"message\", display_name=\"Transcript\", method=\"get_message_output\"),\n        Output(name=\"data_output\", display_name=\"Transcript + Source\", method=\"get_data_output\"),\n    ]\n\n    def _load_transcripts(self, *, as_chunks: bool = True):\n        \"\"\"Internal method to load transcripts from YouTube.\"\"\"\n        loader = YoutubeLoader.from_youtube_url(\n            self.url,\n            transcript_format=TranscriptFormat.CHUNKS if as_chunks else TranscriptFormat.TEXT,\n            chunk_size_seconds=self.chunk_size_seconds,\n            translation=self.translation or None,\n        )\n        return loader.load()\n\n    def get_dataframe_output(self) -> DataFrame:\n        \"\"\"Provides transcript output as a DataFrame with timestamp and text columns.\"\"\"\n        try:\n            transcripts = self._load_transcripts(as_chunks=True)\n\n            # Create DataFrame with timestamp and text columns\n            data = []\n            for doc in transcripts:\n                start_seconds = int(doc.metadata[\"start_seconds\"])\n                start_minutes = start_seconds // 60\n                start_seconds %= 60\n                timestamp = f\"{start_minutes:02d}:{start_seconds:02d}\"\n                data.append({\"timestamp\": timestamp, \"text\": doc.page_content})\n\n            return DataFrame(pd.DataFrame(data))\n\n        except (youtube_transcript_api.TranscriptsDisabled, youtube_transcript_api.NoTranscriptFound) as exc:\n            return DataFrame(pd.DataFrame({\"error\": [f\"Failed to get YouTube transcripts: {exc!s}\"]}))\n\n    def get_message_output(self) -> Message:\n        \"\"\"Provides transcript output as continuous text.\"\"\"\n        try:\n            transcripts = self._load_transcripts(as_chunks=False)\n            result = transcripts[0].page_content\n            return Message(text=result)\n\n        except (youtube_transcript_api.TranscriptsDisabled, youtube_transcript_api.NoTranscriptFound) as exc:\n            error_msg = f\"Failed to get YouTube transcripts: {exc!s}\"\n            return Message(text=error_msg)\n\n    def get_data_output(self) -> Data:\n        \"\"\"Creates a structured data object with transcript and metadata.\n\n        Returns a Data object containing transcript text, video URL, and any error\n        messages that occurred during processing. The object includes:\n        - 'transcript': continuous text from the entire video (concatenated if multiple parts)\n        - 'video_url': the input YouTube URL\n        - 'error': error message if an exception occurs\n        \"\"\"\n        default_data = {\"transcript\": \"\", \"video_url\": self.url, \"error\": None}\n\n        try:\n            transcripts = self._load_transcripts(as_chunks=False)\n            if not transcripts:\n                default_data[\"error\"] = \"No transcripts found.\"\n                return Data(data=default_data)\n\n            # Combine all transcript parts\n            full_transcript = \" \".join(doc.page_content for doc in transcripts)\n            return Data(data={\"transcript\": full_transcript, \"video_url\": self.url})\n\n        except (\n            youtube_transcript_api.TranscriptsDisabled,\n            youtube_transcript_api.NoTranscriptFound,\n            youtube_transcript_api.CouldNotRetrieveTranscript,\n        ) as exc:\n            default_data[\"error\"] = str(exc)\n            return Data(data=default_data)\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "translation": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "",
          "en",
          "es",
          "fr",
          "de",
          "it",
          "pt",
          "ru",
          "ja",
          "ko",
          "hi",
          "ar",
          "id"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "translation",
        "value": "",
        "display_name": "Translation Language",
        "advanced": true,
        "dynamic": false,
        "info": "Translate the transcripts to the specified language. Leave empty for no translation.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "url": {
        "tool_mode": true,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "url",
        "value": "",
        "display_name": "Video URL",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Enter the YouTube video URL to get transcripts from.",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      }
    },
    "description": "Extracts spoken content from YouTube videos with multiple output options.",
    "icon": "YouTube",
    "base_classes": [
      "Data",
      "DataFrame",
      "Message"
    ],
    "display_name": "YouTube Transcripts",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "Chunks",
        "method": "get_dataframe_output",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "Message"
        ],
        "selected": "Message",
        "name": "message",
        "display_name": "Transcript",
        "method": "get_message_output",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "data_output",
        "display_name": "Transcript + Source",
        "method": "get_data_output",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "url",
      "chunk_size_seconds",
      "translation"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "YouTubePlaylistComponent": {
    "template": {
      "_type": "Component",
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from pytube import Playlist  # Ensure you have pytube installed\n\nfrom langflow.custom import Component\nfrom langflow.inputs import MessageTextInput\nfrom langflow.schema import Data, DataFrame\nfrom langflow.template import Output\n\n\nclass YouTubePlaylistComponent(Component):\n    display_name = \"Youtube Playlist\"\n    description = \"Extracts all video URLs from a YouTube playlist.\"\n    icon = \"YouTube\"  # Replace with a suitable icon\n\n    inputs = [\n        MessageTextInput(\n            name=\"playlist_url\",\n            display_name=\"Playlist URL\",\n            info=\"URL of the YouTube playlist.\",\n            required=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Video URLs\", name=\"video_urls\", method=\"extract_video_urls\"),\n    ]\n\n    def extract_video_urls(self) -> DataFrame:\n        playlist_url = self.playlist_url\n        playlist = Playlist(playlist_url)\n        video_urls = [video.watch_url for video in playlist.videos]\n\n        return DataFrame([Data(data={\"video_url\": url}) for url in video_urls])\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "playlist_url": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "playlist_url",
        "value": "",
        "display_name": "Playlist URL",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "URL of the YouTube playlist.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      }
    },
    "description": "Extracts all video URLs from a YouTube playlist.",
    "icon": "YouTube",
    "base_classes": [
      "DataFrame"
    ],
    "display_name": "Youtube Playlist",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "video_urls",
        "display_name": "Video URLs",
        "method": "extract_video_urls",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "playlist_url"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "YouTubeSearchComponent": {
    "template": {
      "_type": "Component",
      "api_key": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "api_key",
        "value": "",
        "display_name": "YouTube API Key",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "Your YouTube Data API key.",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from contextlib import contextmanager\n\nimport pandas as pd\nfrom googleapiclient.discovery import build\nfrom googleapiclient.errors import HttpError\n\nfrom langflow.custom import Component\nfrom langflow.inputs import BoolInput, DropdownInput, IntInput, MessageTextInput, SecretStrInput\nfrom langflow.schema import DataFrame\nfrom langflow.template import Output\n\n\nclass YouTubeSearchComponent(Component):\n    \"\"\"A component that searches YouTube videos.\"\"\"\n\n    display_name: str = \"YouTube Search\"\n    description: str = \"Searches YouTube videos based on query.\"\n    icon: str = \"YouTube\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"query\",\n            display_name=\"Search Query\",\n            info=\"The search query to look for on YouTube.\",\n            tool_mode=True,\n            required=True,\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"YouTube API Key\",\n            info=\"Your YouTube Data API key.\",\n            required=True,\n        ),\n        IntInput(\n            name=\"max_results\",\n            display_name=\"Max Results\",\n            value=10,\n            info=\"The maximum number of results to return.\",\n        ),\n        DropdownInput(\n            name=\"order\",\n            display_name=\"Sort Order\",\n            options=[\"relevance\", \"date\", \"rating\", \"title\", \"viewCount\"],\n            value=\"relevance\",\n            info=\"Sort order for the search results.\",\n        ),\n        BoolInput(\n            name=\"include_metadata\",\n            display_name=\"Include Metadata\",\n            value=True,\n            info=\"Include video metadata like description and statistics.\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(name=\"results\", display_name=\"Search Results\", method=\"search_videos\"),\n    ]\n\n    @contextmanager\n    def youtube_client(self):\n        \"\"\"Context manager for YouTube API client.\"\"\"\n        client = build(\"youtube\", \"v3\", developerKey=self.api_key)\n        try:\n            yield client\n        finally:\n            client.close()\n\n    def search_videos(self) -> DataFrame:\n        \"\"\"Searches YouTube videos and returns results as DataFrame.\"\"\"\n        try:\n            with self.youtube_client() as youtube:\n                search_response = (\n                    youtube.search()\n                    .list(\n                        q=self.query,\n                        part=\"id,snippet\",\n                        maxResults=self.max_results,\n                        order=self.order,\n                        type=\"video\",\n                    )\n                    .execute()\n                )\n\n                results = []\n                for search_result in search_response.get(\"items\", []):\n                    video_id = search_result[\"id\"][\"videoId\"]\n                    snippet = search_result[\"snippet\"]\n\n                    result = {\n                        \"video_id\": video_id,\n                        \"title\": snippet[\"title\"],\n                        \"description\": snippet[\"description\"],\n                        \"published_at\": snippet[\"publishedAt\"],\n                        \"channel_title\": snippet[\"channelTitle\"],\n                        \"thumbnail_url\": snippet[\"thumbnails\"][\"default\"][\"url\"],\n                    }\n\n                    if self.include_metadata:\n                        # Get video details for additional metadata\n                        video_response = youtube.videos().list(part=\"statistics,contentDetails\", id=video_id).execute()\n\n                        if video_response.get(\"items\"):\n                            video_details = video_response[\"items\"][0]\n                            result.update(\n                                {\n                                    \"view_count\": int(video_details[\"statistics\"][\"viewCount\"]),\n                                    \"like_count\": int(video_details[\"statistics\"].get(\"likeCount\", 0)),\n                                    \"comment_count\": int(video_details[\"statistics\"].get(\"commentCount\", 0)),\n                                    \"duration\": video_details[\"contentDetails\"][\"duration\"],\n                                }\n                            )\n\n                    results.append(result)\n\n                return DataFrame(pd.DataFrame(results))\n\n        except HttpError as e:\n            error_message = f\"YouTube API error: {e!s}\"\n            return DataFrame(pd.DataFrame({\"error\": [error_message]}))\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "include_metadata": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "include_metadata",
        "value": true,
        "display_name": "Include Metadata",
        "advanced": true,
        "dynamic": false,
        "info": "Include video metadata like description and statistics.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "max_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "max_results",
        "value": 10,
        "display_name": "Max Results",
        "advanced": false,
        "dynamic": false,
        "info": "The maximum number of results to return.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "order": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "relevance",
          "date",
          "rating",
          "title",
          "viewCount"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "order",
        "value": "relevance",
        "display_name": "Sort Order",
        "advanced": false,
        "dynamic": false,
        "info": "Sort order for the search results.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "query": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "query",
        "value": "",
        "display_name": "Search Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The search query to look for on YouTube.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      }
    },
    "description": "Searches YouTube videos based on query.",
    "icon": "YouTube",
    "base_classes": [
      "DataFrame"
    ],
    "display_name": "YouTube Search",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "results",
        "display_name": "Search Results",
        "method": "search_videos",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "query",
      "api_key",
      "max_results",
      "order",
      "include_metadata"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "YouTubeVideoDetailsComponent": {
    "template": {
      "_type": "Component",
      "api_key": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "api_key",
        "value": "",
        "display_name": "YouTube API Key",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "Your YouTube Data API key.",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from contextlib import contextmanager\n\nimport googleapiclient\nimport pandas as pd\nfrom googleapiclient.discovery import build\nfrom googleapiclient.errors import HttpError\n\nfrom langflow.custom import Component\nfrom langflow.inputs import BoolInput, MessageTextInput, SecretStrInput\nfrom langflow.schema import DataFrame\nfrom langflow.template import Output\n\n\nclass YouTubeVideoDetailsComponent(Component):\n    \"\"\"A component that retrieves detailed information about YouTube videos.\"\"\"\n\n    display_name: str = \"YouTube Video Details\"\n    description: str = \"Retrieves detailed information and statistics about YouTube videos.\"\n    icon: str = \"YouTube\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"video_url\",\n            display_name=\"Video URL\",\n            info=\"The URL of the YouTube video.\",\n            tool_mode=True,\n            required=True,\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"YouTube API Key\",\n            info=\"Your YouTube Data API key.\",\n            required=True,\n        ),\n        BoolInput(\n            name=\"include_statistics\",\n            display_name=\"Include Statistics\",\n            value=True,\n            info=\"Include video statistics (views, likes, comments).\",\n        ),\n        BoolInput(\n            name=\"include_content_details\",\n            display_name=\"Include Content Details\",\n            value=True,\n            info=\"Include video duration, quality, and age restriction info.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"include_tags\",\n            display_name=\"Include Tags\",\n            value=True,\n            info=\"Include video tags and keywords.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"include_thumbnails\",\n            display_name=\"Include Thumbnails\",\n            value=True,\n            info=\"Include video thumbnail URLs in different resolutions.\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(name=\"video_data\", display_name=\"Video Data\", method=\"get_video_details\"),\n    ]\n\n    API_FORBIDDEN = 403\n    VIDEO_NOT_FOUND = 404\n\n    @contextmanager\n    def youtube_client(self):\n        \"\"\"Context manager for YouTube API client.\"\"\"\n        client = build(\"youtube\", \"v3\", developerKey=self.api_key)\n        try:\n            yield client\n        finally:\n            client.close()\n\n    def _extract_video_id(self, video_url: str) -> str:\n        \"\"\"Extracts the video ID from a YouTube URL.\"\"\"\n        import re\n\n        patterns = [\n            r\"(?:youtube\\.com\\/watch\\?v=|youtu.be\\/|youtube.com\\/embed\\/)([^&\\n?#]+)\",\n            r\"youtube.com\\/shorts\\/([^&\\n?#]+)\",\n        ]\n\n        for pattern in patterns:\n            match = re.search(pattern, video_url)\n            if match:\n                return match.group(1)\n\n        return video_url.strip()\n\n    def _format_duration(self, duration: str) -> str:\n        \"\"\"Formats the ISO 8601 duration to a readable format.\"\"\"\n        import re\n\n        hours = 0\n        minutes = 0\n        seconds = 0\n\n        hours_match = re.search(r\"(\\d+)H\", duration)\n        minutes_match = re.search(r\"(\\d+)M\", duration)\n        seconds_match = re.search(r\"(\\d+)S\", duration)\n\n        if hours_match:\n            hours = int(hours_match.group(1))\n        if minutes_match:\n            minutes = int(minutes_match.group(1))\n        if seconds_match:\n            seconds = int(seconds_match.group(1))\n\n        if hours > 0:\n            return f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n        return f\"{minutes:02d}:{seconds:02d}\"\n\n    def get_video_details(self) -> DataFrame:\n        \"\"\"Retrieves detailed information about a YouTube video and returns as DataFrame.\"\"\"\n        try:\n            with self.youtube_client() as youtube:\n                # Extract video ID\n                video_id = self._extract_video_id(self.video_url)\n\n                # Prepare parts for the API request\n                parts = [\"snippet\"]\n                if self.include_statistics:\n                    parts.append(\"statistics\")\n                if self.include_content_details:\n                    parts.append(\"contentDetails\")\n\n                # Get video information\n                video_response = youtube.videos().list(part=\",\".join(parts), id=video_id).execute()\n\n                if not video_response[\"items\"]:\n                    return DataFrame(pd.DataFrame({\"error\": [\"Video not found\"]}))\n\n                video_info = video_response[\"items\"][0]\n                snippet = video_info[\"snippet\"]\n\n                # Build video data dictionary\n                video_data = {\n                    \"video_id\": [video_id],\n                    \"url\": [f\"https://www.youtube.com/watch?v={video_id}\"],\n                    \"title\": [snippet[\"title\"]],\n                    \"description\": [snippet[\"description\"]],\n                    \"published_at\": [snippet[\"publishedAt\"]],\n                    \"channel_id\": [snippet[\"channelId\"]],\n                    \"channel_title\": [snippet[\"channelTitle\"]],\n                    \"category_id\": [snippet.get(\"categoryId\", \"Unknown\")],\n                    \"live_broadcast_content\": [snippet.get(\"liveBroadcastContent\", \"none\")],\n                }\n\n                # Add thumbnails if requested\n                if self.include_thumbnails:\n                    for size, thumb in snippet[\"thumbnails\"].items():\n                        video_data[f\"thumbnail_{size}_url\"] = [thumb[\"url\"]]\n                        video_data[f\"thumbnail_{size}_width\"] = [thumb.get(\"width\", 0)]\n                        video_data[f\"thumbnail_{size}_height\"] = [thumb.get(\"height\", 0)]\n\n                # Add tags if requested\n                if self.include_tags and \"tags\" in snippet:\n                    video_data[\"tags\"] = [\", \".join(snippet[\"tags\"])]\n                    video_data[\"tags_count\"] = [len(snippet[\"tags\"])]\n\n                # Add statistics if requested\n                if self.include_statistics and \"statistics\" in video_info:\n                    stats = video_info[\"statistics\"]\n                    video_data.update(\n                        {\n                            \"view_count\": [int(stats.get(\"viewCount\", 0))],\n                            \"like_count\": [int(stats.get(\"likeCount\", 0))],\n                            \"favorite_count\": [int(stats.get(\"favoriteCount\", 0))],\n                            \"comment_count\": [int(stats.get(\"commentCount\", 0))],\n                        }\n                    )\n\n                # Add content details if requested\n                if self.include_content_details and \"contentDetails\" in video_info:\n                    content_details = video_info[\"contentDetails\"]\n                    video_data.update(\n                        {\n                            \"duration\": [self._format_duration(content_details[\"duration\"])],\n                            \"dimension\": [content_details.get(\"dimension\", \"2d\")],\n                            \"definition\": [content_details.get(\"definition\", \"hd\").upper()],\n                            \"has_captions\": [content_details.get(\"caption\", \"false\") == \"true\"],\n                            \"licensed_content\": [content_details.get(\"licensedContent\", False)],\n                            \"projection\": [content_details.get(\"projection\", \"rectangular\")],\n                            \"has_custom_thumbnails\": [content_details.get(\"hasCustomThumbnail\", False)],\n                        }\n                    )\n\n                    # Add content rating if available\n                    if \"contentRating\" in content_details:\n                        rating_info = content_details[\"contentRating\"]\n                        video_data[\"content_rating\"] = [str(rating_info)]\n\n                # Create DataFrame with organized columns\n                video_df = pd.DataFrame(video_data)\n\n                # Organize columns in logical groups\n                basic_cols = [\n                    \"video_id\",\n                    \"title\",\n                    \"url\",\n                    \"channel_id\",\n                    \"channel_title\",\n                    \"published_at\",\n                    \"category_id\",\n                    \"live_broadcast_content\",\n                    \"description\",\n                ]\n\n                stat_cols = [\"view_count\", \"like_count\", \"favorite_count\", \"comment_count\"]\n\n                content_cols = [\n                    \"duration\",\n                    \"dimension\",\n                    \"definition\",\n                    \"has_captions\",\n                    \"licensed_content\",\n                    \"projection\",\n                    \"has_custom_thumbnails\",\n                    \"content_rating\",\n                ]\n\n                tag_cols = [\"tags\", \"tags_count\"]\n\n                thumb_cols = [col for col in video_df.columns if col.startswith(\"thumbnail_\")]\n\n                # Reorder columns based on what's included\n                ordered_cols = basic_cols.copy()\n\n                if self.include_statistics:\n                    ordered_cols.extend([col for col in stat_cols if col in video_df.columns])\n\n                if self.include_content_details:\n                    ordered_cols.extend([col for col in content_cols if col in video_df.columns])\n\n                if self.include_tags:\n                    ordered_cols.extend([col for col in tag_cols if col in video_df.columns])\n\n                if self.include_thumbnails:\n                    ordered_cols.extend(sorted(thumb_cols))\n\n                # Add any remaining columns\n                remaining_cols = [col for col in video_df.columns if col not in ordered_cols]\n                ordered_cols.extend(remaining_cols)\n\n                return DataFrame(video_df[ordered_cols])\n\n        except (HttpError, googleapiclient.errors.HttpError) as e:\n            error_message = f\"YouTube API error: {e!s}\"\n            if e.resp.status == self.API_FORBIDDEN:\n                error_message = \"API quota exceeded or access forbidden.\"\n            elif e.resp.status == self.VIDEO_NOT_FOUND:\n                error_message = \"Video not found.\"\n\n            return DataFrame(pd.DataFrame({\"error\": [error_message]}))\n\n        except KeyError as e:\n            return DataFrame(pd.DataFrame({\"error\": [str(e)]}))\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "include_content_details": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "include_content_details",
        "value": true,
        "display_name": "Include Content Details",
        "advanced": true,
        "dynamic": false,
        "info": "Include video duration, quality, and age restriction info.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "include_statistics": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "include_statistics",
        "value": true,
        "display_name": "Include Statistics",
        "advanced": false,
        "dynamic": false,
        "info": "Include video statistics (views, likes, comments).",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "include_tags": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "include_tags",
        "value": true,
        "display_name": "Include Tags",
        "advanced": true,
        "dynamic": false,
        "info": "Include video tags and keywords.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "include_thumbnails": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "include_thumbnails",
        "value": true,
        "display_name": "Include Thumbnails",
        "advanced": true,
        "dynamic": false,
        "info": "Include video thumbnail URLs in different resolutions.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "video_url": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "video_url",
        "value": "",
        "display_name": "Video URL",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The URL of the YouTube video.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      }
    },
    "description": "Retrieves detailed information and statistics about YouTube videos.",
    "icon": "YouTube",
    "base_classes": [
      "DataFrame"
    ],
    "display_name": "YouTube Video Details",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "video_data",
        "display_name": "Video Data",
        "method": "get_video_details",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "video_url",
      "api_key",
      "include_statistics",
      "include_content_details",
      "include_tags",
      "include_thumbnails"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "YouTubeCommentsComponent": {
    "template": {
      "_type": "Component",
      "api_key": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "api_key",
        "value": "",
        "display_name": "YouTube API Key",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "Your YouTube Data API key.",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from contextlib import contextmanager\n\nimport pandas as pd\nfrom googleapiclient.discovery import build\nfrom googleapiclient.errors import HttpError\n\nfrom langflow.custom import Component\nfrom langflow.inputs import BoolInput, DropdownInput, IntInput, MessageTextInput, SecretStrInput\nfrom langflow.schema import DataFrame\nfrom langflow.template import Output\n\n\nclass YouTubeCommentsComponent(Component):\n    \"\"\"A component that retrieves comments from YouTube videos.\"\"\"\n\n    display_name: str = \"YouTube Comments\"\n    description: str = \"Retrieves and analyzes comments from YouTube videos.\"\n    icon: str = \"YouTube\"\n\n    # Constants\n    COMMENTS_DISABLED_STATUS = 403\n    NOT_FOUND_STATUS = 404\n    API_MAX_RESULTS = 100\n\n    inputs = [\n        MessageTextInput(\n            name=\"video_url\",\n            display_name=\"Video URL\",\n            info=\"The URL of the YouTube video to get comments from.\",\n            tool_mode=True,\n            required=True,\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"YouTube API Key\",\n            info=\"Your YouTube Data API key.\",\n            required=True,\n        ),\n        IntInput(\n            name=\"max_results\",\n            display_name=\"Max Results\",\n            value=20,\n            info=\"The maximum number of comments to return.\",\n        ),\n        DropdownInput(\n            name=\"sort_by\",\n            display_name=\"Sort By\",\n            options=[\"time\", \"relevance\"],\n            value=\"relevance\",\n            info=\"Sort comments by time or relevance.\",\n        ),\n        BoolInput(\n            name=\"include_replies\",\n            display_name=\"Include Replies\",\n            value=False,\n            info=\"Whether to include replies to comments.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"include_metrics\",\n            display_name=\"Include Metrics\",\n            value=True,\n            info=\"Include metrics like like count and reply count.\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(name=\"comments\", display_name=\"Comments\", method=\"get_video_comments\"),\n    ]\n\n    def _extract_video_id(self, video_url: str) -> str:\n        \"\"\"Extracts the video ID from a YouTube URL.\"\"\"\n        import re\n\n        patterns = [\n            r\"(?:youtube\\.com\\/watch\\?v=|youtu.be\\/|youtube.com\\/embed\\/)([^&\\n?#]+)\",\n            r\"youtube.com\\/shorts\\/([^&\\n?#]+)\",\n        ]\n\n        for pattern in patterns:\n            match = re.search(pattern, video_url)\n            if match:\n                return match.group(1)\n\n        return video_url.strip()\n\n    def _process_reply(self, reply: dict, parent_id: str, *, include_metrics: bool = True) -> dict:\n        \"\"\"Process a single reply comment.\"\"\"\n        reply_snippet = reply[\"snippet\"]\n        reply_data = {\n            \"comment_id\": reply[\"id\"],\n            \"parent_comment_id\": parent_id,\n            \"author\": reply_snippet[\"authorDisplayName\"],\n            \"text\": reply_snippet[\"textDisplay\"],\n            \"published_at\": reply_snippet[\"publishedAt\"],\n            \"is_reply\": True,\n        }\n        if include_metrics:\n            reply_data[\"like_count\"] = reply_snippet[\"likeCount\"]\n            reply_data[\"reply_count\"] = 0  # Replies can't have replies\n\n        return reply_data\n\n    def _process_comment(\n        self, item: dict, *, include_metrics: bool = True, include_replies: bool = False\n    ) -> list[dict]:\n        \"\"\"Process a single comment thread.\"\"\"\n        comment = item[\"snippet\"][\"topLevelComment\"][\"snippet\"]\n        comment_id = item[\"snippet\"][\"topLevelComment\"][\"id\"]\n\n        # Basic comment data\n        processed_comments = [\n            {\n                \"comment_id\": comment_id,\n                \"parent_comment_id\": \"\",  # Empty for top-level comments\n                \"author\": comment[\"authorDisplayName\"],\n                \"author_channel_url\": comment.get(\"authorChannelUrl\", \"\"),\n                \"text\": comment[\"textDisplay\"],\n                \"published_at\": comment[\"publishedAt\"],\n                \"updated_at\": comment[\"updatedAt\"],\n                \"is_reply\": False,\n            }\n        ]\n\n        # Add metrics if requested\n        if include_metrics:\n            processed_comments[0].update(\n                {\n                    \"like_count\": comment[\"likeCount\"],\n                    \"reply_count\": item[\"snippet\"][\"totalReplyCount\"],\n                }\n            )\n\n        # Add replies if requested\n        if include_replies and item[\"snippet\"][\"totalReplyCount\"] > 0 and \"replies\" in item:\n            for reply in item[\"replies\"][\"comments\"]:\n                reply_data = self._process_reply(reply, parent_id=comment_id, include_metrics=include_metrics)\n                processed_comments.append(reply_data)\n\n        return processed_comments\n\n    @contextmanager\n    def youtube_client(self):\n        \"\"\"Context manager for YouTube API client.\"\"\"\n        client = build(\"youtube\", \"v3\", developerKey=self.api_key)\n        try:\n            yield client\n        finally:\n            client.close()\n\n    def get_video_comments(self) -> DataFrame:\n        \"\"\"Retrieves comments from a YouTube video and returns as DataFrame.\"\"\"\n        try:\n            # Extract video ID from URL\n            video_id = self._extract_video_id(self.video_url)\n\n            # Use context manager for YouTube API client\n            with self.youtube_client() as youtube:\n                comments_data = []\n                results_count = 0\n                request = youtube.commentThreads().list(\n                    part=\"snippet,replies\",\n                    videoId=video_id,\n                    maxResults=min(self.API_MAX_RESULTS, self.max_results),\n                    order=self.sort_by,\n                    textFormat=\"plainText\",\n                )\n\n                while request and results_count < self.max_results:\n                    response = request.execute()\n\n                    for item in response.get(\"items\", []):\n                        if results_count >= self.max_results:\n                            break\n\n                        comments = self._process_comment(\n                            item, include_metrics=self.include_metrics, include_replies=self.include_replies\n                        )\n                        comments_data.extend(comments)\n                        results_count += 1\n\n                    # Get the next page if available and needed\n                    if \"nextPageToken\" in response and results_count < self.max_results:\n                        request = youtube.commentThreads().list(\n                            part=\"snippet,replies\",\n                            videoId=video_id,\n                            maxResults=min(self.API_MAX_RESULTS, self.max_results - results_count),\n                            order=self.sort_by,\n                            textFormat=\"plainText\",\n                            pageToken=response[\"nextPageToken\"],\n                        )\n                    else:\n                        request = None\n\n                # Convert to DataFrame\n                comments_df = pd.DataFrame(comments_data)\n\n                # Add video metadata\n                comments_df[\"video_id\"] = video_id\n                comments_df[\"video_url\"] = self.video_url\n\n                # Sort columns for better organization\n                column_order = [\n                    \"video_id\",\n                    \"video_url\",\n                    \"comment_id\",\n                    \"parent_comment_id\",\n                    \"is_reply\",\n                    \"author\",\n                    \"author_channel_url\",\n                    \"text\",\n                    \"published_at\",\n                    \"updated_at\",\n                ]\n\n                if self.include_metrics:\n                    column_order.extend([\"like_count\", \"reply_count\"])\n\n                comments_df = comments_df[column_order]\n\n                return DataFrame(comments_df)\n\n        except HttpError as e:\n            error_message = f\"YouTube API error: {e!s}\"\n            if e.resp.status == self.COMMENTS_DISABLED_STATUS:\n                error_message = \"Comments are disabled for this video or API quota exceeded.\"\n            elif e.resp.status == self.NOT_FOUND_STATUS:\n                error_message = \"Video not found.\"\n\n            return DataFrame(pd.DataFrame({\"error\": [error_message]}))\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "include_metrics": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "include_metrics",
        "value": true,
        "display_name": "Include Metrics",
        "advanced": true,
        "dynamic": false,
        "info": "Include metrics like like count and reply count.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "include_replies": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "include_replies",
        "value": false,
        "display_name": "Include Replies",
        "advanced": true,
        "dynamic": false,
        "info": "Whether to include replies to comments.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "max_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "max_results",
        "value": 20,
        "display_name": "Max Results",
        "advanced": false,
        "dynamic": false,
        "info": "The maximum number of comments to return.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "sort_by": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "time",
          "relevance"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "sort_by",
        "value": "relevance",
        "display_name": "Sort By",
        "advanced": false,
        "dynamic": false,
        "info": "Sort comments by time or relevance.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "video_url": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "video_url",
        "value": "",
        "display_name": "Video URL",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The URL of the YouTube video to get comments from.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      }
    },
    "description": "Retrieves and analyzes comments from YouTube videos.",
    "icon": "YouTube",
    "base_classes": [
      "DataFrame"
    ],
    "display_name": "YouTube Comments",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "comments",
        "display_name": "Comments",
        "method": "get_video_comments",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "video_url",
      "api_key",
      "max_results",
      "sort_by",
      "include_replies",
      "include_metrics"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  }
}