{
  "GleanSearchAPIComponent": {
    "template": {
      "_type": "Component",
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "import json\nfrom typing import Any\nfrom urllib.parse import urljoin\n\nimport httpx\nfrom langchain_core.tools import StructuredTool, ToolException\nfrom pydantic import BaseModel\nfrom pydantic.v1 import Field\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import IntInput, MultilineInput, NestedDictInput, SecretStrInput, StrInput\nfrom langflow.io import Output\nfrom langflow.schema import Data, DataFrame\n\n\nclass GleanSearchAPISchema(BaseModel):\n    query: str = Field(..., description=\"The search query\")\n    page_size: int = Field(10, description=\"Maximum number of results to return\")\n    request_options: dict[str, Any] | None = Field(default_factory=dict, description=\"Request Options\")\n\n\nclass GleanAPIWrapper(BaseModel):\n    \"\"\"Wrapper around Glean API.\"\"\"\n\n    glean_api_url: str\n    glean_access_token: str\n    act_as: str = \"langflow-component@datastax.com\"  # TODO: Detect this\n\n    def _prepare_request(\n        self,\n        query: str,\n        page_size: int = 10,\n        request_options: dict[str, Any] | None = None,\n    ) -> dict:\n        # Ensure there's a trailing slash\n        url = self.glean_api_url\n        if not url.endswith(\"/\"):\n            url += \"/\"\n\n        return {\n            \"url\": urljoin(url, \"search\"),\n            \"headers\": {\n                \"Authorization\": f\"Bearer {self.glean_access_token}\",\n                \"X-Scio-ActAs\": self.act_as,\n            },\n            \"payload\": {\n                \"query\": query,\n                \"pageSize\": page_size,\n                \"requestOptions\": request_options,\n            },\n        }\n\n    def results(self, query: str, **kwargs: Any) -> list[dict[str, Any]]:\n        results = self._search_api_results(query, **kwargs)\n\n        if len(results) == 0:\n            msg = \"No good Glean Search Result was found\"\n            raise AssertionError(msg)\n\n        return results\n\n    def run(self, query: str, **kwargs: Any) -> list[dict[str, Any]]:\n        try:\n            results = self.results(query, **kwargs)\n\n            processed_results = []\n            for result in results:\n                if \"title\" in result:\n                    result[\"snippets\"] = result.get(\"snippets\", [{\"snippet\": {\"text\": result[\"title\"]}}])\n                    if \"text\" not in result[\"snippets\"][0]:\n                        result[\"snippets\"][0][\"text\"] = result[\"title\"]\n\n                processed_results.append(result)\n        except Exception as e:\n            error_message = f\"Error in Glean Search API: {e!s}\"\n            raise ToolException(error_message) from e\n\n        return processed_results\n\n    def _search_api_results(self, query: str, **kwargs: Any) -> list[dict[str, Any]]:\n        request_details = self._prepare_request(query, **kwargs)\n\n        response = httpx.post(\n            request_details[\"url\"],\n            json=request_details[\"payload\"],\n            headers=request_details[\"headers\"],\n        )\n\n        response.raise_for_status()\n        response_json = response.json()\n\n        return response_json.get(\"results\", [])\n\n    @staticmethod\n    def _result_as_string(result: dict) -> str:\n        return json.dumps(result, indent=4)\n\n\nclass GleanSearchAPIComponent(LCToolComponent):\n    display_name: str = \"Glean Search API\"\n    description: str = \"Search using Glean's API.\"\n    documentation: str = \"https://docs.langflow.org/Components/components-tools#glean-search-api\"\n    icon: str = \"Glean\"\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"run_model\"),\n        Output(display_name=\"DataFrame\", name=\"dataframe\", method=\"as_dataframe\"),\n    ]\n\n    inputs = [\n        StrInput(name=\"glean_api_url\", display_name=\"Glean API URL\", required=True),\n        SecretStrInput(name=\"glean_access_token\", display_name=\"Glean Access Token\", required=True),\n        MultilineInput(name=\"query\", display_name=\"Query\", required=True, tool_mode=True),\n        IntInput(name=\"page_size\", display_name=\"Page Size\", value=10),\n        NestedDictInput(name=\"request_options\", display_name=\"Request Options\", required=False),\n    ]\n\n    def build_tool(self) -> Tool:\n        wrapper = self._build_wrapper(\n            glean_api_url=self.glean_api_url,\n            glean_access_token=self.glean_access_token,\n        )\n\n        tool = StructuredTool.from_function(\n            name=\"glean_search_api\",\n            description=\"Search Glean for relevant results.\",\n            func=wrapper.run,\n            args_schema=GleanSearchAPISchema,\n        )\n\n        self.status = \"Glean Search API Tool for Langchain\"\n\n        return tool\n\n    def run_model(self) -> list[Data]:\n        tool = self.build_tool()\n\n        results = tool.run(\n            {\n                \"query\": self.query,\n                \"page_size\": self.page_size,\n                \"request_options\": self.request_options,\n            }\n        )\n\n        # Build the data\n        data = [Data(data=result, text=result[\"snippets\"][0][\"text\"]) for result in results]\n        self.status = data  # type: ignore[assignment]\n\n        return data\n\n    def _build_wrapper(\n        self,\n        glean_api_url: str,\n        glean_access_token: str,\n    ):\n        return GleanAPIWrapper(\n            glean_api_url=glean_api_url,\n            glean_access_token=glean_access_token,\n        )\n\n    def as_dataframe(self) -> DataFrame:\n        \"\"\"Convert the Glean search results to a DataFrame.\n\n        Returns:\n            DataFrame: A DataFrame containing the search results.\n        \"\"\"\n        data = self.run_model()\n        if isinstance(data, list):\n            return DataFrame(data=[d.data for d in data])\n        return DataFrame(data=[data.data])\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "glean_access_token": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "glean_access_token",
        "value": "",
        "display_name": "Glean Access Token",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "glean_api_url": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "glean_api_url",
        "value": "",
        "display_name": "Glean API URL",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "page_size": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "page_size",
        "value": 10,
        "display_name": "Page Size",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "query": {
        "tool_mode": true,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "query",
        "value": "",
        "display_name": "Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "request_options": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "request_options",
        "value": {},
        "display_name": "Request Options",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "NestedDict",
        "_input_type": "NestedDictInput"
      }
    },
    "description": "Search using Glean's API.",
    "icon": "Glean",
    "base_classes": [
      "Data",
      "DataFrame"
    ],
    "display_name": "Glean Search API",
    "documentation": "https://docs.langflow.org/Components/components-tools#glean-search-api",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "data",
        "display_name": "Data",
        "method": "run_model",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "glean_api_url",
      "glean_access_token",
      "query",
      "page_size",
      "request_options"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "AstraDBCQLToolComponent": {
    "template": {
      "_type": "Component",
      "api_endpoint": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "api_endpoint",
        "value": "ASTRA_DB_API_ENDPOINT",
        "display_name": "API Endpoint",
        "advanced": false,
        "dynamic": false,
        "info": "API endpoint URL for the Astra DB service.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "clustering_keys": {
        "tool_mode": false,
        "trace_as_input": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "clustering_keys",
        "value": {},
        "display_name": "DEPRECATED: Clustering Keys",
        "advanced": true,
        "dynamic": false,
        "info": "Field name and description to the model",
        "title_case": false,
        "type": "dict",
        "_input_type": "DictInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "import json\nimport urllib\nfrom datetime import datetime, timezone\nfrom http import HTTPStatus\nfrom typing import Any\n\nimport requests\nfrom langchain.pydantic_v1 import BaseModel, Field, create_model\nfrom langchain_core.tools import StructuredTool, Tool\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.io import DictInput, IntInput, SecretStrInput, StrInput, TableInput\nfrom langflow.logging import logger\nfrom langflow.schema import Data\nfrom langflow.schema.table import EditMode\n\n\nclass AstraDBCQLToolComponent(LCToolComponent):\n    display_name: str = \"Astra DB CQL\"\n    description: str = \"Create a tool to get transactional data from DataStax Astra DB CQL Table\"\n    documentation: str = \"https://docs.langflow.org/Components/components-tools#astra-db-cql-tool\"\n    icon: str = \"AstraDB\"\n\n    inputs = [\n        StrInput(name=\"tool_name\", display_name=\"Tool Name\", info=\"The name of the tool.\", required=True),\n        StrInput(\n            name=\"tool_description\",\n            display_name=\"Tool Description\",\n            info=\"The tool description to be passed to the model.\",\n            required=True,\n        ),\n        StrInput(\n            name=\"keyspace\",\n            display_name=\"Keyspace\",\n            value=\"default_keyspace\",\n            info=\"The keyspace name within Astra DB where the data is stored.\",\n            required=True,\n            advanced=True,\n        ),\n        StrInput(\n            name=\"table_name\",\n            display_name=\"Table Name\",\n            info=\"The name of the table within Astra DB where the data is stored.\",\n            required=True,\n        ),\n        SecretStrInput(\n            name=\"token\",\n            display_name=\"Astra DB Application Token\",\n            info=\"Authentication token for accessing Astra DB.\",\n            value=\"ASTRA_DB_APPLICATION_TOKEN\",\n            required=True,\n        ),\n        StrInput(\n            name=\"api_endpoint\",\n            display_name=\"API Endpoint\",\n            info=\"API endpoint URL for the Astra DB service.\",\n            value=\"ASTRA_DB_API_ENDPOINT\",\n            required=True,\n        ),\n        StrInput(\n            name=\"projection_fields\",\n            display_name=\"Projection fields\",\n            info=\"Attributes to return separated by comma.\",\n            required=True,\n            value=\"*\",\n            advanced=True,\n        ),\n        TableInput(\n            name=\"tools_params\",\n            display_name=\"Tools Parameters\",\n            info=\"Define the structure for the tool parameters. Describe the parameters \"\n            \"in a way the LLM can understand how to use them. Add the parameters \"\n            \"respecting the table schema (Partition Keys, Clustering Keys and Indexed Fields).\",\n            required=False,\n            table_schema=[\n                {\n                    \"name\": \"name\",\n                    \"display_name\": \"Name\",\n                    \"type\": \"str\",\n                    \"description\": \"Name of the field/parameter to be used by the model.\",\n                    \"default\": \"field\",\n                    \"edit_mode\": EditMode.INLINE,\n                },\n                {\n                    \"name\": \"field_name\",\n                    \"display_name\": \"Field Name\",\n                    \"type\": \"str\",\n                    \"description\": \"Specify the column name to be filtered on the table. \"\n                    \"Leave empty if the attribute name is the same as the name of the field.\",\n                    \"default\": \"\",\n                    \"edit_mode\": EditMode.INLINE,\n                },\n                {\n                    \"name\": \"description\",\n                    \"display_name\": \"Description\",\n                    \"type\": \"str\",\n                    \"description\": \"Describe the purpose of the parameter.\",\n                    \"default\": \"description of tool parameter\",\n                    \"edit_mode\": EditMode.POPOVER,\n                },\n                {\n                    \"name\": \"mandatory\",\n                    \"display_name\": \"Is Mandatory\",\n                    \"type\": \"boolean\",\n                    \"edit_mode\": EditMode.INLINE,\n                    \"description\": (\"Indicate if the field is mandatory.\"),\n                    \"options\": [\"True\", \"False\"],\n                    \"default\": \"False\",\n                },\n                {\n                    \"name\": \"is_timestamp\",\n                    \"display_name\": \"Is Timestamp\",\n                    \"type\": \"boolean\",\n                    \"edit_mode\": EditMode.INLINE,\n                    \"description\": (\"Indicate if the field is a timestamp.\"),\n                    \"options\": [\"True\", \"False\"],\n                    \"default\": \"False\",\n                },\n                {\n                    \"name\": \"operator\",\n                    \"display_name\": \"Operator\",\n                    \"type\": \"str\",\n                    \"description\": \"Set the operator for the field. \"\n                    \"https://docs.datastax.com/en/astra-db-serverless/api-reference/documents.html#operators\",\n                    \"default\": \"$eq\",\n                    \"options\": [\"$gt\", \"$gte\", \"$lt\", \"$lte\", \"$eq\", \"$ne\", \"$in\", \"$nin\", \"$exists\", \"$all\", \"$size\"],\n                    \"edit_mode\": EditMode.INLINE,\n                },\n            ],\n            value=[],\n        ),\n        DictInput(\n            name=\"partition_keys\",\n            display_name=\"DEPRECATED: Partition Keys\",\n            is_list=True,\n            info=\"Field name and description to the model\",\n            required=False,\n            advanced=True,\n        ),\n        DictInput(\n            name=\"clustering_keys\",\n            display_name=\"DEPRECATED: Clustering Keys\",\n            is_list=True,\n            info=\"Field name and description to the model\",\n            required=False,\n            advanced=True,\n        ),\n        DictInput(\n            name=\"static_filters\",\n            display_name=\"Static Filters\",\n            is_list=True,\n            advanced=True,\n            info=\"Field name and value. When filled, it will not be generated by the LLM.\",\n        ),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            advanced=True,\n            value=5,\n        ),\n    ]\n\n    def parse_timestamp(self, timestamp_str: str) -> str:\n        \"\"\"Parse a timestamp string into Astra DB REST API format.\n\n        Args:\n            timestamp_str (str): Input timestamp string\n\n        Returns:\n            str: Formatted timestamp string in YYYY-MM-DDTHH:MI:SS.000Z format\n\n        Raises:\n            ValueError: If the timestamp cannot be parsed\n        \"\"\"\n        # Common datetime formats to try\n        formats = [\n            \"%Y-%m-%d\",  # 2024-03-21\n            \"%Y-%m-%dT%H:%M:%S\",  # 2024-03-21T15:30:00\n            \"%Y-%m-%dT%H:%M:%S%z\",  # 2024-03-21T15:30:00+0000\n            \"%Y-%m-%d %H:%M:%S\",  # 2024-03-21 15:30:00\n            \"%d/%m/%Y\",  # 21/03/2024\n            \"%Y/%m/%d\",  # 2024/03/21\n        ]\n\n        for fmt in formats:\n            try:\n                # Parse the date string\n                date_obj = datetime.strptime(timestamp_str, fmt).astimezone()\n\n                # If the parsed date has no timezone info, assume UTC\n                if date_obj.tzinfo is None:\n                    date_obj = date_obj.replace(tzinfo=timezone.utc)\n\n                # Convert to UTC and format\n                utc_date = date_obj.astimezone(timezone.utc)\n                return utc_date.strftime(\"%Y-%m-%dT%H:%M:%S.000Z\")\n            except ValueError:\n                continue\n\n        msg = f\"Could not parse date: {timestamp_str}\"\n        logger.error(msg)\n        raise ValueError(msg)\n\n    def astra_rest(self, args):\n        headers = {\"Accept\": \"application/json\", \"X-Cassandra-Token\": f\"{self.token}\"}\n        astra_url = f\"{self.api_endpoint}/api/rest/v2/keyspaces/{self.keyspace}/{self.table_name}/\"\n        where = {}\n\n        for param in self.tools_params:\n            field_name = param[\"field_name\"] if param[\"field_name\"] else param[\"name\"]\n            field_value = None\n\n            if field_name in self.static_filters:\n                field_value = self.static_filters[field_name]\n            elif param[\"name\"] in args:\n                field_value = args[param[\"name\"]]\n\n            if field_value is None:\n                continue\n\n            if param[\"is_timestamp\"] == True:  # noqa: E712\n                try:\n                    field_value = self.parse_timestamp(field_value)\n                except ValueError as e:\n                    msg = f\"Error parsing timestamp: {e} - Use the prompt to specify the date in the correct format\"\n                    logger.error(msg)\n                    raise ValueError(msg) from e\n\n            if param[\"operator\"] == \"$exists\":\n                where[field_name] = {**where.get(field_name, {}), param[\"operator\"]: True}\n            elif param[\"operator\"] in [\"$in\", \"$nin\", \"$all\"]:\n                where[field_name] = {\n                    **where.get(field_name, {}),\n                    param[\"operator\"]: field_value.split(\",\") if isinstance(field_value, str) else field_value,\n                }\n            else:\n                where[field_name] = {**where.get(field_name, {}), param[\"operator\"]: field_value}\n\n        url = f\"{astra_url}?page-size={self.number_of_results}\"\n        url += f\"&where={json.dumps(where)}\"\n\n        if self.projection_fields != \"*\":\n            url += f\"&fields={urllib.parse.quote(self.projection_fields.replace(' ', ''))}\"\n\n        res = requests.request(\"GET\", url=url, headers=headers, timeout=10)\n\n        if int(res.status_code) >= HTTPStatus.BAD_REQUEST:\n            msg = f\"Error on Astra DB CQL Tool {self.tool_name} request: {res.text}\"\n            logger.error(msg)\n            raise ValueError(msg)\n\n        try:\n            res_data = res.json()\n            return res_data[\"data\"]\n        except ValueError:\n            return res.status_code\n\n    def create_args_schema(self) -> dict[str, BaseModel]:\n        args: dict[str, tuple[Any, Field]] = {}\n\n        for param in self.tools_params:\n            field_name = param[\"field_name\"] if param[\"field_name\"] else param[\"name\"]\n            if field_name not in self.static_filters:\n                if param[\"mandatory\"]:\n                    args[param[\"name\"]] = (str, Field(description=param[\"description\"]))\n                else:\n                    args[param[\"name\"]] = (str | None, Field(description=param[\"description\"], default=None))\n\n        model = create_model(\"ToolInput\", **args, __base__=BaseModel)\n        return {\"ToolInput\": model}\n\n    def build_tool(self) -> Tool:\n        \"\"\"Builds a Astra DB CQL Table tool.\n\n        Args:\n            name (str, optional): The name of the tool.\n\n        Returns:\n            Tool: The built AstraDB tool.\n        \"\"\"\n        schema_dict = self.create_args_schema()\n        return StructuredTool.from_function(\n            name=self.tool_name,\n            args_schema=schema_dict[\"ToolInput\"],\n            description=self.tool_description,\n            func=self.run_model,\n            return_direct=False,\n        )\n\n    def projection_args(self, input_str: str) -> dict:\n        elements = input_str.split(\",\")\n        result = {}\n\n        for element in elements:\n            if element.startswith(\"!\"):\n                result[element[1:]] = False\n            else:\n                result[element] = True\n\n        return result\n\n    def run_model(self, **args) -> Data | list[Data]:\n        results = self.astra_rest(args)\n        data: list[Data] = []\n\n        if isinstance(results, list):\n            data = [Data(data=doc) for doc in results]\n        else:\n            self.status = results\n            return []\n\n        self.status = data\n        return data\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "keyspace": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "keyspace",
        "value": "default_keyspace",
        "display_name": "Keyspace",
        "advanced": true,
        "dynamic": false,
        "info": "The keyspace name within Astra DB where the data is stored.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "number_of_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "number_of_results",
        "value": 5,
        "display_name": "Number of Results",
        "advanced": true,
        "dynamic": false,
        "info": "Number of results to return.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "partition_keys": {
        "tool_mode": false,
        "trace_as_input": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "partition_keys",
        "value": {},
        "display_name": "DEPRECATED: Partition Keys",
        "advanced": true,
        "dynamic": false,
        "info": "Field name and description to the model",
        "title_case": false,
        "type": "dict",
        "_input_type": "DictInput"
      },
      "projection_fields": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "projection_fields",
        "value": "*",
        "display_name": "Projection fields",
        "advanced": true,
        "dynamic": false,
        "info": "Attributes to return separated by comma.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "static_filters": {
        "tool_mode": false,
        "trace_as_input": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "static_filters",
        "value": {},
        "display_name": "Static Filters",
        "advanced": true,
        "dynamic": false,
        "info": "Field name and value. When filled, it will not be generated by the LLM.",
        "title_case": false,
        "type": "dict",
        "_input_type": "DictInput"
      },
      "table_name": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "table_name",
        "value": "",
        "display_name": "Table Name",
        "advanced": false,
        "dynamic": false,
        "info": "The name of the table within Astra DB where the data is stored.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "token": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "token",
        "value": "ASTRA_DB_APPLICATION_TOKEN",
        "display_name": "Astra DB Application Token",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "Authentication token for accessing Astra DB.",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "tool_description": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "tool_description",
        "value": "",
        "display_name": "Tool Description",
        "advanced": false,
        "dynamic": false,
        "info": "The tool description to be passed to the model.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "tool_name": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "tool_name",
        "value": "",
        "display_name": "Tool Name",
        "advanced": false,
        "dynamic": false,
        "info": "The name of the tool.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "tools_params": {
        "tool_mode": false,
        "is_list": true,
        "list_add_label": "Add More",
        "table_schema": {
          "columns": [
            {
              "name": "name",
              "display_name": "Name",
              "sortable": true,
              "filterable": true,
              "formatter": "text",
              "type": "str",
              "description": "Name of the field/parameter to be used by the model.",
              "default": "field",
              "disable_edit": false,
              "edit_mode": "inline",
              "hidden": false
            },
            {
              "name": "field_name",
              "display_name": "Field Name",
              "sortable": true,
              "filterable": true,
              "formatter": "text",
              "type": "str",
              "description": "Specify the column name to be filtered on the table. Leave empty if the attribute name is the same as the name of the field.",
              "default": "",
              "disable_edit": false,
              "edit_mode": "inline",
              "hidden": false
            },
            {
              "name": "description",
              "display_name": "Description",
              "sortable": true,
              "filterable": true,
              "formatter": "text",
              "type": "str",
              "description": "Describe the purpose of the parameter.",
              "default": "description of tool parameter",
              "disable_edit": false,
              "edit_mode": "popover",
              "hidden": false
            },
            {
              "name": "mandatory",
              "display_name": "Is Mandatory",
              "options": [
                "True",
                "False"
              ],
              "sortable": true,
              "filterable": true,
              "formatter": "boolean",
              "type": "boolean",
              "description": "Indicate if the field is mandatory.",
              "default": false,
              "disable_edit": false,
              "edit_mode": "inline",
              "hidden": false
            },
            {
              "name": "is_timestamp",
              "display_name": "Is Timestamp",
              "options": [
                "True",
                "False"
              ],
              "sortable": true,
              "filterable": true,
              "formatter": "boolean",
              "type": "boolean",
              "description": "Indicate if the field is a timestamp.",
              "default": false,
              "disable_edit": false,
              "edit_mode": "inline",
              "hidden": false
            },
            {
              "name": "operator",
              "display_name": "Operator",
              "options": [
                "$gt",
                "$gte",
                "$lt",
                "$lte",
                "$eq",
                "$ne",
                "$in",
                "$nin",
                "$exists",
                "$all",
                "$size"
              ],
              "sortable": true,
              "filterable": true,
              "formatter": "text",
              "type": "str",
              "description": "Set the operator for the field. https://docs.datastax.com/en/astra-db-serverless/api-reference/documents.html#operators",
              "default": "$eq",
              "disable_edit": false,
              "edit_mode": "inline",
              "hidden": false
            }
          ]
        },
        "trigger_text": "Open table",
        "trigger_icon": "Table",
        "table_icon": "Table",
        "trace_as_metadata": true,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "tools_params",
        "value": [],
        "display_name": "Tools Parameters",
        "advanced": false,
        "dynamic": false,
        "info": "Define the structure for the tool parameters. Describe the parameters in a way the LLM can understand how to use them. Add the parameters respecting the table schema (Partition Keys, Clustering Keys and Indexed Fields).",
        "title_case": false,
        "type": "table",
        "_input_type": "TableInput"
      }
    },
    "description": "Create a tool to get transactional data from DataStax Astra DB CQL Table",
    "icon": "AstraDB",
    "base_classes": [
      "Data",
      "Tool"
    ],
    "display_name": "Astra DB CQL",
    "documentation": "https://docs.langflow.org/Components/components-tools#astra-db-cql-tool",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "api_run_model",
        "display_name": "Data",
        "method": "run_model",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "api_endpoint",
          "keyspace",
          "projection_fields",
          "table_name",
          "token",
          "tool_description",
          "tool_name"
        ],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "Tool"
        ],
        "selected": "Tool",
        "name": "api_build_tool",
        "display_name": "Tool",
        "method": "build_tool",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "api_endpoint",
          "keyspace",
          "projection_fields",
          "table_name",
          "token",
          "tool_description",
          "tool_name"
        ],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "tool_name",
      "tool_description",
      "keyspace",
      "table_name",
      "token",
      "api_endpoint",
      "projection_fields",
      "tools_params",
      "partition_keys",
      "clustering_keys",
      "static_filters",
      "number_of_results"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "BingSearchAPI": {
    "template": {
      "_type": "Component",
      "bing_search_url": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "bing_search_url",
        "value": "",
        "display_name": "Bing Search URL",
        "advanced": true,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "bing_subscription_key": {
        "load_from_db": true,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "bing_subscription_key",
        "value": "",
        "display_name": "Bing Subscription Key",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from typing import cast\n\nfrom langchain_community.tools.bing_search import BingSearchResults\nfrom langchain_community.utilities import BingSearchAPIWrapper\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import IntInput, MessageTextInput, MultilineInput, SecretStrInput\nfrom langflow.schema import Data\n\n\nclass BingSearchAPIComponent(LCToolComponent):\n    display_name = \"Bing Search API\"\n    description = \"Call the Bing Search API.\"\n    name = \"BingSearchAPI\"\n    icon = \"Bing\"\n\n    inputs = [\n        SecretStrInput(name=\"bing_subscription_key\", display_name=\"Bing Subscription Key\"),\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input\",\n        ),\n        MessageTextInput(name=\"bing_search_url\", display_name=\"Bing Search URL\", advanced=True),\n        IntInput(name=\"k\", display_name=\"Number of results\", value=4, required=True),\n    ]\n\n    def run_model(self) -> list[Data]:\n        if self.bing_search_url:\n            wrapper = BingSearchAPIWrapper(\n                bing_search_url=self.bing_search_url, bing_subscription_key=self.bing_subscription_key\n            )\n        else:\n            wrapper = BingSearchAPIWrapper(bing_subscription_key=self.bing_subscription_key)\n        results = wrapper.results(query=self.input_value, num_results=self.k)\n        data = [Data(data=result, text=result[\"snippet\"]) for result in results]\n        self.status = data\n        return data\n\n    def build_tool(self) -> Tool:\n        if self.bing_search_url:\n            wrapper = BingSearchAPIWrapper(\n                bing_search_url=self.bing_search_url, bing_subscription_key=self.bing_subscription_key\n            )\n        else:\n            wrapper = BingSearchAPIWrapper(bing_subscription_key=self.bing_subscription_key)\n        return cast(\"Tool\", BingSearchResults(api_wrapper=wrapper, num_results=self.k))\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "input_value": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "input_value",
        "value": "",
        "display_name": "Input",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "k": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "k",
        "value": 4,
        "display_name": "Number of results",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      }
    },
    "description": "Call the Bing Search API.",
    "icon": "Bing",
    "base_classes": [
      "Data",
      "Tool"
    ],
    "display_name": "Bing Search API",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "api_run_model",
        "display_name": "Data",
        "method": "run_model",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "k"
        ],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "Tool"
        ],
        "selected": "Tool",
        "name": "api_build_tool",
        "display_name": "Tool",
        "method": "build_tool",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "k"
        ],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "bing_subscription_key",
      "input_value",
      "bing_search_url",
      "k"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "Serp": {
    "template": {
      "_type": "Component",
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from typing import Any\n\nfrom langchain_community.utilities.serpapi import SerpAPIWrapper\nfrom langchain_core.tools import ToolException\nfrom loguru import logger\nfrom pydantic import BaseModel, Field\n\nfrom langflow.custom import Component\nfrom langflow.inputs import DictInput, IntInput, MultilineInput, SecretStrInput\nfrom langflow.io import Output\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\n\n\nclass SerpAPISchema(BaseModel):\n    \"\"\"Schema for SerpAPI search parameters.\"\"\"\n\n    query: str = Field(..., description=\"The search query\")\n    params: dict[str, Any] | None = Field(\n        default={\n            \"engine\": \"google\",\n            \"google_domain\": \"google.com\",\n            \"gl\": \"us\",\n            \"hl\": \"en\",\n        },\n        description=\"Additional search parameters\",\n    )\n    max_results: int = Field(5, description=\"Maximum number of results to return\")\n    max_snippet_length: int = Field(100, description=\"Maximum length of each result snippet\")\n\n\nclass SerpComponent(Component):\n    display_name = \"Serp Search API\"\n    description = \"Call Serp Search API with result limiting\"\n    name = \"Serp\"\n    icon = \"SerpSearch\"\n\n    inputs = [\n        SecretStrInput(name=\"serpapi_api_key\", display_name=\"SerpAPI API Key\", required=True),\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input\",\n            tool_mode=True,\n        ),\n        DictInput(name=\"search_params\", display_name=\"Parameters\", advanced=True, is_list=True),\n        IntInput(name=\"max_results\", display_name=\"Max Results\", value=5, advanced=True),\n        IntInput(name=\"max_snippet_length\", display_name=\"Max Snippet Length\", value=100, advanced=True),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"fetch_content\"),\n        Output(display_name=\"Text\", name=\"text\", method=\"fetch_content_text\"),\n    ]\n\n    def _build_wrapper(self, params: dict[str, Any] | None = None) -> SerpAPIWrapper:\n        \"\"\"Build a SerpAPIWrapper with the provided parameters.\"\"\"\n        params = params or {}\n        if params:\n            return SerpAPIWrapper(\n                serpapi_api_key=self.serpapi_api_key,\n                params=params,\n            )\n        return SerpAPIWrapper(serpapi_api_key=self.serpapi_api_key)\n\n    def run_model(self) -> list[Data]:\n        return self.fetch_content()\n\n    def fetch_content(self) -> list[Data]:\n        wrapper = self._build_wrapper(self.search_params)\n\n        def search_func(\n            query: str, params: dict[str, Any] | None = None, max_results: int = 5, max_snippet_length: int = 100\n        ) -> list[Data]:\n            try:\n                local_wrapper = wrapper\n                if params:\n                    local_wrapper = self._build_wrapper(params)\n\n                full_results = local_wrapper.results(query)\n                organic_results = full_results.get(\"organic_results\", [])[:max_results]\n\n                limited_results = [\n                    Data(\n                        text=result.get(\"snippet\", \"\"),\n                        data={\n                            \"title\": result.get(\"title\", \"\")[:max_snippet_length],\n                            \"link\": result.get(\"link\", \"\"),\n                            \"snippet\": result.get(\"snippet\", \"\")[:max_snippet_length],\n                        },\n                    )\n                    for result in organic_results\n                ]\n\n            except Exception as e:\n                error_message = f\"Error in SerpAPI search: {e!s}\"\n                logger.debug(error_message)\n                raise ToolException(error_message) from e\n            return limited_results\n\n        results = search_func(\n            self.input_value,\n            params=self.search_params,\n            max_results=self.max_results,\n            max_snippet_length=self.max_snippet_length,\n        )\n        self.status = results\n        return results\n\n    def fetch_content_text(self) -> Message:\n        data = self.fetch_content()\n        result_string = \"\"\n        for item in data:\n            result_string += item.text + \"\\n\"\n        self.status = result_string\n        return Message(text=result_string)\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "input_value": {
        "tool_mode": true,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "input_value",
        "value": "",
        "display_name": "Input",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "max_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "max_results",
        "value": 5,
        "display_name": "Max Results",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "max_snippet_length": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "max_snippet_length",
        "value": 100,
        "display_name": "Max Snippet Length",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "search_params": {
        "tool_mode": false,
        "trace_as_input": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_params",
        "value": {},
        "display_name": "Parameters",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "dict",
        "_input_type": "DictInput"
      },
      "serpapi_api_key": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "serpapi_api_key",
        "value": "",
        "display_name": "SerpAPI API Key",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      }
    },
    "description": "Call Serp Search API with result limiting",
    "icon": "SerpSearch",
    "base_classes": [
      "Data",
      "Message"
    ],
    "display_name": "Serp Search API",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "data",
        "display_name": "Data",
        "method": "fetch_content",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "Message"
        ],
        "selected": "Message",
        "name": "text",
        "display_name": "Text",
        "method": "fetch_content_text",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "serpapi_api_key",
      "input_value",
      "search_params",
      "max_results",
      "max_snippet_length"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "GoogleSearchAPI": {
    "template": {
      "_type": "Component",
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain_core.tools import Tool\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.inputs import IntInput, MultilineInput, SecretStrInput\nfrom langflow.schema import Data\n\n\nclass GoogleSearchAPIComponent(LCToolComponent):\n    display_name = \"Google Search API [DEPRECATED]\"\n    description = \"Call Google Search API.\"\n    name = \"GoogleSearchAPI\"\n    icon = \"Google\"\n    legacy = True\n    inputs = [\n        SecretStrInput(name=\"google_api_key\", display_name=\"Google API Key\", required=True),\n        SecretStrInput(name=\"google_cse_id\", display_name=\"Google CSE ID\", required=True),\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input\",\n        ),\n        IntInput(name=\"k\", display_name=\"Number of results\", value=4, required=True),\n    ]\n\n    def run_model(self) -> Data | list[Data]:\n        wrapper = self._build_wrapper()\n        results = wrapper.results(query=self.input_value, num_results=self.k)\n        data = [Data(data=result, text=result[\"snippet\"]) for result in results]\n        self.status = data\n        return data\n\n    def build_tool(self) -> Tool:\n        wrapper = self._build_wrapper()\n        return Tool(\n            name=\"google_search\",\n            description=\"Search Google for recent results.\",\n            func=wrapper.run,\n        )\n\n    def _build_wrapper(self):\n        try:\n            from langchain_google_community import GoogleSearchAPIWrapper\n        except ImportError as e:\n            msg = \"Please install langchain-google-community to use GoogleSearchAPIWrapper.\"\n            raise ImportError(msg) from e\n        return GoogleSearchAPIWrapper(google_api_key=self.google_api_key, google_cse_id=self.google_cse_id, k=self.k)\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "google_api_key": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "google_api_key",
        "value": "",
        "display_name": "Google API Key",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "google_cse_id": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "google_cse_id",
        "value": "",
        "display_name": "Google CSE ID",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "input_value": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "input_value",
        "value": "",
        "display_name": "Input",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "k": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "k",
        "value": 4,
        "display_name": "Number of results",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      }
    },
    "description": "Call Google Search API.",
    "icon": "Google",
    "base_classes": [
      "Data",
      "Tool"
    ],
    "display_name": "Google Search API [DEPRECATED]",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "api_run_model",
        "display_name": "Data",
        "method": "run_model",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "google_api_key",
          "google_cse_id",
          "k"
        ],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "Tool"
        ],
        "selected": "Tool",
        "name": "api_build_tool",
        "display_name": "Tool",
        "method": "build_tool",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "google_api_key",
          "google_cse_id",
          "k"
        ],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "google_api_key",
      "google_cse_id",
      "input_value",
      "k"
    ],
    "beta": false,
    "legacy": true,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "GoogleSerperAPI": {
    "template": {
      "_type": "Component",
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from typing import Any\n\nfrom langchain.tools import StructuredTool\nfrom langchain_community.utilities.google_serper import GoogleSerperAPIWrapper\nfrom pydantic import BaseModel, Field\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import (\n    DictInput,\n    DropdownInput,\n    IntInput,\n    MultilineInput,\n    SecretStrInput,\n)\nfrom langflow.schema import Data\n\n\nclass QuerySchema(BaseModel):\n    query: str = Field(..., description=\"The query to search for.\")\n    query_type: str = Field(\n        \"search\",\n        description=\"The type of search to perform (e.g., 'news' or 'search').\",\n    )\n    k: int = Field(4, description=\"The number of results to return.\")\n    query_params: dict[str, Any] = Field({}, description=\"Additional query parameters to pass to the API.\")\n\n\nclass GoogleSerperAPIComponent(LCToolComponent):\n    display_name = \"Google Serper API [DEPRECATED]\"\n    description = \"Call the Serper.dev Google Search API.\"\n    name = \"GoogleSerperAPI\"\n    icon = \"Google\"\n    legacy = True\n    inputs = [\n        SecretStrInput(name=\"serper_api_key\", display_name=\"Serper API Key\", required=True),\n        MultilineInput(\n            name=\"query\",\n            display_name=\"Query\",\n        ),\n        IntInput(name=\"k\", display_name=\"Number of results\", value=4, required=True),\n        DropdownInput(\n            name=\"query_type\",\n            display_name=\"Query Type\",\n            required=False,\n            options=[\"news\", \"search\"],\n            value=\"search\",\n        ),\n        DictInput(\n            name=\"query_params\",\n            display_name=\"Query Params\",\n            required=False,\n            value={\n                \"gl\": \"us\",\n                \"hl\": \"en\",\n            },\n            list=True,\n        ),\n    ]\n\n    def run_model(self) -> Data | list[Data]:\n        wrapper = self._build_wrapper(self.k, self.query_type, self.query_params)\n        results = wrapper.results(query=self.query)\n\n        # Adjust the extraction based on the `type`\n        if self.query_type == \"search\":\n            list_results = results.get(\"organic\", [])\n        elif self.query_type == \"news\":\n            list_results = results.get(\"news\", [])\n        else:\n            list_results = []\n\n        data_list = []\n        for result in list_results:\n            result[\"text\"] = result.pop(\"snippet\", \"\")\n            data_list.append(Data(data=result))\n        self.status = data_list\n        return data_list\n\n    def build_tool(self) -> Tool:\n        return StructuredTool.from_function(\n            name=\"google_search\",\n            description=\"Search Google for recent results.\",\n            func=self._search,\n            args_schema=self.QuerySchema,\n        )\n\n    def _build_wrapper(\n        self,\n        k: int = 5,\n        query_type: str = \"search\",\n        query_params: dict | None = None,\n    ) -> GoogleSerperAPIWrapper:\n        wrapper_args = {\n            \"serper_api_key\": self.serper_api_key,\n            \"k\": k,\n            \"type\": query_type,\n        }\n\n        # Add query_params if provided\n        if query_params:\n            wrapper_args.update(query_params)  # Merge with additional query params\n\n        # Dynamically pass parameters to the wrapper\n        return GoogleSerperAPIWrapper(**wrapper_args)\n\n    def _search(\n        self,\n        query: str,\n        k: int = 5,\n        query_type: str = \"search\",\n        query_params: dict | None = None,\n    ) -> dict:\n        wrapper = self._build_wrapper(k, query_type, query_params)\n        return wrapper.results(query=query)\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "k": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "k",
        "value": 4,
        "display_name": "Number of results",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "query": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "query",
        "value": "",
        "display_name": "Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "query_params": {
        "tool_mode": false,
        "trace_as_input": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "query_params",
        "value": {
          "gl": "us",
          "hl": "en"
        },
        "display_name": "Query Params",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "dict",
        "_input_type": "DictInput"
      },
      "query_type": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "news",
          "search"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "query_type",
        "value": "search",
        "display_name": "Query Type",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "serper_api_key": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "serper_api_key",
        "value": "",
        "display_name": "Serper API Key",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      }
    },
    "description": "Call the Serper.dev Google Search API.",
    "icon": "Google",
    "base_classes": [
      "Data",
      "Tool"
    ],
    "display_name": "Google Serper API [DEPRECATED]",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "api_run_model",
        "display_name": "Data",
        "method": "run_model",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "k",
          "serper_api_key"
        ],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "Tool"
        ],
        "selected": "Tool",
        "name": "api_build_tool",
        "display_name": "Tool",
        "method": "build_tool",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "k",
          "serper_api_key"
        ],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "serper_api_key",
      "query",
      "k",
      "query_type",
      "query_params"
    ],
    "beta": false,
    "legacy": true,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "PythonCodeStructuredTool": {
    "template": {
      "_type": "Component",
      "_classes": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "_classes",
        "value": "",
        "display_name": "Classes",
        "advanced": true,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "_functions": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "_functions",
        "value": "",
        "display_name": "Functions",
        "advanced": true,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "import ast\nimport json\nfrom typing import Any\n\nfrom langchain.agents import Tool\nfrom langchain_core.tools import StructuredTool\nfrom loguru import logger\nfrom pydantic.v1 import Field, create_model\nfrom pydantic.v1.fields import Undefined\nfrom typing_extensions import override\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.inputs.inputs import (\n    BoolInput,\n    DropdownInput,\n    FieldTypes,\n    HandleInput,\n    MessageTextInput,\n    MultilineInput,\n)\nfrom langflow.io import Output\nfrom langflow.schema import Data\nfrom langflow.schema.dotdict import dotdict\n\n\nclass PythonCodeStructuredTool(LCToolComponent):\n    DEFAULT_KEYS = [\n        \"code\",\n        \"_type\",\n        \"text_key\",\n        \"tool_code\",\n        \"tool_name\",\n        \"tool_description\",\n        \"return_direct\",\n        \"tool_function\",\n        \"global_variables\",\n        \"_classes\",\n        \"_functions\",\n    ]\n    display_name = \"Python Code Structured\"\n    description = \"structuredtool dataclass code to tool\"\n    documentation = \"https://python.langchain.com/docs/modules/tools/custom_tools/#structuredtool-dataclass\"\n    name = \"PythonCodeStructuredTool\"\n    icon = \"Python\"\n    field_order = [\"name\", \"description\", \"tool_code\", \"return_direct\", \"tool_function\"]\n    legacy: bool = True\n\n    inputs = [\n        MultilineInput(\n            name=\"tool_code\",\n            display_name=\"Tool Code\",\n            info=\"Enter the dataclass code.\",\n            placeholder=\"def my_function(args):\\n    pass\",\n            required=True,\n            real_time_refresh=True,\n            refresh_button=True,\n        ),\n        MessageTextInput(\n            name=\"tool_name\",\n            display_name=\"Tool Name\",\n            info=\"Enter the name of the tool.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"tool_description\",\n            display_name=\"Description\",\n            info=\"Enter the description of the tool.\",\n            required=True,\n        ),\n        BoolInput(\n            name=\"return_direct\",\n            display_name=\"Return Directly\",\n            info=\"Should the tool return the function output directly?\",\n        ),\n        DropdownInput(\n            name=\"tool_function\",\n            display_name=\"Tool Function\",\n            info=\"Select the function for additional expressions.\",\n            options=[],\n            required=True,\n            real_time_refresh=True,\n            refresh_button=True,\n        ),\n        HandleInput(\n            name=\"global_variables\",\n            display_name=\"Global Variables\",\n            info=\"Enter the global variables or Create Data Component.\",\n            input_types=[\"Data\"],\n            field_type=FieldTypes.DICT,\n            is_list=True,\n        ),\n        MessageTextInput(name=\"_classes\", display_name=\"Classes\", advanced=True),\n        MessageTextInput(name=\"_functions\", display_name=\"Functions\", advanced=True),\n    ]\n\n    outputs = [\n        Output(display_name=\"Tool\", name=\"result_tool\", method=\"build_tool\"),\n    ]\n\n    @override\n    async def update_build_config(\n        self, build_config: dotdict, field_value: Any, field_name: str | None = None\n    ) -> dotdict:\n        if field_name is None:\n            return build_config\n\n        if field_name not in {\"tool_code\", \"tool_function\"}:\n            return build_config\n\n        try:\n            named_functions = {}\n            [classes, functions] = self._parse_code(build_config[\"tool_code\"][\"value\"])\n            existing_fields = {}\n            if len(build_config) > len(self.DEFAULT_KEYS):\n                for key in build_config.copy():\n                    if key not in self.DEFAULT_KEYS:\n                        existing_fields[key] = build_config.pop(key)\n\n            names = []\n            for func in functions:\n                named_functions[func[\"name\"]] = func\n                names.append(func[\"name\"])\n\n                for arg in func[\"args\"]:\n                    field_name = f\"{func['name']}|{arg['name']}\"\n                    if field_name in existing_fields:\n                        build_config[field_name] = existing_fields[field_name]\n                        continue\n\n                    field = MessageTextInput(\n                        display_name=f\"{arg['name']}: Description\",\n                        name=field_name,\n                        info=f\"Enter the description for {arg['name']}\",\n                        required=True,\n                    )\n                    build_config[field_name] = field.to_dict()\n            build_config[\"_functions\"][\"value\"] = json.dumps(named_functions)\n            build_config[\"_classes\"][\"value\"] = json.dumps(classes)\n            build_config[\"tool_function\"][\"options\"] = names\n        except Exception as e:  # noqa: BLE001\n            self.status = f\"Failed to extract names: {e}\"\n            logger.opt(exception=True).debug(self.status)\n            build_config[\"tool_function\"][\"options\"] = [\"Failed to parse\", str(e)]\n        return build_config\n\n    async def build_tool(self) -> Tool:\n        local_namespace = {}  # type: ignore[var-annotated]\n        modules = self._find_imports(self.tool_code)\n        import_code = \"\"\n        for module in modules[\"imports\"]:\n            import_code += f\"global {module}\\nimport {module}\\n\"\n        for from_module in modules[\"from_imports\"]:\n            for alias in from_module.names:\n                import_code += f\"global {alias.name}\\n\"\n            import_code += (\n                f\"from {from_module.module} import {', '.join([alias.name for alias in from_module.names])}\\n\"\n            )\n        exec(import_code, globals())\n        exec(self.tool_code, globals(), local_namespace)\n\n        class PythonCodeToolFunc:\n            params: dict = {}\n\n            def run(**kwargs):\n                for key, arg in kwargs.items():\n                    if key not in PythonCodeToolFunc.params:\n                        PythonCodeToolFunc.params[key] = arg\n                return local_namespace[self.tool_function](**PythonCodeToolFunc.params)\n\n        globals_ = globals()\n        local = {}\n        local[self.tool_function] = PythonCodeToolFunc\n        globals_.update(local)\n\n        if isinstance(self.global_variables, list):\n            for data in self.global_variables:\n                if isinstance(data, Data):\n                    globals_.update(data.data)\n        elif isinstance(self.global_variables, dict):\n            globals_.update(self.global_variables)\n\n        classes = json.loads(self._attributes[\"_classes\"])\n        for class_dict in classes:\n            exec(\"\\n\".join(class_dict[\"code\"]), globals_)\n\n        named_functions = json.loads(self._attributes[\"_functions\"])\n        schema_fields = {}\n\n        for attr in self._attributes:\n            if attr in self.DEFAULT_KEYS:\n                continue\n\n            func_name = attr.split(\"|\")[0]\n            field_name = attr.split(\"|\")[1]\n            func_arg = self._find_arg(named_functions, func_name, field_name)\n            if func_arg is None:\n                msg = f\"Failed to find arg: {field_name}\"\n                raise ValueError(msg)\n\n            field_annotation = func_arg[\"annotation\"]\n            field_description = self._get_value(self._attributes[attr], str)\n\n            if field_annotation:\n                exec(f\"temp_annotation_type = {field_annotation}\", globals_)\n                schema_annotation = globals_[\"temp_annotation_type\"]\n            else:\n                schema_annotation = Any\n            schema_fields[field_name] = (\n                schema_annotation,\n                Field(\n                    default=func_arg.get(\"default\", Undefined),\n                    description=field_description,\n                ),\n            )\n\n        if \"temp_annotation_type\" in globals_:\n            globals_.pop(\"temp_annotation_type\")\n\n        python_code_tool_schema = None\n        if schema_fields:\n            python_code_tool_schema = create_model(\"PythonCodeToolSchema\", **schema_fields)\n\n        return StructuredTool.from_function(\n            func=local[self.tool_function].run,\n            args_schema=python_code_tool_schema,\n            name=self.tool_name,\n            description=self.tool_description,\n            return_direct=self.return_direct,\n        )\n\n    async def update_frontend_node(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"This function is called after the code validation is done.\"\"\"\n        frontend_node = await super().update_frontend_node(new_frontend_node, current_frontend_node)\n        frontend_node[\"template\"] = await self.update_build_config(\n            frontend_node[\"template\"],\n            frontend_node[\"template\"][\"tool_code\"][\"value\"],\n            \"tool_code\",\n        )\n        frontend_node = await super().update_frontend_node(new_frontend_node, current_frontend_node)\n        for key in frontend_node[\"template\"]:\n            if key in self.DEFAULT_KEYS:\n                continue\n            frontend_node[\"template\"] = await self.update_build_config(\n                frontend_node[\"template\"], frontend_node[\"template\"][key][\"value\"], key\n            )\n            frontend_node = await super().update_frontend_node(new_frontend_node, current_frontend_node)\n        return frontend_node\n\n    def _parse_code(self, code: str) -> tuple[list[dict], list[dict]]:\n        parsed_code = ast.parse(code)\n        lines = code.split(\"\\n\")\n        classes = []\n        functions = []\n        for node in parsed_code.body:\n            if isinstance(node, ast.ClassDef):\n                class_lines = lines[node.lineno - 1 : node.end_lineno]\n                class_lines[-1] = class_lines[-1][: node.end_col_offset]\n                class_lines[0] = class_lines[0][node.col_offset :]\n                classes.append(\n                    {\n                        \"name\": node.name,\n                        \"code\": class_lines,\n                    }\n                )\n                continue\n\n            if not isinstance(node, ast.FunctionDef):\n                continue\n\n            func = {\"name\": node.name, \"args\": []}\n            for arg in node.args.args:\n                if arg.lineno != arg.end_lineno:\n                    msg = \"Multiline arguments are not supported\"\n                    raise ValueError(msg)\n\n                func_arg = {\n                    \"name\": arg.arg,\n                    \"annotation\": None,\n                }\n\n                for default in node.args.defaults:\n                    if (\n                        arg.lineno > default.lineno\n                        or arg.col_offset > default.col_offset\n                        or (\n                            arg.end_lineno is not None\n                            and default.end_lineno is not None\n                            and arg.end_lineno < default.end_lineno\n                        )\n                        or (\n                            arg.end_col_offset is not None\n                            and default.end_col_offset is not None\n                            and arg.end_col_offset < default.end_col_offset\n                        )\n                    ):\n                        continue\n\n                    if isinstance(default, ast.Name):\n                        func_arg[\"default\"] = default.id\n                    elif isinstance(default, ast.Constant):\n                        func_arg[\"default\"] = default.value\n\n                if arg.annotation:\n                    annotation_line = lines[arg.annotation.lineno - 1]\n                    annotation_line = annotation_line[: arg.annotation.end_col_offset]\n                    annotation_line = annotation_line[arg.annotation.col_offset :]\n                    func_arg[\"annotation\"] = annotation_line\n                    if isinstance(func_arg[\"annotation\"], str) and func_arg[\"annotation\"].count(\"=\") > 0:\n                        func_arg[\"annotation\"] = \"=\".join(func_arg[\"annotation\"].split(\"=\")[:-1]).strip()\n                if isinstance(func[\"args\"], list):\n                    func[\"args\"].append(func_arg)\n            functions.append(func)\n\n        return classes, functions\n\n    def _find_imports(self, code: str) -> dotdict:\n        imports: list[str] = []\n        from_imports = []\n        parsed_code = ast.parse(code)\n        for node in parsed_code.body:\n            if isinstance(node, ast.Import):\n                imports.extend(alias.name for alias in node.names)\n            elif isinstance(node, ast.ImportFrom):\n                from_imports.append(node)\n        return dotdict({\"imports\": imports, \"from_imports\": from_imports})\n\n    def _get_value(self, value: Any, annotation: Any) -> Any:\n        return value if isinstance(value, annotation) else value[\"value\"]\n\n    def _find_arg(self, named_functions: dict, func_name: str, arg_name: str) -> dict | None:\n        for arg in named_functions[func_name][\"args\"]:\n            if arg[\"name\"] == arg_name:\n                return arg\n        return None\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "global_variables": {
        "trace_as_metadata": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "global_variables",
        "value": "",
        "display_name": "Global Variables",
        "advanced": false,
        "input_types": [
          "Data"
        ],
        "dynamic": false,
        "info": "Enter the global variables or Create Data Component.",
        "title_case": false,
        "type": "dict",
        "_input_type": "HandleInput"
      },
      "return_direct": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "return_direct",
        "value": false,
        "display_name": "Return Directly",
        "advanced": false,
        "dynamic": false,
        "info": "Should the tool return the function output directly?",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "tool_code": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "def my_function(args):\n    pass",
        "show": true,
        "name": "tool_code",
        "value": "",
        "display_name": "Tool Code",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Enter the dataclass code.",
        "real_time_refresh": true,
        "refresh_button": true,
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "tool_description": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "tool_description",
        "value": "",
        "display_name": "Description",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Enter the description of the tool.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "tool_function": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "tool_function",
        "value": "",
        "display_name": "Tool Function",
        "advanced": false,
        "dynamic": false,
        "info": "Select the function for additional expressions.",
        "real_time_refresh": true,
        "refresh_button": true,
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "tool_name": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "tool_name",
        "value": "",
        "display_name": "Tool Name",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Enter the name of the tool.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      }
    },
    "description": "structuredtool dataclass code to tool",
    "icon": "Python",
    "base_classes": [
      "Tool"
    ],
    "display_name": "Python Code Structured",
    "documentation": "https://python.langchain.com/docs/modules/tools/custom_tools/#structuredtool-dataclass",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Tool"
        ],
        "selected": "Tool",
        "name": "result_tool",
        "display_name": "Tool",
        "method": "build_tool",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "tool_code",
      "tool_name",
      "tool_description",
      "return_direct",
      "tool_function",
      "global_variables",
      "_classes",
      "_functions"
    ],
    "beta": false,
    "legacy": true,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "TavilySearchComponent": {
    "template": {
      "_type": "Component",
      "api_key": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "api_key",
        "value": "",
        "display_name": "Tavily API Key",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "Your Tavily API Key.",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "import httpx\nfrom loguru import logger\n\nfrom langflow.custom import Component\nfrom langflow.helpers.data import data_to_text\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MessageTextInput, Output, SecretStrInput\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\n\n\nclass TavilySearchComponent(Component):\n    display_name = \"Tavily AI Search\"\n    description = \"\"\"**Tavily AI** is a search engine optimized for LLMs and RAG, \\\n        aimed at efficient, quick, and persistent search results.\"\"\"\n    icon = \"TavilyIcon\"\n\n    inputs = [\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"Tavily API Key\",\n            required=True,\n            info=\"Your Tavily API Key.\",\n        ),\n        MessageTextInput(\n            name=\"query\",\n            display_name=\"Search Query\",\n            info=\"The search query you want to execute with Tavily.\",\n            tool_mode=True,\n        ),\n        DropdownInput(\n            name=\"search_depth\",\n            display_name=\"Search Depth\",\n            info=\"The depth of the search.\",\n            options=[\"basic\", \"advanced\"],\n            value=\"advanced\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"topic\",\n            display_name=\"Search Topic\",\n            info=\"The category of the search.\",\n            options=[\"general\", \"news\"],\n            value=\"general\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"time_range\",\n            display_name=\"Time Range\",\n            info=\"The time range back from the current date to include in the search results.\",\n            options=[\"day\", \"week\", \"month\", \"year\"],\n            value=None,\n            advanced=True,\n            combobox=True,\n        ),\n        IntInput(\n            name=\"max_results\",\n            display_name=\"Max Results\",\n            info=\"The maximum number of search results to return.\",\n            value=5,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"include_images\",\n            display_name=\"Include Images\",\n            info=\"Include a list of query-related images in the response.\",\n            value=True,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"include_answer\",\n            display_name=\"Include Answer\",\n            info=\"Include a short answer to original query.\",\n            value=True,\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"fetch_content\"),\n        Output(display_name=\"Text\", name=\"text\", method=\"fetch_content_text\"),\n    ]\n\n    def fetch_content(self) -> list[Data]:\n        try:\n            url = \"https://api.tavily.com/search\"\n            headers = {\n                \"content-type\": \"application/json\",\n                \"accept\": \"application/json\",\n            }\n            payload = {\n                \"api_key\": self.api_key,\n                \"query\": self.query,\n                \"search_depth\": self.search_depth,\n                \"topic\": self.topic,\n                \"max_results\": self.max_results,\n                \"include_images\": self.include_images,\n                \"include_answer\": self.include_answer,\n                \"time_range\": self.time_range,\n            }\n\n            with httpx.Client() as client:\n                response = client.post(url, json=payload, headers=headers)\n\n            response.raise_for_status()\n            search_results = response.json()\n\n            data_results = []\n\n            if self.include_answer and search_results.get(\"answer\"):\n                data_results.append(Data(text=search_results[\"answer\"]))\n\n            for result in search_results.get(\"results\", []):\n                content = result.get(\"content\", \"\")\n                data_results.append(\n                    Data(\n                        text=content,\n                        data={\n                            \"title\": result.get(\"title\"),\n                            \"url\": result.get(\"url\"),\n                            \"content\": content,\n                            \"score\": result.get(\"score\"),\n                        },\n                    )\n                )\n\n            if self.include_images and search_results.get(\"images\"):\n                data_results.append(Data(text=\"Images found\", data={\"images\": search_results[\"images\"]}))\n        except httpx.HTTPStatusError as exc:\n            error_message = f\"HTTP error occurred: {exc.response.status_code} - {exc.response.text}\"\n            logger.error(error_message)\n            return [Data(text=error_message, data={\"error\": error_message})]\n        except httpx.RequestError as exc:\n            error_message = f\"Request error occurred: {exc}\"\n            logger.error(error_message)\n            return [Data(text=error_message, data={\"error\": error_message})]\n        except ValueError as exc:\n            error_message = f\"Invalid response format: {exc}\"\n            logger.error(error_message)\n            return [Data(text=error_message, data={\"error\": error_message})]\n        else:\n            self.status = data_results\n            return data_results\n\n    def fetch_content_text(self) -> Message:\n        data = self.fetch_content()\n        result_string = data_to_text(\"{text}\", data)\n        self.status = result_string\n        return Message(text=result_string)\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "include_answer": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "include_answer",
        "value": true,
        "display_name": "Include Answer",
        "advanced": true,
        "dynamic": false,
        "info": "Include a short answer to original query.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "include_images": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "include_images",
        "value": true,
        "display_name": "Include Images",
        "advanced": true,
        "dynamic": false,
        "info": "Include a list of query-related images in the response.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "max_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "max_results",
        "value": 5,
        "display_name": "Max Results",
        "advanced": true,
        "dynamic": false,
        "info": "The maximum number of search results to return.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "query": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "query",
        "value": "",
        "display_name": "Search Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The search query you want to execute with Tavily.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "search_depth": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "basic",
          "advanced"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_depth",
        "value": "advanced",
        "display_name": "Search Depth",
        "advanced": true,
        "dynamic": false,
        "info": "The depth of the search.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "time_range": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "day",
          "week",
          "month",
          "year"
        ],
        "options_metadata": [],
        "combobox": true,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "time_range",
        "display_name": "Time Range",
        "advanced": true,
        "dynamic": false,
        "info": "The time range back from the current date to include in the search results.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "topic": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "general",
          "news"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "topic",
        "value": "general",
        "display_name": "Search Topic",
        "advanced": true,
        "dynamic": false,
        "info": "The category of the search.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      }
    },
    "description": "**Tavily AI** is a search engine optimized for LLMs and RAG,         aimed at efficient, quick, and persistent search results.",
    "icon": "TavilyIcon",
    "base_classes": [
      "Data",
      "Message"
    ],
    "display_name": "Tavily AI Search",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "data",
        "display_name": "Data",
        "method": "fetch_content",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "Message"
        ],
        "selected": "Message",
        "name": "text",
        "display_name": "Text",
        "method": "fetch_content_text",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "api_key",
      "query",
      "search_depth",
      "topic",
      "time_range",
      "max_results",
      "include_images",
      "include_answer"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "ArXivComponent": {
    "template": {
      "_type": "Component",
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "import urllib.request\nfrom urllib.parse import urlparse\nfrom xml.etree.ElementTree import Element\n\nfrom defusedxml.ElementTree import fromstring\n\nfrom langflow.custom import Component\nfrom langflow.io import DropdownInput, IntInput, MessageTextInput, Output\nfrom langflow.schema import Data, DataFrame\n\n\nclass ArXivComponent(Component):\n    display_name = \"arXiv\"\n    description = \"Search and retrieve papers from arXiv.org\"\n    icon = \"arXiv\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"search_query\",\n            display_name=\"Search Query\",\n            info=\"The search query for arXiv papers (e.g., 'quantum computing')\",\n            tool_mode=True,\n        ),\n        DropdownInput(\n            name=\"search_type\",\n            display_name=\"Search Field\",\n            info=\"The field to search in\",\n            options=[\"all\", \"title\", \"abstract\", \"author\", \"cat\"],  # cat is for category\n            value=\"all\",\n        ),\n        IntInput(\n            name=\"max_results\",\n            display_name=\"Max Results\",\n            info=\"Maximum number of results to return\",\n            value=10,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"search_papers\"),\n        Output(display_name=\"DataFrame\", name=\"dataframe\", method=\"as_dataframe\"),\n    ]\n\n    def build_query_url(self) -> str:\n        \"\"\"Build the arXiv API query URL.\"\"\"\n        base_url = \"http://export.arxiv.org/api/query?\"\n\n        # Build the search query\n        search_query = f\"{self.search_type}:{self.search_query}\"\n\n        # URL parameters\n        params = {\n            \"search_query\": search_query,\n            \"max_results\": str(self.max_results),\n        }\n\n        # Convert params to URL query string\n        query_string = \"&\".join([f\"{k}={urllib.parse.quote(str(v))}\" for k, v in params.items()])\n\n        return base_url + query_string\n\n    def parse_atom_response(self, response_text: str) -> list[dict]:\n        \"\"\"Parse the Atom XML response from arXiv.\"\"\"\n        # Parse XML safely using defusedxml\n        root = fromstring(response_text)\n\n        # Define namespace dictionary for XML parsing\n        ns = {\"atom\": \"http://www.w3.org/2005/Atom\", \"arxiv\": \"http://arxiv.org/schemas/atom\"}\n\n        papers = []\n        # Process each entry (paper)\n        for entry in root.findall(\"atom:entry\", ns):\n            paper = {\n                \"id\": self._get_text(entry, \"atom:id\", ns),\n                \"title\": self._get_text(entry, \"atom:title\", ns),\n                \"summary\": self._get_text(entry, \"atom:summary\", ns),\n                \"published\": self._get_text(entry, \"atom:published\", ns),\n                \"updated\": self._get_text(entry, \"atom:updated\", ns),\n                \"authors\": [author.find(\"atom:name\", ns).text for author in entry.findall(\"atom:author\", ns)],\n                \"arxiv_url\": self._get_link(entry, \"alternate\", ns),\n                \"pdf_url\": self._get_link(entry, \"related\", ns),\n                \"comment\": self._get_text(entry, \"arxiv:comment\", ns),\n                \"journal_ref\": self._get_text(entry, \"arxiv:journal_ref\", ns),\n                \"primary_category\": self._get_category(entry, ns),\n                \"categories\": [cat.get(\"term\") for cat in entry.findall(\"atom:category\", ns)],\n            }\n            papers.append(paper)\n\n        return papers\n\n    def _get_text(self, element: Element, path: str, ns: dict) -> str | None:\n        \"\"\"Safely extract text from an XML element.\"\"\"\n        el = element.find(path, ns)\n        return el.text.strip() if el is not None and el.text else None\n\n    def _get_link(self, element: Element, rel: str, ns: dict) -> str | None:\n        \"\"\"Get link URL based on relation type.\"\"\"\n        for link in element.findall(\"atom:link\", ns):\n            if link.get(\"rel\") == rel:\n                return link.get(\"href\")\n        return None\n\n    def _get_category(self, element: Element, ns: dict) -> str | None:\n        \"\"\"Get primary category.\"\"\"\n        cat = element.find(\"arxiv:primary_category\", ns)\n        return cat.get(\"term\") if cat is not None else None\n\n    def search_papers(self) -> list[Data]:\n        \"\"\"Search arXiv and return results.\"\"\"\n        try:\n            # Build the query URL\n            url = self.build_query_url()\n\n            # Validate URL scheme and host\n            parsed_url = urlparse(url)\n            if parsed_url.scheme not in {\"http\", \"https\"}:\n                error_msg = f\"Invalid URL scheme: {parsed_url.scheme}\"\n                raise ValueError(error_msg)\n            if parsed_url.hostname != \"export.arxiv.org\":\n                error_msg = f\"Invalid host: {parsed_url.hostname}\"\n                raise ValueError(error_msg)\n\n            # Create a custom opener that only allows http/https schemes\n            class RestrictedHTTPHandler(urllib.request.HTTPHandler):\n                def http_open(self, req):\n                    return super().http_open(req)\n\n            class RestrictedHTTPSHandler(urllib.request.HTTPSHandler):\n                def https_open(self, req):\n                    return super().https_open(req)\n\n            # Build opener with restricted handlers\n            opener = urllib.request.build_opener(RestrictedHTTPHandler, RestrictedHTTPSHandler)\n            urllib.request.install_opener(opener)\n\n            # Make the request with validated URL using restricted opener\n            response = opener.open(url)\n            response_text = response.read().decode(\"utf-8\")\n\n            # Parse the response\n            papers = self.parse_atom_response(response_text)\n\n            # Convert to Data objects\n            results = [Data(data=paper) for paper in papers]\n            self.status = results\n        except (urllib.error.URLError, ValueError) as e:\n            error_data = Data(data={\"error\": f\"Request error: {e!s}\"})\n            self.status = error_data\n            return [error_data]\n        else:\n            return results\n\n    def as_dataframe(self) -> DataFrame:\n        \"\"\"Convert the Arxiv search results to a DataFrame.\n\n        Returns:\n            DataFrame: A DataFrame containing the search results.\n        \"\"\"\n        data = self.search_papers()\n        if isinstance(data, list):\n            return DataFrame(data=[d.data for d in data])\n        return DataFrame(data=[data.data])\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "max_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "max_results",
        "value": 10,
        "display_name": "Max Results",
        "advanced": false,
        "dynamic": false,
        "info": "Maximum number of results to return",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "search_query": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_query",
        "value": "",
        "display_name": "Search Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The search query for arXiv papers (e.g., 'quantum computing')",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "search_type": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "all",
          "title",
          "abstract",
          "author",
          "cat"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_type",
        "value": "all",
        "display_name": "Search Field",
        "advanced": false,
        "dynamic": false,
        "info": "The field to search in",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      }
    },
    "description": "Search and retrieve papers from arXiv.org",
    "icon": "arXiv",
    "base_classes": [
      "Data",
      "DataFrame"
    ],
    "display_name": "arXiv",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "data",
        "display_name": "Data",
        "method": "search_papers",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "search_query",
      "search_type",
      "max_results"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "WikipediaAPI": {
    "template": {
      "_type": "Component",
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from typing import cast\n\nfrom langchain_community.tools import WikipediaQueryRun\nfrom langchain_community.utilities.wikipedia import WikipediaAPIWrapper\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import BoolInput, IntInput, MessageTextInput, MultilineInput\nfrom langflow.schema import Data\n\n\nclass WikipediaAPIComponent(LCToolComponent):\n    display_name = \"Wikipedia API [Deprecated]\"\n    description = \"Call Wikipedia API.\"\n    name = \"WikipediaAPI\"\n    icon = \"Wikipedia\"\n    legacy = True\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input\",\n        ),\n        MessageTextInput(name=\"lang\", display_name=\"Language\", value=\"en\"),\n        IntInput(name=\"k\", display_name=\"Number of results\", value=4, required=True),\n        BoolInput(name=\"load_all_available_meta\", display_name=\"Load all available meta\", value=False, advanced=True),\n        IntInput(\n            name=\"doc_content_chars_max\", display_name=\"Document content characters max\", value=4000, advanced=True\n        ),\n    ]\n\n    def run_model(self) -> list[Data]:\n        wrapper = self._build_wrapper()\n        docs = wrapper.load(self.input_value)\n        data = [Data.from_document(doc) for doc in docs]\n        self.status = data\n        return data\n\n    def build_tool(self) -> Tool:\n        wrapper = self._build_wrapper()\n        return cast(\"Tool\", WikipediaQueryRun(api_wrapper=wrapper))\n\n    def _build_wrapper(self) -> WikipediaAPIWrapper:\n        return WikipediaAPIWrapper(\n            top_k_results=self.k,\n            lang=self.lang,\n            load_all_available_meta=self.load_all_available_meta,\n            doc_content_chars_max=self.doc_content_chars_max,\n        )\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "doc_content_chars_max": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "doc_content_chars_max",
        "value": 4000,
        "display_name": "Document content characters max",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "input_value": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "input_value",
        "value": "",
        "display_name": "Input",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "k": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "k",
        "value": 4,
        "display_name": "Number of results",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "lang": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "lang",
        "value": "en",
        "display_name": "Language",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "load_all_available_meta": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "load_all_available_meta",
        "value": false,
        "display_name": "Load all available meta",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      }
    },
    "description": "Call Wikipedia API.",
    "icon": "Wikipedia",
    "base_classes": [
      "Data",
      "Tool"
    ],
    "display_name": "Wikipedia API [Deprecated]",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "api_run_model",
        "display_name": "Data",
        "method": "run_model",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "k"
        ],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "Tool"
        ],
        "selected": "Tool",
        "name": "api_build_tool",
        "display_name": "Tool",
        "method": "build_tool",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "k"
        ],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "input_value",
      "lang",
      "k",
      "load_all_available_meta",
      "doc_content_chars_max"
    ],
    "beta": false,
    "legacy": true,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "AstraDBToolComponent": {
    "template": {
      "_type": "Component",
      "embedding": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "embedding",
        "value": "",
        "display_name": "Embedding Model",
        "advanced": false,
        "input_types": [
          "Embeddings"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "api_endpoint": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "api_endpoint",
        "value": "ASTRA_DB_API_ENDPOINT",
        "display_name": "API Endpoint",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "API endpoint URL for the Astra DB service.",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "import os\nfrom datetime import datetime, timezone\nfrom typing import Any\n\nfrom astrapy import Collection, DataAPIClient, Database\nfrom astrapy.admin import parse_api_endpoint\nfrom langchain.pydantic_v1 import BaseModel, Field, create_model\nfrom langchain_core.tools import StructuredTool, Tool\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.io import BoolInput, DictInput, HandleInput, IntInput, SecretStrInput, StrInput, TableInput\nfrom langflow.logging import logger\nfrom langflow.schema import Data\nfrom langflow.schema.table import EditMode\n\n\nclass AstraDBToolComponent(LCToolComponent):\n    display_name: str = \"Astra DB Tool\"\n    description: str = \"Tool to run hybrid vector and metadata search on DataStax Astra DB Collection\"\n    documentation: str = \"https://docs.langflow.org/Components/components-tools#astra-db-tool\"\n    icon: str = \"AstraDB\"\n\n    inputs = [\n        StrInput(\n            name=\"tool_name\",\n            display_name=\"Tool Name\",\n            info=\"The name of the tool to be passed to the LLM.\",\n            required=True,\n        ),\n        StrInput(\n            name=\"tool_description\",\n            display_name=\"Tool Description\",\n            info=\"Describe the tool to LLM. Add any information that can help the LLM to use the tool.\",\n            required=True,\n        ),\n        StrInput(\n            name=\"keyspace\",\n            display_name=\"Keyspace Name\",\n            info=\"The name of the keyspace within Astra where the collection is stored.\",\n            value=\"default_keyspace\",\n            advanced=True,\n        ),\n        StrInput(\n            name=\"collection_name\",\n            display_name=\"Collection Name\",\n            info=\"The name of the collection within Astra DB where the vectors will be stored.\",\n            required=True,\n        ),\n        SecretStrInput(\n            name=\"token\",\n            display_name=\"Astra DB Application Token\",\n            info=\"Authentication token for accessing Astra DB.\",\n            value=\"ASTRA_DB_APPLICATION_TOKEN\",\n            required=True,\n        ),\n        SecretStrInput(\n            name=\"api_endpoint\",\n            display_name=\"Database\" if os.getenv(\"ASTRA_ENHANCED\", \"false\").lower() == \"true\" else \"API Endpoint\",\n            info=\"API endpoint URL for the Astra DB service.\",\n            value=\"ASTRA_DB_API_ENDPOINT\",\n            required=True,\n        ),\n        StrInput(\n            name=\"projection_attributes\",\n            display_name=\"Projection Attributes\",\n            info=\"Attributes to be returned by the tool separated by comma.\",\n            required=True,\n            value=\"*\",\n            advanced=True,\n        ),\n        TableInput(\n            name=\"tools_params_v2\",\n            display_name=\"Tools Parameters\",\n            info=\"Define the structure for the tool parameters. Describe the parameters \"\n            \"in a way the LLM can understand how to use them.\",\n            required=False,\n            table_schema=[\n                {\n                    \"name\": \"name\",\n                    \"display_name\": \"Name\",\n                    \"type\": \"str\",\n                    \"description\": \"Specify the name of the output field/parameter for the model.\",\n                    \"default\": \"field\",\n                    \"edit_mode\": EditMode.INLINE,\n                },\n                {\n                    \"name\": \"attribute_name\",\n                    \"display_name\": \"Attribute Name\",\n                    \"type\": \"str\",\n                    \"description\": \"Specify the attribute name to be filtered on the collection. \"\n                    \"Leave empty if the attribute name is the same as the name of the field.\",\n                    \"default\": \"\",\n                    \"edit_mode\": EditMode.INLINE,\n                },\n                {\n                    \"name\": \"description\",\n                    \"display_name\": \"Description\",\n                    \"type\": \"str\",\n                    \"description\": \"Describe the purpose of the output field.\",\n                    \"default\": \"description of field\",\n                    \"edit_mode\": EditMode.POPOVER,\n                },\n                {\n                    \"name\": \"metadata\",\n                    \"display_name\": \"Is Metadata\",\n                    \"type\": \"boolean\",\n                    \"edit_mode\": EditMode.INLINE,\n                    \"description\": (\"Indicate if the field is included in the metadata field.\"),\n                    \"options\": [\"True\", \"False\"],\n                    \"default\": \"False\",\n                },\n                {\n                    \"name\": \"mandatory\",\n                    \"display_name\": \"Is Mandatory\",\n                    \"type\": \"boolean\",\n                    \"edit_mode\": EditMode.INLINE,\n                    \"description\": (\"Indicate if the field is mandatory.\"),\n                    \"options\": [\"True\", \"False\"],\n                    \"default\": \"False\",\n                },\n                {\n                    \"name\": \"is_timestamp\",\n                    \"display_name\": \"Is Timestamp\",\n                    \"type\": \"boolean\",\n                    \"edit_mode\": EditMode.INLINE,\n                    \"description\": (\"Indicate if the field is a timestamp.\"),\n                    \"options\": [\"True\", \"False\"],\n                    \"default\": \"False\",\n                },\n                {\n                    \"name\": \"operator\",\n                    \"display_name\": \"Operator\",\n                    \"type\": \"str\",\n                    \"description\": \"Set the operator for the field. \"\n                    \"https://docs.datastax.com/en/astra-db-serverless/api-reference/documents.html#operators\",\n                    \"default\": \"$eq\",\n                    \"options\": [\"$gt\", \"$gte\", \"$lt\", \"$lte\", \"$eq\", \"$ne\", \"$in\", \"$nin\", \"$exists\", \"$all\", \"$size\"],\n                    \"edit_mode\": EditMode.INLINE,\n                },\n            ],\n            value=[],\n        ),\n        DictInput(\n            name=\"tool_params\",\n            info=\"DEPRECATED: Attributes to filter and description to the model. \"\n            \"Add ! for mandatory (e.g: !customerId)\",\n            display_name=\"Tool params\",\n            is_list=True,\n            advanced=True,\n        ),\n        DictInput(\n            name=\"static_filters\",\n            info=\"Attributes to filter and correspoding value\",\n            display_name=\"Static filters\",\n            advanced=True,\n            is_list=True,\n        ),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            advanced=True,\n            value=5,\n        ),\n        BoolInput(\n            name=\"use_search_query\",\n            display_name=\"Semantic Search\",\n            info=\"When this parameter is activated, the search query parameter will be used to search the collection.\",\n            advanced=False,\n            value=False,\n        ),\n        BoolInput(\n            name=\"use_vectorize\",\n            display_name=\"Use Astra DB Vectorize\",\n            info=\"When this parameter is activated, Astra DB Vectorize method will be used to generate the embeddings.\",\n            advanced=False,\n            value=False,\n        ),\n        HandleInput(name=\"embedding\", display_name=\"Embedding Model\", input_types=[\"Embeddings\"]),\n        StrInput(\n            name=\"semantic_search_instruction\",\n            display_name=\"Semantic Search Instruction\",\n            info=\"The instruction to use for the semantic search.\",\n            required=True,\n            value=\"Search query to find relevant documents.\",\n            advanced=True,\n        ),\n    ]\n\n    _cached_client: DataAPIClient | None = None\n    _cached_db: Database | None = None\n    _cached_collection: Collection | None = None\n\n    def _build_collection(self):\n        if self._cached_collection:\n            return self._cached_collection\n\n        try:\n            environment = parse_api_endpoint(self.api_endpoint).environment\n            cached_client = DataAPIClient(self.token, environment=environment)\n            cached_db = cached_client.get_database(self.api_endpoint, keyspace=self.keyspace)\n            self._cached_collection = cached_db.get_collection(self.collection_name)\n        except Exception as e:\n            msg = f\"Error building collection: {e}\"\n            raise ValueError(msg) from e\n        else:\n            return self._cached_collection\n\n    def create_args_schema(self) -> dict[str, BaseModel]:\n        \"\"\"DEPRECATED: This method is deprecated. Please use create_args_schema_v2 instead.\n\n        It is keep only for backward compatibility.\n        \"\"\"\n        logger.warning(\"This is the old way to define the tool parameters. Please use the new way.\")\n        args: dict[str, tuple[Any, Field] | list[str]] = {}\n\n        for key in self.tool_params:\n            if key.startswith(\"!\"):  # Mandatory\n                args[key[1:]] = (str, Field(description=self.tool_params[key]))\n            else:  # Optional\n                args[key] = (str | None, Field(description=self.tool_params[key], default=None))\n\n        if self.use_search_query:\n            args[\"search_query\"] = (\n                str | None,\n                Field(description=\"Search query to find relevant documents.\", default=None),\n            )\n\n        model = create_model(\"ToolInput\", **args, __base__=BaseModel)\n        return {\"ToolInput\": model}\n\n    def create_args_schema_v2(self) -> dict[str, BaseModel]:\n        \"\"\"Create the tool input schema using the new tool parameters configuration.\"\"\"\n        args: dict[str, tuple[Any, Field] | list[str]] = {}\n\n        for tool_param in self.tools_params_v2:\n            if tool_param[\"mandatory\"]:\n                args[tool_param[\"name\"]] = (str, Field(description=tool_param[\"description\"]))\n            else:\n                args[tool_param[\"name\"]] = (str | None, Field(description=tool_param[\"description\"], default=None))\n\n        if self.use_search_query:\n            args[\"search_query\"] = (\n                str,\n                Field(description=self.semantic_search_instruction),\n            )\n\n        model = create_model(\"ToolInput\", **args, __base__=BaseModel)\n        return {\"ToolInput\": model}\n\n    def build_tool(self) -> Tool:\n        \"\"\"Builds an Astra DB Collection tool.\n\n        Returns:\n            Tool: The built Astra DB tool.\n        \"\"\"\n        schema_dict = self.create_args_schema() if len(self.tool_params.keys()) > 0 else self.create_args_schema_v2()\n\n        tool = StructuredTool.from_function(\n            name=self.tool_name,\n            args_schema=schema_dict[\"ToolInput\"],\n            description=self.tool_description,\n            func=self.run_model,\n            return_direct=False,\n        )\n        self.status = \"Astra DB Tool created\"\n\n        return tool\n\n    def projection_args(self, input_str: str) -> dict | None:\n        \"\"\"Build the projection arguments for the AstraDB query.\"\"\"\n        elements = input_str.split(\",\")\n        result = {}\n\n        if elements == [\"*\"]:\n            return None\n\n        # Force the projection to exclude the $vector field as it is not required by the tool\n        result[\"$vector\"] = False\n\n        # Fields with ! as prefix should be removed from the projection\n        for element in elements:\n            if element.startswith(\"!\"):\n                result[element[1:]] = False\n            else:\n                result[element] = True\n\n        return result\n\n    def parse_timestamp(self, timestamp_str: str) -> datetime:\n        \"\"\"Parse a timestamp string into Astra DB REST API format.\n\n        Args:\n            timestamp_str (str): Input timestamp string\n\n        Returns:\n            datetime: Datetime object\n\n        Raises:\n            ValueError: If the timestamp cannot be parsed\n        \"\"\"\n        # Common datetime formats to try\n        formats = [\n            \"%Y-%m-%d\",  # 2024-03-21\n            \"%Y-%m-%dT%H:%M:%S\",  # 2024-03-21T15:30:00\n            \"%Y-%m-%dT%H:%M:%S%z\",  # 2024-03-21T15:30:00+0000\n            \"%Y-%m-%d %H:%M:%S\",  # 2024-03-21 15:30:00\n            \"%d/%m/%Y\",  # 21/03/2024\n            \"%Y/%m/%d\",  # 2024/03/21\n        ]\n\n        for fmt in formats:\n            try:\n                # Parse the date string\n                date_obj = datetime.strptime(timestamp_str, fmt).astimezone()\n\n                # If the parsed date has no timezone info, assume UTC\n                if date_obj.tzinfo is None:\n                    date_obj = date_obj.replace(tzinfo=timezone.utc)\n\n                # Convert to UTC and format\n                return date_obj.astimezone(timezone.utc)\n\n            except ValueError:\n                continue\n\n        msg = f\"Could not parse date: {timestamp_str}\"\n        logger.error(msg)\n        raise ValueError(msg)\n\n    def build_filter(self, args: dict, filter_settings: list) -> dict:\n        \"\"\"Build filter dictionary for AstraDB query.\n\n        Args:\n            args: Dictionary of arguments from the tool\n            filter_settings: List of filter settings from tools_params_v2\n        Returns:\n            Dictionary containing the filter conditions\n        \"\"\"\n        filters = {**self.static_filters}\n\n        for key, value in args.items():\n            # Skip search_query as it's handled separately\n            if key == \"search_query\":\n                continue\n\n            filter_setting = next((x for x in filter_settings if x[\"name\"] == key), None)\n            if filter_setting and value is not None:\n                field_name = filter_setting[\"attribute_name\"] if filter_setting[\"attribute_name\"] else key\n                filter_key = field_name if not filter_setting[\"metadata\"] else f\"metadata.{field_name}\"\n                if filter_setting[\"operator\"] == \"$exists\":\n                    filters[filter_key] = {**filters.get(filter_key, {}), filter_setting[\"operator\"]: True}\n                elif filter_setting[\"operator\"] in [\"$in\", \"$nin\", \"$all\"]:\n                    filters[filter_key] = {\n                        **filters.get(filter_key, {}),\n                        filter_setting[\"operator\"]: value.split(\",\") if isinstance(value, str) else value,\n                    }\n                elif filter_setting[\"is_timestamp\"] == True:  # noqa: E712\n                    try:\n                        filters[filter_key] = {\n                            **filters.get(filter_key, {}),\n                            filter_setting[\"operator\"]: self.parse_timestamp(value),\n                        }\n                    except ValueError as e:\n                        msg = f\"Error parsing timestamp: {e} - Use the prompt to specify the date in the correct format\"\n                        logger.error(msg)\n                        raise ValueError(msg) from e\n                else:\n                    filters[filter_key] = {**filters.get(filter_key, {}), filter_setting[\"operator\"]: value}\n        return filters\n\n    def run_model(self, **args) -> Data | list[Data]:\n        \"\"\"Run the query to get the data from the AstraDB collection.\"\"\"\n        collection = self._build_collection()\n        sort = {}\n\n        # Build filters using the new method\n        filters = self.build_filter(args, self.tools_params_v2)\n\n        # Build the vector search on\n        if self.use_search_query and args[\"search_query\"] is not None and args[\"search_query\"] != \"\":\n            if self.use_vectorize:\n                sort[\"$vectorize\"] = args[\"search_query\"]\n            else:\n                if self.embedding is None:\n                    msg = \"Embedding model is not set. Please set the embedding model or use Astra DB Vectorize.\"\n                    logger.error(msg)\n                    raise ValueError(msg)\n                embedding_query = self.embedding.embed_query(args[\"search_query\"])\n                sort[\"$vector\"] = embedding_query\n            del args[\"search_query\"]\n\n        find_options = {\n            \"filter\": filters,\n            \"limit\": self.number_of_results,\n            \"sort\": sort,\n        }\n\n        projection = self.projection_args(self.projection_attributes)\n        if projection and len(projection) > 0:\n            find_options[\"projection\"] = projection\n\n        try:\n            results = collection.find(**find_options)\n        except Exception as e:\n            msg = f\"Error on Astra DB Tool {self.tool_name} request: {e}\"\n            logger.error(msg)\n            raise ValueError(msg) from e\n\n        logger.info(f\"Tool {self.tool_name} executed`\")\n\n        data: list[Data] = [Data(data=doc) for doc in results]\n        self.status = data\n        return data\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "collection_name": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "collection_name",
        "value": "",
        "display_name": "Collection Name",
        "advanced": false,
        "dynamic": false,
        "info": "The name of the collection within Astra DB where the vectors will be stored.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "keyspace": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "keyspace",
        "value": "default_keyspace",
        "display_name": "Keyspace Name",
        "advanced": true,
        "dynamic": false,
        "info": "The name of the keyspace within Astra where the collection is stored.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "number_of_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "number_of_results",
        "value": 5,
        "display_name": "Number of Results",
        "advanced": true,
        "dynamic": false,
        "info": "Number of results to return.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "projection_attributes": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "projection_attributes",
        "value": "*",
        "display_name": "Projection Attributes",
        "advanced": true,
        "dynamic": false,
        "info": "Attributes to be returned by the tool separated by comma.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "semantic_search_instruction": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "semantic_search_instruction",
        "value": "Search query to find relevant documents.",
        "display_name": "Semantic Search Instruction",
        "advanced": true,
        "dynamic": false,
        "info": "The instruction to use for the semantic search.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "static_filters": {
        "tool_mode": false,
        "trace_as_input": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "static_filters",
        "value": {},
        "display_name": "Static filters",
        "advanced": true,
        "dynamic": false,
        "info": "Attributes to filter and correspoding value",
        "title_case": false,
        "type": "dict",
        "_input_type": "DictInput"
      },
      "token": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "token",
        "value": "ASTRA_DB_APPLICATION_TOKEN",
        "display_name": "Astra DB Application Token",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "Authentication token for accessing Astra DB.",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "tool_description": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "tool_description",
        "value": "",
        "display_name": "Tool Description",
        "advanced": false,
        "dynamic": false,
        "info": "Describe the tool to LLM. Add any information that can help the LLM to use the tool.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "tool_name": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "tool_name",
        "value": "",
        "display_name": "Tool Name",
        "advanced": false,
        "dynamic": false,
        "info": "The name of the tool to be passed to the LLM.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "tool_params": {
        "tool_mode": false,
        "trace_as_input": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "tool_params",
        "value": {},
        "display_name": "Tool params",
        "advanced": true,
        "dynamic": false,
        "info": "DEPRECATED: Attributes to filter and description to the model. Add ! for mandatory (e.g: !customerId)",
        "title_case": false,
        "type": "dict",
        "_input_type": "DictInput"
      },
      "tools_params_v2": {
        "tool_mode": false,
        "is_list": true,
        "list_add_label": "Add More",
        "table_schema": {
          "columns": [
            {
              "name": "name",
              "display_name": "Name",
              "sortable": true,
              "filterable": true,
              "formatter": "text",
              "type": "str",
              "description": "Specify the name of the output field/parameter for the model.",
              "default": "field",
              "disable_edit": false,
              "edit_mode": "inline",
              "hidden": false
            },
            {
              "name": "attribute_name",
              "display_name": "Attribute Name",
              "sortable": true,
              "filterable": true,
              "formatter": "text",
              "type": "str",
              "description": "Specify the attribute name to be filtered on the collection. Leave empty if the attribute name is the same as the name of the field.",
              "default": "",
              "disable_edit": false,
              "edit_mode": "inline",
              "hidden": false
            },
            {
              "name": "description",
              "display_name": "Description",
              "sortable": true,
              "filterable": true,
              "formatter": "text",
              "type": "str",
              "description": "Describe the purpose of the output field.",
              "default": "description of field",
              "disable_edit": false,
              "edit_mode": "popover",
              "hidden": false
            },
            {
              "name": "metadata",
              "display_name": "Is Metadata",
              "options": [
                "True",
                "False"
              ],
              "sortable": true,
              "filterable": true,
              "formatter": "boolean",
              "type": "boolean",
              "description": "Indicate if the field is included in the metadata field.",
              "default": false,
              "disable_edit": false,
              "edit_mode": "inline",
              "hidden": false
            },
            {
              "name": "mandatory",
              "display_name": "Is Mandatory",
              "options": [
                "True",
                "False"
              ],
              "sortable": true,
              "filterable": true,
              "formatter": "boolean",
              "type": "boolean",
              "description": "Indicate if the field is mandatory.",
              "default": false,
              "disable_edit": false,
              "edit_mode": "inline",
              "hidden": false
            },
            {
              "name": "is_timestamp",
              "display_name": "Is Timestamp",
              "options": [
                "True",
                "False"
              ],
              "sortable": true,
              "filterable": true,
              "formatter": "boolean",
              "type": "boolean",
              "description": "Indicate if the field is a timestamp.",
              "default": false,
              "disable_edit": false,
              "edit_mode": "inline",
              "hidden": false
            },
            {
              "name": "operator",
              "display_name": "Operator",
              "options": [
                "$gt",
                "$gte",
                "$lt",
                "$lte",
                "$eq",
                "$ne",
                "$in",
                "$nin",
                "$exists",
                "$all",
                "$size"
              ],
              "sortable": true,
              "filterable": true,
              "formatter": "text",
              "type": "str",
              "description": "Set the operator for the field. https://docs.datastax.com/en/astra-db-serverless/api-reference/documents.html#operators",
              "default": "$eq",
              "disable_edit": false,
              "edit_mode": "inline",
              "hidden": false
            }
          ]
        },
        "trigger_text": "Open table",
        "trigger_icon": "Table",
        "table_icon": "Table",
        "trace_as_metadata": true,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "tools_params_v2",
        "value": [],
        "display_name": "Tools Parameters",
        "advanced": false,
        "dynamic": false,
        "info": "Define the structure for the tool parameters. Describe the parameters in a way the LLM can understand how to use them.",
        "title_case": false,
        "type": "table",
        "_input_type": "TableInput"
      },
      "use_search_query": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "use_search_query",
        "value": false,
        "display_name": "Semantic Search",
        "advanced": false,
        "dynamic": false,
        "info": "When this parameter is activated, the search query parameter will be used to search the collection.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "use_vectorize": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "use_vectorize",
        "value": false,
        "display_name": "Use Astra DB Vectorize",
        "advanced": false,
        "dynamic": false,
        "info": "When this parameter is activated, Astra DB Vectorize method will be used to generate the embeddings.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      }
    },
    "description": "Tool to run hybrid vector and metadata search on DataStax Astra DB Collection",
    "icon": "AstraDB",
    "base_classes": [
      "Data",
      "Tool"
    ],
    "display_name": "Astra DB Tool",
    "documentation": "https://docs.langflow.org/Components/components-tools#astra-db-tool",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "api_run_model",
        "display_name": "Data",
        "method": "run_model",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "api_endpoint",
          "collection_name",
          "projection_attributes",
          "semantic_search_instruction",
          "token",
          "tool_description",
          "tool_name"
        ],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "Tool"
        ],
        "selected": "Tool",
        "name": "api_build_tool",
        "display_name": "Tool",
        "method": "build_tool",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "api_endpoint",
          "collection_name",
          "projection_attributes",
          "semantic_search_instruction",
          "token",
          "tool_description",
          "tool_name"
        ],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "tool_name",
      "tool_description",
      "keyspace",
      "collection_name",
      "token",
      "api_endpoint",
      "projection_attributes",
      "tools_params_v2",
      "tool_params",
      "static_filters",
      "number_of_results",
      "use_search_query",
      "use_vectorize",
      "embedding",
      "semantic_search_instruction"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "YfinanceComponent": {
    "template": {
      "_type": "Component",
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "import ast\nimport pprint\nfrom enum import Enum\n\nimport yfinance as yf\nfrom langchain_core.tools import ToolException\nfrom loguru import logger\nfrom pydantic import BaseModel, Field\n\nfrom langflow.custom import Component\nfrom langflow.inputs import DropdownInput, IntInput, MessageTextInput\nfrom langflow.io import Output\nfrom langflow.schema import Data, DataFrame\nfrom langflow.schema.message import Message\n\n\nclass YahooFinanceMethod(Enum):\n    GET_INFO = \"get_info\"\n    GET_NEWS = \"get_news\"\n    GET_ACTIONS = \"get_actions\"\n    GET_ANALYSIS = \"get_analysis\"\n    GET_BALANCE_SHEET = \"get_balance_sheet\"\n    GET_CALENDAR = \"get_calendar\"\n    GET_CASHFLOW = \"get_cashflow\"\n    GET_INSTITUTIONAL_HOLDERS = \"get_institutional_holders\"\n    GET_RECOMMENDATIONS = \"get_recommendations\"\n    GET_SUSTAINABILITY = \"get_sustainability\"\n    GET_MAJOR_HOLDERS = \"get_major_holders\"\n    GET_MUTUALFUND_HOLDERS = \"get_mutualfund_holders\"\n    GET_INSIDER_PURCHASES = \"get_insider_purchases\"\n    GET_INSIDER_TRANSACTIONS = \"get_insider_transactions\"\n    GET_INSIDER_ROSTER_HOLDERS = \"get_insider_roster_holders\"\n    GET_DIVIDENDS = \"get_dividends\"\n    GET_CAPITAL_GAINS = \"get_capital_gains\"\n    GET_SPLITS = \"get_splits\"\n    GET_SHARES = \"get_shares\"\n    GET_FAST_INFO = \"get_fast_info\"\n    GET_SEC_FILINGS = \"get_sec_filings\"\n    GET_RECOMMENDATIONS_SUMMARY = \"get_recommendations_summary\"\n    GET_UPGRADES_DOWNGRADES = \"get_upgrades_downgrades\"\n    GET_EARNINGS = \"get_earnings\"\n    GET_INCOME_STMT = \"get_income_stmt\"\n\n\nclass YahooFinanceSchema(BaseModel):\n    symbol: str = Field(..., description=\"The stock symbol to retrieve data for.\")\n    method: YahooFinanceMethod = Field(YahooFinanceMethod.GET_INFO, description=\"The type of data to retrieve.\")\n    num_news: int | None = Field(5, description=\"The number of news articles to retrieve.\")\n\n\nclass YfinanceComponent(Component):\n    display_name = \"Yahoo Finance\"\n    description = \"\"\"Uses [yfinance](https://pypi.org/project/yfinance/) (unofficial package) \\\nto access financial data and market information from Yahoo Finance.\"\"\"\n    icon = \"trending-up\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"symbol\",\n            display_name=\"Stock Symbol\",\n            info=\"The stock symbol to retrieve data for (e.g., AAPL, GOOG).\",\n            tool_mode=True,\n        ),\n        DropdownInput(\n            name=\"method\",\n            display_name=\"Data Method\",\n            info=\"The type of data to retrieve.\",\n            options=list(YahooFinanceMethod),\n            value=\"get_news\",\n        ),\n        IntInput(\n            name=\"num_news\",\n            display_name=\"Number of News\",\n            info=\"The number of news articles to retrieve (only applicable for get_news).\",\n            value=5,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"fetch_content\"),\n        Output(display_name=\"Text\", name=\"text\", method=\"fetch_content_text\"),\n        Output(display_name=\"DataFrame\", name=\"dataframe\", method=\"as_dataframe\"),\n    ]\n\n    def run_model(self) -> list[Data]:\n        return self.fetch_content()\n\n    def fetch_content_text(self) -> Message:\n        data = self.fetch_content()\n        result_string = \"\"\n        for item in data:\n            result_string += item.text + \"\\n\"\n        self.status = result_string\n        return Message(text=result_string)\n\n    def _fetch_yfinance_data(self, ticker: yf.Ticker, method: YahooFinanceMethod, num_news: int | None) -> str:\n        try:\n            if method == YahooFinanceMethod.GET_INFO:\n                result = ticker.info\n            elif method == YahooFinanceMethod.GET_NEWS:\n                result = ticker.news[:num_news]\n            else:\n                result = getattr(ticker, method.value)()\n            return pprint.pformat(result)\n        except Exception as e:\n            error_message = f\"Error retrieving data: {e}\"\n            logger.debug(error_message)\n            self.status = error_message\n            raise ToolException(error_message) from e\n\n    def fetch_content(self) -> list[Data]:\n        try:\n            return self._yahoo_finance_tool(\n                self.symbol,\n                YahooFinanceMethod(self.method),\n                self.num_news,\n            )\n        except ToolException:\n            raise\n        except Exception as e:\n            error_message = f\"Unexpected error: {e}\"\n            logger.debug(error_message)\n            self.status = error_message\n            raise ToolException(error_message) from e\n\n    def _yahoo_finance_tool(\n        self,\n        symbol: str,\n        method: YahooFinanceMethod,\n        num_news: int | None = 5,\n    ) -> list[Data]:\n        ticker = yf.Ticker(symbol)\n        result = self._fetch_yfinance_data(ticker, method, num_news)\n\n        if method == YahooFinanceMethod.GET_NEWS:\n            data_list = [\n                Data(text=f\"{article['title']}: {article['link']}\", data=article)\n                for article in ast.literal_eval(result)\n            ]\n        else:\n            data_list = [Data(text=result, data={\"result\": result})]\n\n        return data_list\n\n    def as_dataframe(self) -> DataFrame:\n        \"\"\"Convert the Yahoo search results to a DataFrame.\n\n        Returns:\n            DataFrame: A DataFrame containing the search results.\n        \"\"\"\n        data = self.fetch_content()\n        return DataFrame(data)\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "method": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "get_info",
          "get_news",
          "get_actions",
          "get_analysis",
          "get_balance_sheet",
          "get_calendar",
          "get_cashflow",
          "get_institutional_holders",
          "get_recommendations",
          "get_sustainability",
          "get_major_holders",
          "get_mutualfund_holders",
          "get_insider_purchases",
          "get_insider_transactions",
          "get_insider_roster_holders",
          "get_dividends",
          "get_capital_gains",
          "get_splits",
          "get_shares",
          "get_fast_info",
          "get_sec_filings",
          "get_recommendations_summary",
          "get_upgrades_downgrades",
          "get_earnings",
          "get_income_stmt"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "method",
        "value": "get_news",
        "display_name": "Data Method",
        "advanced": false,
        "dynamic": false,
        "info": "The type of data to retrieve.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "num_news": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "num_news",
        "value": 5,
        "display_name": "Number of News",
        "advanced": false,
        "dynamic": false,
        "info": "The number of news articles to retrieve (only applicable for get_news).",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "symbol": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "symbol",
        "value": "",
        "display_name": "Stock Symbol",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The stock symbol to retrieve data for (e.g., AAPL, GOOG).",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      }
    },
    "description": "Uses [yfinance](https://pypi.org/project/yfinance/) (unofficial package) to access financial data and market information from Yahoo Finance.",
    "icon": "trending-up",
    "base_classes": [
      "Data",
      "DataFrame",
      "Message"
    ],
    "display_name": "Yahoo Finance",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "data",
        "display_name": "Data",
        "method": "fetch_content",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "Message"
        ],
        "selected": "Message",
        "name": "text",
        "display_name": "Text",
        "method": "fetch_content_text",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "symbol",
      "method",
      "num_news"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "MCPTools": {
    "template": {
      "_type": "Component",
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "import os\nfrom typing import Any\n\nimport httpx\nfrom langchain_core.tools import StructuredTool\n\nfrom langflow.base.mcp.util import (\n    HTTP_ERROR_STATUS_CODE,\n    MCPSseClient,\n    MCPStdioClient,\n    create_input_schema_from_json_schema,\n    create_tool_coroutine,\n    create_tool_func,\n)\nfrom langflow.custom import Component\nfrom langflow.inputs import DropdownInput\nfrom langflow.inputs.inputs import InputTypes\nfrom langflow.io import MessageTextInput, MultilineInput, Output, TabInput\nfrom langflow.io.schema import schema_to_langflow_inputs\nfrom langflow.logging import logger\nfrom langflow.schema import Message\n\n\nclass MCPToolsComponent(Component):\n    schema_inputs: list[InputTypes] = []\n    stdio_client: MCPStdioClient = MCPStdioClient()\n    sse_client: MCPSseClient = MCPSseClient()\n    tools: list = []\n    tool_names: list[str] = []\n    _tool_cache: dict = {}  # Cache for tool objects\n    default_keys: list[str] = [\"code\", \"_type\", \"mode\", \"command\", \"sse_url\", \"tool_placeholder\", \"tool_mode\", \"tool\"]\n\n    display_name = \"MCP Server\"\n    description = \"Connect to an MCP server and expose tools.\"\n    icon = \"server\"\n    name = \"MCPTools\"\n\n    inputs = [\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Stdio\", \"SSE\"],\n            value=\"Stdio\",\n            info=\"Select the connection mode\",\n            real_time_refresh=True,\n        ),\n        MessageTextInput(\n            name=\"command\",\n            display_name=\"MCP Command\",\n            info=\"Command for MCP stdio connection\",\n            value=\"uvx mcp-server-fetch\",\n            show=True,\n            refresh_button=True,\n        ),\n        MultilineInput(\n            name=\"sse_url\",\n            display_name=\"MCP SSE URL\",\n            info=\"URL for MCP SSE connection\",\n            show=False,\n            refresh_button=True,\n        ),\n        DropdownInput(\n            name=\"tool\",\n            display_name=\"Tool\",\n            options=[],\n            value=\"\",\n            info=\"Select the tool to execute\",\n            show=True,\n            required=True,\n            real_time_refresh=True,\n        ),\n        MessageTextInput(\n            name=\"tool_placeholder\",\n            display_name=\"Tool Placeholder\",\n            info=\"Placeholder for the tool\",\n            value=\"\",\n            show=False,\n            tool_mode=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Response\", name=\"response\", method=\"build_output\"),\n    ]\n\n    async def find_langflow_instance(self) -> tuple[bool, int | None, str]:\n        \"\"\"Find Langflow instance by checking env variable first, then scanning common ports.\"\"\"\n        # First check environment variable\n        env_port = os.getenv(\"LANGFLOW_PORT\")\n        port = int(env_port) if env_port else 7860\n        try:\n            url = f\"http://localhost:{port}/api/v1/mcp/sse\"\n            async with httpx.AsyncClient() as client:\n                response = await client.head(url, timeout=2.0)\n                if response.status_code < HTTP_ERROR_STATUS_CODE:\n                    return True, port, f\"Langflow instance found at configured port {port}\"\n        except (ValueError, httpx.TimeoutException, httpx.NetworkError, httpx.HTTPError):\n            logger.warning(f\"Could not connect to Langflow at configured port {env_port}\")\n        return False, None, \"No Langflow instance found on configured port or common ports\"\n\n    async def _validate_connection_params(self, mode: str, command: str | None = None, url: str | None = None) -> None:\n        \"\"\"Validate connection parameters based on mode.\"\"\"\n        if mode not in [\"Stdio\", \"SSE\"]:\n            msg = f\"Invalid mode: {mode}. Must be either 'Stdio' or 'SSE'\"\n            raise ValueError(msg)\n\n        if mode == \"Stdio\" and not command:\n            msg = \"Command is required for Stdio mode\"\n            raise ValueError(msg)\n        if mode == \"SSE\" and not url:\n            msg = \"URL is required for SSE mode\"\n            raise ValueError(msg)\n\n    async def _validate_schema_inputs(self, tool_obj) -> list[InputTypes]:\n        \"\"\"Validate and process schema inputs for a tool.\"\"\"\n        try:\n            if not tool_obj or not hasattr(tool_obj, \"inputSchema\"):\n                msg = \"Invalid tool object or missing input schema\"\n                raise ValueError(msg)\n\n            input_schema = create_input_schema_from_json_schema(tool_obj.inputSchema)\n            if not input_schema:\n                msg = f\"Empty input schema for tool '{tool_obj.name}'\"\n                raise ValueError(msg)\n\n            schema_inputs = schema_to_langflow_inputs(input_schema)\n            if not schema_inputs:\n                msg = f\"No input parameters defined for tool '{tool_obj.name}'\"\n                logger.warning(msg)\n                return []\n\n        except Exception as e:\n            msg = f\"Error validating schema inputs: {e!s}\"\n            logger.exception(msg)\n            raise ValueError(msg) from e\n        else:\n            return schema_inputs\n\n    async def update_build_config(self, build_config: dict, field_value: str, field_name: str | None = None) -> dict:\n        \"\"\"Toggle the visibility of connection-specific fields based on the selected mode.\"\"\"\n        try:\n            if field_name == \"mode\":\n                self.remove_non_default_keys(build_config)\n                if field_value == \"Stdio\":\n                    build_config[\"command\"][\"show\"] = True\n                    build_config[\"sse_url\"][\"show\"] = False\n                elif field_value == \"SSE\":\n                    build_config[\"command\"][\"show\"] = False\n                    build_config[\"sse_url\"][\"show\"] = True\n                    build_config[\"sse_url\"][\"value\"] = \"MCP_SSE\"\n                    return build_config\n            if field_name in (\"command\", \"sse_url\", \"mode\"):\n                try:\n                    # If SSE mode and localhost URL is not valid, try to find correct port\n                    if build_config[\"mode\"][\"value\"] == \"SSE\" and (\n                        \"localhost\" in str(build_config[\"sse_url\"][\"value\"])\n                        or \"127.0.0.1\" in str(build_config[\"sse_url\"][\"value\"])\n                    ):\n                        is_valid, _ = await self.sse_client.validate_url(build_config[\"sse_url\"][\"value\"])\n                        if not is_valid:\n                            found, port, message = await self.find_langflow_instance()\n                            if found:\n                                new_url = f\"http://localhost:{port}/api/v1/mcp/sse\"\n                                logger.info(f\"Original URL {build_config['sse_url']['value']} not valid. {message}\")\n                                build_config[\"sse_url\"][\"value\"] = new_url\n                    elif build_config[\"mode\"][\"value\"] == \"SSE\":\n                        if len(build_config[\"sse_url\"][\"value\"]) > 0:\n                            is_valid, _ = await self.sse_client.validate_url(build_config[\"sse_url\"][\"value\"])\n                            if not is_valid:\n                                msg = (\n                                    f\"Invalid SSE URL configuration: {build_config['sse_url']['value']}. \"\n                                    \"Please check the SSE URL and try again.\"\n                                )\n                                raise ValueError(msg)\n                        else:\n                            build_config[\"tool\"][\"options\"] = []\n                            return build_config\n\n                    await self.update_tools(\n                        mode=build_config[\"mode\"][\"value\"],\n                        command=build_config[\"command\"][\"value\"],\n                        url=build_config[\"sse_url\"][\"value\"],\n                    )\n                    if \"tool\" in build_config:\n                        build_config[\"tool\"][\"options\"] = self.tool_names\n                except Exception as e:\n                    build_config[\"tool\"][\"options\"] = []\n                    msg = f\"Failed to update tools: {e!s}\"\n                    raise ValueError(msg) from e\n                else:\n                    return build_config\n            elif field_name == \"tool\":\n                if len(self.tools) == 0:\n                    await self.update_tools(\n                        mode=build_config[\"mode\"][\"value\"],\n                        command=build_config[\"command\"][\"value\"],\n                        url=build_config[\"sse_url\"][\"value\"],\n                    )\n                if self.tool is None:\n                    return build_config\n                tool_obj = None\n                for tool in self.tools:\n                    if tool.name == self.tool:\n                        tool_obj = tool\n                        break\n                if tool_obj is None:\n                    msg = f\"Tool {self.tool} not found in available tools: {self.tools}\"\n                    logger.warning(msg)\n                    return build_config\n                self.remove_non_default_keys(build_config)\n                await self._update_tool_config(build_config, field_value)\n            elif field_name == \"tool_mode\":\n                build_config[\"tool\"][\"show\"] = not field_value\n                for key, value in list(build_config.items()):\n                    if key not in self.default_keys and isinstance(value, dict) and \"show\" in value:\n                        build_config[key][\"show\"] = not field_value\n\n        except Exception as e:\n            msg = f\"Error in update_build_config: {e!s}\"\n            logger.exception(msg)\n            raise ValueError(msg) from e\n        else:\n            return build_config\n\n    def get_inputs_for_all_tools(self, tools: list) -> dict:\n        \"\"\"Get input schemas for all tools.\"\"\"\n        inputs = {}\n        for tool in tools:\n            if not tool or not hasattr(tool, \"name\"):\n                continue\n            try:\n                input_schema = schema_to_langflow_inputs(create_input_schema_from_json_schema(tool.inputSchema))\n                inputs[tool.name] = input_schema\n            except (AttributeError, ValueError, TypeError, KeyError) as e:\n                msg = f\"Error getting inputs for tool {getattr(tool, 'name', 'unknown')}: {e!s}\"\n                logger.exception(msg)\n                continue\n        return inputs\n\n    def remove_input_schema_from_build_config(\n        self, build_config: dict, tool_name: str, input_schema: dict[list[InputTypes], Any]\n    ):\n        \"\"\"Remove the input schema for the tool from the build config.\"\"\"\n        # Keep only schemas that don't belong to the current tool\n        input_schema = {k: v for k, v in input_schema.items() if k != tool_name}\n        # Remove all inputs from other tools\n        for value in input_schema.values():\n            for _input in value:\n                if _input.name in build_config:\n                    build_config.pop(_input.name)\n\n    def remove_non_default_keys(self, build_config: dict) -> None:\n        \"\"\"Remove non-default keys from the build config.\"\"\"\n        for key in list(build_config.keys()):\n            if key not in self.default_keys:\n                build_config.pop(key)\n\n    async def _update_tool_config(self, build_config: dict, tool_name: str) -> None:\n        \"\"\"Update tool configuration with proper error handling.\"\"\"\n        if not self.tools:\n            await self.update_tools(\n                mode=build_config[\"mode\"][\"value\"],\n                command=build_config[\"command\"][\"value\"],\n                url=build_config[\"sse_url\"][\"value\"],\n            )\n\n        if not tool_name:\n            return\n\n        tool_obj = next((tool for tool in self.tools if tool.name == tool_name), None)\n        if not tool_obj:\n            msg = f\"Tool {tool_name} not found in available tools: {self.tools}\"\n            logger.warning(msg)\n            return\n\n        try:\n            # Get all tool inputs and remove old ones\n            input_schema_for_all_tools = self.get_inputs_for_all_tools(self.tools)\n            self.remove_input_schema_from_build_config(build_config, tool_name, input_schema_for_all_tools)\n\n            # Get and validate new inputs\n            self.schema_inputs = await self._validate_schema_inputs(tool_obj)\n            if not self.schema_inputs:\n                msg = f\"No input parameters to configure for tool '{tool_name}'\"\n                logger.info(msg)\n                return\n\n            # Add new inputs to build config\n            for schema_input in self.schema_inputs:\n                if not schema_input or not hasattr(schema_input, \"name\"):\n                    msg = \"Invalid schema input detected, skipping\"\n                    logger.warning(msg)\n                    continue\n\n                try:\n                    name = schema_input.name\n                    input_dict = schema_input.to_dict()\n                    input_dict.setdefault(\"value\", None)\n                    input_dict.setdefault(\"required\", True)\n                    build_config[name] = input_dict\n                except (AttributeError, KeyError, TypeError) as e:\n                    msg = f\"Error processing schema input {schema_input}: {e!s}\"\n                    logger.exception(msg)\n                    continue\n\n        except ValueError as e:\n            msg = f\"Schema validation error for tool {tool_name}: {e!s}\"\n            logger.exception(msg)\n            self.schema_inputs = []\n            return\n        except (AttributeError, KeyError, TypeError) as e:\n            msg = f\"Error updating tool config: {e!s}\"\n            logger.exception(msg)\n            raise ValueError(msg) from e\n\n    async def build_output(self) -> Message:\n        \"\"\"Build output with improved error handling and validation.\"\"\"\n        try:\n            await self.update_tools()\n            if self.tool != \"\":\n                exec_tool = self._tool_cache[self.tool]\n                tool_args = self.get_inputs_for_all_tools(self.tools)[self.tool]\n                kwargs = {}\n                for arg in tool_args:\n                    value = getattr(self, arg.name, None)\n                    if value:\n                        kwargs[arg.name] = value\n                output = await exec_tool.coroutine(**kwargs)\n                return Message(text=output.content[len(output.content) - 1].text)\n            return Message(text=\"You must select a tool\", error=True)\n        except Exception as e:\n            msg = f\"Error in build_output: {e!s}\"\n            logger.exception(msg)\n            raise ValueError(msg) from e\n\n    async def update_tools(\n        self, mode: str | None = None, command: str | None = None, url: str | None = None\n    ) -> list[StructuredTool]:\n        \"\"\"Connect to the MCP server and update available tools with improved error handling.\"\"\"\n        try:\n            if mode is None:\n                mode = self.mode\n            if command is None:\n                command = self.command\n            if url is None:\n                url = self.sse_url\n            await self._validate_connection_params(mode, command, url)\n\n            if mode == \"Stdio\":\n                if not self.stdio_client.session:\n                    self.tools = await self.stdio_client.connect_to_server(command)\n            elif mode == \"SSE\" and not self.sse_client.session:\n                try:\n                    is_valid, _ = await self.sse_client.validate_url(url)\n                    if not is_valid:\n                        msg = f\"Invalid SSE URL configuration: {url}. Please check the SSE URL and try again.\"\n                        logger.error(msg)\n                        return []\n                    self.tools = await self.sse_client.connect_to_server(url, {})\n                except ValueError as e:\n                    # URL validation error\n                    logger.error(f\"SSE URL validation error: {e}\")\n                    msg = f\"Invalid SSE URL configuration: {e}. Please check your Langflow deployment URL and port.\"\n                    raise ValueError(msg) from e\n                except ConnectionError as e:\n                    # Connection failed after retries\n                    logger.error(f\"SSE connection error: {e}\")\n                    msg = (\n                        f\"Could not connect to Langflow SSE endpoint: {e}. \"\n                        \"Please verify:\\n\"\n                        \"1. Langflow server is running\\n\"\n                        \"2. The SSE URL matches your Langflow deployment port\\n\"\n                        \"3. There are no network issues preventing the connection\"\n                    )\n                    raise ValueError(msg) from e\n                except Exception as e:\n                    logger.error(f\"Unexpected SSE error: {e}\")\n                    msg = f\"Unexpected error connecting to SSE endpoint: {e}\"\n                    raise ValueError(msg) from e\n\n            if not self.tools:\n                logger.warning(\"No tools returned from server\")\n                return []\n\n            tool_list = []\n            for tool in self.tools:\n                if not tool or not hasattr(tool, \"name\"):\n                    logger.warning(\"Invalid tool object detected, skipping\")\n                    continue\n\n                try:\n                    args_schema = create_input_schema_from_json_schema(tool.inputSchema)\n                    if not args_schema:\n                        logger.warning(f\"Empty schema for tool '{tool.name}', skipping\")\n                        continue\n\n                    client = self.stdio_client if self.mode == \"Stdio\" else self.sse_client\n                    if not client or not client.session:\n                        msg = f\"Invalid client session for tool '{tool.name}'\"\n                        raise ValueError(msg)\n\n                    tool_obj = StructuredTool(\n                        name=tool.name,\n                        description=tool.description or \"\",\n                        args_schema=args_schema,\n                        func=create_tool_func(tool.name, args_schema, client.session),\n                        coroutine=create_tool_coroutine(tool.name, args_schema, client.session),\n                        tags=[tool.name],\n                    )\n                    tool_list.append(tool_obj)\n                    self._tool_cache[tool.name] = tool_obj\n                except (AttributeError, ValueError, TypeError, KeyError) as e:\n                    msg = f\"Error creating tool {getattr(tool, 'name', 'unknown')}: {e}\"\n                    logger.exception(msg)\n                    continue\n\n            self.tool_names = [tool.name for tool in self.tools if hasattr(tool, \"name\")]\n\n        except ValueError as e:\n            # Re-raise validation errors with clear messages\n            raise ValueError(str(e)) from e\n        except Exception as e:\n            logger.exception(\"Error updating tools\")\n            msg = f\"Failed to update tools: {e!s}\"\n            raise ValueError(msg) from e\n        else:\n            return tool_list\n\n    async def _get_tools(self):\n        \"\"\"Get cached tools or update if necessary.\"\"\"\n        # if not self.tools:\n        if self.mode == \"SSE\" and self.sse_url is None:\n            msg = \"SSE URL is not set\"\n            raise ValueError(msg)\n        return await self.update_tools()\n        # return self.tools\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "command": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "command",
        "value": "uvx mcp-server-fetch",
        "display_name": "MCP Command",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Command for MCP stdio connection",
        "refresh_button": true,
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "mode": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "Stdio",
          "SSE"
        ],
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "mode",
        "value": "Stdio",
        "display_name": "Mode",
        "advanced": false,
        "dynamic": false,
        "info": "Select the connection mode",
        "real_time_refresh": true,
        "title_case": false,
        "type": "tab",
        "_input_type": "TabInput"
      },
      "sse_url": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": false,
        "name": "sse_url",
        "value": "",
        "display_name": "MCP SSE URL",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "URL for MCP SSE connection",
        "refresh_button": true,
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "tool": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "tool",
        "value": "",
        "display_name": "Tool",
        "advanced": false,
        "dynamic": false,
        "info": "Select the tool to execute",
        "real_time_refresh": true,
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "tool_placeholder": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": false,
        "name": "tool_placeholder",
        "value": "",
        "display_name": "Tool Placeholder",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Placeholder for the tool",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      }
    },
    "description": "Connect to an MCP server and expose tools.",
    "icon": "server",
    "base_classes": [
      "Message"
    ],
    "display_name": "MCP Server",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Message"
        ],
        "selected": "Message",
        "name": "response",
        "display_name": "Response",
        "method": "build_output",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "mode",
      "command",
      "sse_url",
      "tool",
      "tool_placeholder"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "SearXNGTool": {
    "template": {
      "_type": "Component",
      "categories": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [],
        "combobox": false,
        "toggle": false,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "categories",
        "value": [],
        "display_name": "Categories",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "MultiselectInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "import json\nfrom collections.abc import Sequence\nfrom typing import Any\n\nimport requests\nfrom langchain.agents import Tool\nfrom langchain_core.tools import StructuredTool\nfrom loguru import logger\nfrom pydantic.v1 import Field, create_model\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.inputs import DropdownInput, IntInput, MessageTextInput, MultiselectInput\nfrom langflow.io import Output\nfrom langflow.schema.dotdict import dotdict\n\n\nclass SearXNGToolComponent(LCToolComponent):\n    search_headers: dict = {}\n    display_name = \"SearXNG Search\"\n    description = \"A component that searches for tools using SearXNG.\"\n    name = \"SearXNGTool\"\n    legacy: bool = True\n\n    inputs = [\n        MessageTextInput(\n            name=\"url\",\n            display_name=\"URL\",\n            value=\"http://localhost\",\n            required=True,\n            refresh_button=True,\n        ),\n        IntInput(\n            name=\"max_results\",\n            display_name=\"Max Results\",\n            value=10,\n            required=True,\n        ),\n        MultiselectInput(\n            name=\"categories\",\n            display_name=\"Categories\",\n            options=[],\n            value=[],\n        ),\n        DropdownInput(\n            name=\"language\",\n            display_name=\"Language\",\n            options=[],\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Tool\", name=\"result_tool\", method=\"build_tool\"),\n    ]\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None) -> dotdict:\n        if field_name is None:\n            return build_config\n\n        if field_name != \"url\":\n            return build_config\n\n        try:\n            url = f\"{field_value}/config\"\n\n            response = requests.get(url=url, headers=self.search_headers.copy(), timeout=10)\n            data = None\n            if response.headers.get(\"Content-Encoding\") == \"zstd\":\n                data = json.loads(response.content)\n            else:\n                data = response.json()\n            build_config[\"categories\"][\"options\"] = data[\"categories\"].copy()\n            for selected_category in build_config[\"categories\"][\"value\"]:\n                if selected_category not in build_config[\"categories\"][\"options\"]:\n                    build_config[\"categories\"][\"value\"].remove(selected_category)\n            languages = list(data[\"locales\"])\n            build_config[\"language\"][\"options\"] = languages.copy()\n        except Exception as e:  # noqa: BLE001\n            self.status = f\"Failed to extract names: {e}\"\n            logger.opt(exception=True).debug(self.status)\n            build_config[\"categories\"][\"options\"] = [\"Failed to parse\", str(e)]\n        return build_config\n\n    def build_tool(self) -> Tool:\n        class SearxSearch:\n            _url: str = \"\"\n            _categories: list[str] = []\n            _language: str = \"\"\n            _headers: dict = {}\n            _max_results: int = 10\n\n            @staticmethod\n            def search(query: str, categories: Sequence[str] = ()) -> list:\n                if not SearxSearch._categories and not categories:\n                    msg = \"No categories provided.\"\n                    raise ValueError(msg)\n                all_categories = SearxSearch._categories + list(set(categories) - set(SearxSearch._categories))\n                try:\n                    url = f\"{SearxSearch._url}/\"\n                    headers = SearxSearch._headers.copy()\n                    response = requests.get(\n                        url=url,\n                        headers=headers,\n                        params={\n                            \"q\": query,\n                            \"categories\": \",\".join(all_categories),\n                            \"language\": SearxSearch._language,\n                            \"format\": \"json\",\n                        },\n                        timeout=10,\n                    ).json()\n\n                    num_results = min(SearxSearch._max_results, len(response[\"results\"]))\n                    return [response[\"results\"][i] for i in range(num_results)]\n                except Exception as e:  # noqa: BLE001\n                    logger.opt(exception=True).debug(\"Error running SearXNG Search\")\n                    return [f\"Failed to search: {e}\"]\n\n        SearxSearch._url = self.url\n        SearxSearch._categories = self.categories.copy()\n        SearxSearch._language = self.language\n        SearxSearch._headers = self.search_headers.copy()\n        SearxSearch._max_results = self.max_results\n\n        globals_ = globals()\n        local = {}\n        local[\"SearxSearch\"] = SearxSearch\n        globals_.update(local)\n\n        schema_fields = {\n            \"query\": (str, Field(..., description=\"The query to search for.\")),\n            \"categories\": (\n                list[str],\n                Field(default=[], description=\"The categories to search in.\"),\n            ),\n        }\n\n        searx_search_schema = create_model(\"SearxSearchSchema\", **schema_fields)\n\n        return StructuredTool.from_function(\n            func=local[\"SearxSearch\"].search,\n            args_schema=searx_search_schema,\n            name=\"searxng_search_tool\",\n            description=\"A tool that searches for tools using SearXNG.\\nThe available categories are: \"\n            + \", \".join(self.categories),\n        )\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "language": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "language",
        "value": "",
        "display_name": "Language",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "max_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "max_results",
        "value": 10,
        "display_name": "Max Results",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "url": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "url",
        "value": "http://localhost",
        "display_name": "URL",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "",
        "refresh_button": true,
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      }
    },
    "description": "A component that searches for tools using SearXNG.",
    "base_classes": [
      "Tool"
    ],
    "display_name": "SearXNG Search",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Tool"
        ],
        "selected": "Tool",
        "name": "result_tool",
        "display_name": "Tool",
        "method": "build_tool",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "url",
      "max_results",
      "categories",
      "language"
    ],
    "beta": false,
    "legacy": true,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "ExaSearch": {
    "template": {
      "_type": "Component",
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain_core.tools import tool\nfrom metaphor_python import Metaphor\n\nfrom langflow.custom import Component\nfrom langflow.field_typing import Tool\nfrom langflow.io import BoolInput, IntInput, Output, SecretStrInput\n\n\nclass ExaSearchToolkit(Component):\n    display_name = \"Exa Search\"\n    description = \"Exa Search toolkit for search and content retrieval\"\n    documentation = \"https://python.langchain.com/docs/integrations/tools/metaphor_search\"\n    beta = True\n    name = \"ExaSearch\"\n    icon = \"ExaSearch\"\n\n    inputs = [\n        SecretStrInput(\n            name=\"metaphor_api_key\",\n            display_name=\"Exa Search API Key\",\n            password=True,\n        ),\n        BoolInput(\n            name=\"use_autoprompt\",\n            display_name=\"Use Autoprompt\",\n            value=True,\n        ),\n        IntInput(\n            name=\"search_num_results\",\n            display_name=\"Search Number of Results\",\n            value=5,\n        ),\n        IntInput(\n            name=\"similar_num_results\",\n            display_name=\"Similar Number of Results\",\n            value=5,\n        ),\n    ]\n\n    outputs = [\n        Output(name=\"tools\", display_name=\"Tools\", method=\"build_toolkit\"),\n    ]\n\n    def build_toolkit(self) -> Tool:\n        client = Metaphor(api_key=self.metaphor_api_key)\n\n        @tool\n        def search(query: str):\n            \"\"\"Call search engine with a query.\"\"\"\n            return client.search(query, use_autoprompt=self.use_autoprompt, num_results=self.search_num_results)\n\n        @tool\n        def get_contents(ids: list[str]):\n            \"\"\"Get contents of a webpage.\n\n            The ids passed in should be a list of ids as fetched from `search`.\n            \"\"\"\n            return client.get_contents(ids)\n\n        @tool\n        def find_similar(url: str):\n            \"\"\"Get search results similar to a given URL.\n\n            The url passed in should be a URL returned from `search`\n            \"\"\"\n            return client.find_similar(url, num_results=self.similar_num_results)\n\n        return [search, get_contents, find_similar]\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "metaphor_api_key": {
        "load_from_db": true,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "metaphor_api_key",
        "value": "",
        "display_name": "Exa Search API Key",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "search_num_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_num_results",
        "value": 5,
        "display_name": "Search Number of Results",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "similar_num_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "similar_num_results",
        "value": 5,
        "display_name": "Similar Number of Results",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "use_autoprompt": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "use_autoprompt",
        "value": true,
        "display_name": "Use Autoprompt",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      }
    },
    "description": "Exa Search toolkit for search and content retrieval",
    "icon": "ExaSearch",
    "base_classes": [
      "Tool"
    ],
    "display_name": "Exa Search",
    "documentation": "https://python.langchain.com/docs/integrations/tools/metaphor_search",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Tool"
        ],
        "selected": "Tool",
        "name": "tools",
        "display_name": "Tools",
        "method": "build_toolkit",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "metaphor_api_key",
      "use_autoprompt",
      "search_num_results",
      "similar_num_results"
    ],
    "beta": true,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "WolframAlphaAPI": {
    "template": {
      "_type": "Component",
      "app_id": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "app_id",
        "value": "",
        "display_name": "App ID",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain_community.utilities.wolfram_alpha import WolframAlphaAPIWrapper\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import MultilineInput, SecretStrInput\nfrom langflow.io import Output\nfrom langflow.schema import Data, DataFrame\n\n\nclass WolframAlphaAPIComponent(LCToolComponent):\n    display_name = \"WolframAlpha API\"\n    description = \"\"\"Enables queries to Wolfram Alpha for computational data, facts, and calculations across various \\\ntopics, delivering structured responses.\"\"\"\n    name = \"WolframAlphaAPI\"\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"run_model\"),\n        Output(display_name=\"DataFrame\", name=\"dataframe\", method=\"as_dataframe\"),\n    ]\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\", display_name=\"Input Query\", info=\"Example query: 'What is the population of France?'\"\n        ),\n        SecretStrInput(name=\"app_id\", display_name=\"App ID\", required=True),\n    ]\n\n    icon = \"WolframAlphaAPI\"\n\n    def run_model(self) -> list[Data]:\n        wrapper = self._build_wrapper()\n        result_str = wrapper.run(self.input_value)\n        data = [Data(text=result_str)]\n        self.status = data\n        return data\n\n    def build_tool(self) -> Tool:\n        wrapper = self._build_wrapper()\n        return Tool(name=\"wolfram_alpha_api\", description=\"Answers mathematical questions.\", func=wrapper.run)\n\n    def _build_wrapper(self) -> WolframAlphaAPIWrapper:\n        return WolframAlphaAPIWrapper(wolfram_alpha_appid=self.app_id)\n\n    def as_dataframe(self) -> DataFrame:\n        \"\"\"Convert the Wolfram Alpha results to a DataFrame.\n\n        Returns:\n            DataFrame: A DataFrame containing the query results.\n        \"\"\"\n        data = self.run_model()\n        return DataFrame(data)\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "input_value": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "input_value",
        "value": "",
        "display_name": "Input Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Example query: 'What is the population of France?'",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      }
    },
    "description": "Enables queries to Wolfram Alpha for computational data, facts, and calculations across various topics, delivering structured responses.",
    "icon": "WolframAlphaAPI",
    "base_classes": [
      "Data",
      "DataFrame"
    ],
    "display_name": "WolframAlpha API",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "data",
        "display_name": "Data",
        "method": "run_model",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "input_value",
      "app_id"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "GoogleSearchAPICore": {
    "template": {
      "_type": "Component",
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain_google_community import GoogleSearchAPIWrapper\n\nfrom langflow.custom import Component\nfrom langflow.io import IntInput, MultilineInput, Output, SecretStrInput\nfrom langflow.schema import DataFrame\n\n\nclass GoogleSearchAPICore(Component):\n    display_name = \"Google Search API\"\n    description = \"Call Google Search API and return results as a DataFrame.\"\n    icon = \"Google\"\n\n    inputs = [\n        SecretStrInput(\n            name=\"google_api_key\",\n            display_name=\"Google API Key\",\n            required=True,\n        ),\n        SecretStrInput(\n            name=\"google_cse_id\",\n            display_name=\"Google CSE ID\",\n            required=True,\n        ),\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input\",\n            tool_mode=True,\n        ),\n        IntInput(\n            name=\"k\",\n            display_name=\"Number of results\",\n            value=4,\n            required=True,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Results\",\n            name=\"results\",\n            type_=DataFrame,\n            method=\"search_google\",\n        ),\n    ]\n\n    def search_google(self) -> DataFrame:\n        \"\"\"Search Google using the provided query.\"\"\"\n        if not self.google_api_key:\n            return DataFrame([{\"error\": \"Invalid Google API Key\"}])\n\n        if not self.google_cse_id:\n            return DataFrame([{\"error\": \"Invalid Google CSE ID\"}])\n\n        try:\n            wrapper = GoogleSearchAPIWrapper(\n                google_api_key=self.google_api_key, google_cse_id=self.google_cse_id, k=self.k\n            )\n            results = wrapper.results(query=self.input_value, num_results=self.k)\n            return DataFrame(results)\n        except (ValueError, KeyError) as e:\n            return DataFrame([{\"error\": f\"Invalid configuration: {e!s}\"}])\n        except ConnectionError as e:\n            return DataFrame([{\"error\": f\"Connection error: {e!s}\"}])\n        except RuntimeError as e:\n            return DataFrame([{\"error\": f\"Error occurred while searching: {e!s}\"}])\n\n    def build(self):\n        return self.search_google\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "google_api_key": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "google_api_key",
        "value": "",
        "display_name": "Google API Key",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "google_cse_id": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "google_cse_id",
        "value": "",
        "display_name": "Google CSE ID",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "input_value": {
        "tool_mode": true,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "input_value",
        "value": "",
        "display_name": "Input",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "k": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "k",
        "value": 4,
        "display_name": "Number of results",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      }
    },
    "description": "Call Google Search API and return results as a DataFrame.",
    "icon": "Google",
    "base_classes": [
      "DataFrame"
    ],
    "display_name": "Google Search API",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "results",
        "display_name": "Results",
        "method": "search_google",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "google_api_key",
      "google_cse_id",
      "input_value",
      "k"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "TavilyAISearch": {
    "template": {
      "_type": "Component",
      "api_key": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "api_key",
        "value": "",
        "display_name": "Tavily API Key",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "Your Tavily API Key.",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from enum import Enum\n\nimport httpx\nfrom langchain.tools import StructuredTool\nfrom langchain_core.tools import ToolException\nfrom loguru import logger\nfrom pydantic import BaseModel, Field\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import BoolInput, DropdownInput, IntInput, MessageTextInput, SecretStrInput\nfrom langflow.schema import Data\n\n\nclass TavilySearchDepth(Enum):\n    BASIC = \"basic\"\n    ADVANCED = \"advanced\"\n\n\nclass TavilySearchTopic(Enum):\n    GENERAL = \"general\"\n    NEWS = \"news\"\n\n\nclass TavilySearchSchema(BaseModel):\n    query: str = Field(..., description=\"The search query you want to execute with Tavily.\")\n    search_depth: TavilySearchDepth = Field(TavilySearchDepth.BASIC, description=\"The depth of the search.\")\n    topic: TavilySearchTopic = Field(TavilySearchTopic.GENERAL, description=\"The category of the search.\")\n    max_results: int = Field(5, description=\"The maximum number of search results to return.\")\n    include_images: bool = Field(default=False, description=\"Include a list of query-related images in the response.\")\n    include_answer: bool = Field(default=False, description=\"Include a short answer to original query.\")\n\n\nclass TavilySearchToolComponent(LCToolComponent):\n    display_name = \"Tavily AI Search [DEPRECATED]\"\n    description = \"\"\"**Tavily AI** is a search engine optimized for LLMs and RAG, \\\n        aimed at efficient, quick, and persistent search results. It can be used independently or as an agent tool.\n\nNote: Check 'Advanced' for all options.\n\"\"\"\n    icon = \"TavilyIcon\"\n    name = \"TavilyAISearch\"\n    documentation = \"https://docs.tavily.com/\"\n    legacy = True\n\n    inputs = [\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"Tavily API Key\",\n            required=True,\n            info=\"Your Tavily API Key.\",\n        ),\n        MessageTextInput(\n            name=\"query\",\n            display_name=\"Search Query\",\n            info=\"The search query you want to execute with Tavily.\",\n        ),\n        DropdownInput(\n            name=\"search_depth\",\n            display_name=\"Search Depth\",\n            info=\"The depth of the search.\",\n            options=list(TavilySearchDepth),\n            value=TavilySearchDepth.ADVANCED,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"topic\",\n            display_name=\"Search Topic\",\n            info=\"The category of the search.\",\n            options=list(TavilySearchTopic),\n            value=TavilySearchTopic.GENERAL,\n            advanced=True,\n        ),\n        IntInput(\n            name=\"max_results\",\n            display_name=\"Max Results\",\n            info=\"The maximum number of search results to return.\",\n            value=5,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"include_images\",\n            display_name=\"Include Images\",\n            info=\"Include a list of query-related images in the response.\",\n            value=True,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"include_answer\",\n            display_name=\"Include Answer\",\n            info=\"Include a short answer to original query.\",\n            value=True,\n            advanced=True,\n        ),\n    ]\n\n    def run_model(self) -> list[Data]:\n        # Convert string values to enum instances with validation\n        try:\n            search_depth_enum = (\n                self.search_depth\n                if isinstance(self.search_depth, TavilySearchDepth)\n                else TavilySearchDepth(str(self.search_depth).lower())\n            )\n        except ValueError as e:\n            error_message = f\"Invalid search depth value: {e!s}\"\n            self.status = error_message\n            return [Data(data={\"error\": error_message})]\n\n        try:\n            topic_enum = (\n                self.topic if isinstance(self.topic, TavilySearchTopic) else TavilySearchTopic(str(self.topic).lower())\n            )\n        except ValueError as e:\n            error_message = f\"Invalid topic value: {e!s}\"\n            self.status = error_message\n            return [Data(data={\"error\": error_message})]\n\n        return self._tavily_search(\n            self.query,\n            search_depth=search_depth_enum,\n            topic=topic_enum,\n            max_results=self.max_results,\n            include_images=self.include_images,\n            include_answer=self.include_answer,\n        )\n\n    def build_tool(self) -> Tool:\n        return StructuredTool.from_function(\n            name=\"tavily_search\",\n            description=\"Perform a web search using the Tavily API.\",\n            func=self._tavily_search,\n            args_schema=TavilySearchSchema,\n        )\n\n    def _tavily_search(\n        self,\n        query: str,\n        *,\n        search_depth: TavilySearchDepth = TavilySearchDepth.BASIC,\n        topic: TavilySearchTopic = TavilySearchTopic.GENERAL,\n        max_results: int = 5,\n        include_images: bool = False,\n        include_answer: bool = False,\n    ) -> list[Data]:\n        # Validate enum values\n        if not isinstance(search_depth, TavilySearchDepth):\n            msg = f\"Invalid search_depth value: {search_depth}\"\n            raise TypeError(msg)\n        if not isinstance(topic, TavilySearchTopic):\n            msg = f\"Invalid topic value: {topic}\"\n            raise TypeError(msg)\n\n        try:\n            url = \"https://api.tavily.com/search\"\n            headers = {\n                \"content-type\": \"application/json\",\n                \"accept\": \"application/json\",\n            }\n            payload = {\n                \"api_key\": self.api_key,\n                \"query\": query,\n                \"search_depth\": search_depth.value,\n                \"topic\": topic.value,\n                \"max_results\": max_results,\n                \"include_images\": include_images,\n                \"include_answer\": include_answer,\n            }\n\n            with httpx.Client() as client:\n                response = client.post(url, json=payload, headers=headers)\n\n            response.raise_for_status()\n            search_results = response.json()\n\n            data_results = [\n                Data(\n                    data={\n                        \"title\": result.get(\"title\"),\n                        \"url\": result.get(\"url\"),\n                        \"content\": result.get(\"content\"),\n                        \"score\": result.get(\"score\"),\n                    }\n                )\n                for result in search_results.get(\"results\", [])\n            ]\n\n            if include_answer and search_results.get(\"answer\"):\n                data_results.insert(0, Data(data={\"answer\": search_results[\"answer\"]}))\n\n            if include_images and search_results.get(\"images\"):\n                data_results.append(Data(data={\"images\": search_results[\"images\"]}))\n\n            self.status = data_results  # type: ignore[assignment]\n\n        except httpx.HTTPStatusError as e:\n            error_message = f\"HTTP error: {e.response.status_code} - {e.response.text}\"\n            logger.debug(error_message)\n            self.status = error_message\n            raise ToolException(error_message) from e\n        except Exception as e:\n            error_message = f\"Unexpected error: {e}\"\n            logger.opt(exception=True).debug(\"Error running Tavily Search\")\n            self.status = error_message\n            raise ToolException(error_message) from e\n        return data_results\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "include_answer": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "include_answer",
        "value": true,
        "display_name": "Include Answer",
        "advanced": true,
        "dynamic": false,
        "info": "Include a short answer to original query.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "include_images": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "include_images",
        "value": true,
        "display_name": "Include Images",
        "advanced": true,
        "dynamic": false,
        "info": "Include a list of query-related images in the response.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "max_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "max_results",
        "value": 5,
        "display_name": "Max Results",
        "advanced": true,
        "dynamic": false,
        "info": "The maximum number of search results to return.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "query": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "query",
        "value": "",
        "display_name": "Search Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The search query you want to execute with Tavily.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "search_depth": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "basic",
          "advanced"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_depth",
        "value": "advanced",
        "display_name": "Search Depth",
        "advanced": true,
        "dynamic": false,
        "info": "The depth of the search.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "topic": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "general",
          "news"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "topic",
        "value": "general",
        "display_name": "Search Topic",
        "advanced": true,
        "dynamic": false,
        "info": "The category of the search.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      }
    },
    "description": "**Tavily AI** is a search engine optimized for LLMs and RAG,         aimed at efficient, quick, and persistent search results. It can be used independently or as an agent tool.\n\nNote: Check 'Advanced' for all options.\n",
    "icon": "TavilyIcon",
    "base_classes": [
      "Data",
      "Tool"
    ],
    "display_name": "Tavily AI Search [DEPRECATED]",
    "documentation": "https://docs.tavily.com/",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "api_run_model",
        "display_name": "Data",
        "method": "run_model",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "api_key"
        ],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "Tool"
        ],
        "selected": "Tool",
        "name": "api_build_tool",
        "display_name": "Tool",
        "method": "build_tool",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "api_key"
        ],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "api_key",
      "query",
      "search_depth",
      "topic",
      "max_results",
      "include_images",
      "include_answer"
    ],
    "beta": false,
    "legacy": true,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "CalculatorTool": {
    "template": {
      "_type": "Component",
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "import ast\nimport operator\n\nfrom langchain.tools import StructuredTool\nfrom langchain_core.tools import ToolException\nfrom loguru import logger\nfrom pydantic import BaseModel, Field\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import MessageTextInput\nfrom langflow.schema import Data\n\n\nclass CalculatorToolComponent(LCToolComponent):\n    display_name = \"Calculator [DEPRECATED]\"\n    description = \"Perform basic arithmetic operations on a given expression.\"\n    icon = \"calculator\"\n    name = \"CalculatorTool\"\n    legacy = True\n\n    inputs = [\n        MessageTextInput(\n            name=\"expression\",\n            display_name=\"Expression\",\n            info=\"The arithmetic expression to evaluate (e.g., '4*4*(33/22)+12-20').\",\n        ),\n    ]\n\n    class CalculatorToolSchema(BaseModel):\n        expression: str = Field(..., description=\"The arithmetic expression to evaluate.\")\n\n    def run_model(self) -> list[Data]:\n        return self._evaluate_expression(self.expression)\n\n    def build_tool(self) -> Tool:\n        return StructuredTool.from_function(\n            name=\"calculator\",\n            description=\"Evaluate basic arithmetic expressions. Input should be a string containing the expression.\",\n            func=self._eval_expr_with_error,\n            args_schema=self.CalculatorToolSchema,\n        )\n\n    def _eval_expr(self, node):\n        if isinstance(node, ast.Num):\n            return node.n\n        if isinstance(node, ast.BinOp):\n            left_val = self._eval_expr(node.left)\n            right_val = self._eval_expr(node.right)\n            return self.operators[type(node.op)](left_val, right_val)\n        if isinstance(node, ast.UnaryOp):\n            operand_val = self._eval_expr(node.operand)\n            return self.operators[type(node.op)](operand_val)\n        if isinstance(node, ast.Call):\n            msg = (\n                \"Function calls like sqrt(), sin(), cos() etc. are not supported. \"\n                \"Only basic arithmetic operations (+, -, *, /, **) are allowed.\"\n            )\n            raise TypeError(msg)\n        msg = f\"Unsupported operation or expression type: {type(node).__name__}\"\n        raise TypeError(msg)\n\n    def _eval_expr_with_error(self, expression: str) -> list[Data]:\n        try:\n            return self._evaluate_expression(expression)\n        except Exception as e:\n            raise ToolException(str(e)) from e\n\n    def _evaluate_expression(self, expression: str) -> list[Data]:\n        try:\n            # Parse the expression and evaluate it\n            tree = ast.parse(expression, mode=\"eval\")\n            result = self._eval_expr(tree.body)\n\n            # Format the result to a reasonable number of decimal places\n            formatted_result = f\"{result:.6f}\".rstrip(\"0\").rstrip(\".\")\n\n            self.status = formatted_result\n            return [Data(data={\"result\": formatted_result})]\n\n        except (SyntaxError, TypeError, KeyError) as e:\n            error_message = f\"Invalid expression: {e}\"\n            self.status = error_message\n            return [Data(data={\"error\": error_message, \"input\": expression})]\n        except ZeroDivisionError:\n            error_message = \"Error: Division by zero\"\n            self.status = error_message\n            return [Data(data={\"error\": error_message, \"input\": expression})]\n        except Exception as e:  # noqa: BLE001\n            logger.opt(exception=True).debug(\"Error evaluating expression\")\n            error_message = f\"Error: {e}\"\n            self.status = error_message\n            return [Data(data={\"error\": error_message, \"input\": expression})]\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.operators = {\n            ast.Add: operator.add,\n            ast.Sub: operator.sub,\n            ast.Mult: operator.mul,\n            ast.Div: operator.truediv,\n            ast.Pow: operator.pow,\n        }\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "expression": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "expression",
        "value": "",
        "display_name": "Expression",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The arithmetic expression to evaluate (e.g., '4*4*(33/22)+12-20').",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      }
    },
    "description": "Perform basic arithmetic operations on a given expression.",
    "icon": "calculator",
    "base_classes": [
      "Data",
      "Tool"
    ],
    "display_name": "Calculator [DEPRECATED]",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "api_run_model",
        "display_name": "Data",
        "method": "run_model",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "Tool"
        ],
        "selected": "Tool",
        "name": "api_build_tool",
        "display_name": "Tool",
        "method": "build_tool",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "expression"
    ],
    "beta": false,
    "legacy": true,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "PythonREPLComponent": {
    "template": {
      "_type": "Component",
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "import importlib\n\nfrom langchain_experimental.utilities import PythonREPL\n\nfrom langflow.custom import Component\nfrom langflow.io import CodeInput, Output, StrInput\nfrom langflow.schema import Data\n\n\nclass PythonREPLComponent(Component):\n    display_name = \"Python REPL\"\n    description = (\n        \"A Python code executor that lets you run Python code with specific imported modules. \"\n        \"Remember to always use print() to see your results. Example: print(df.head())\"\n    )\n    icon = \"Python\"\n\n    inputs = [\n        StrInput(\n            name=\"global_imports\",\n            display_name=\"Global Imports\",\n            info=\"A comma-separated list of modules to import globally, e.g. 'math,numpy,pandas'.\",\n            value=\"math,pandas\",\n            required=True,\n        ),\n        CodeInput(\n            name=\"python_code\",\n            display_name=\"Python Code\",\n            info=\"The Python code to execute. Only modules specified in Global Imports can be used.\",\n            value=\"print('Hello, World!')\",\n            tool_mode=True,\n            required=True,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Results\",\n            name=\"results\",\n            type_=Data,\n            method=\"run_python_repl\",\n        ),\n    ]\n\n    def get_globals(self, global_imports: str | list[str]) -> dict:\n        \"\"\"Create a globals dictionary with only the specified allowed imports.\"\"\"\n        global_dict = {}\n\n        try:\n            if isinstance(global_imports, str):\n                modules = [module.strip() for module in global_imports.split(\",\")]\n            elif isinstance(global_imports, list):\n                modules = global_imports\n            else:\n                msg = \"global_imports must be either a string or a list\"\n                raise TypeError(msg)\n\n            for module in modules:\n                try:\n                    imported_module = importlib.import_module(module)\n                    global_dict[imported_module.__name__] = imported_module\n                except ImportError as e:\n                    msg = f\"Could not import module {module}: {e!s}\"\n                    raise ImportError(msg) from e\n\n        except Exception as e:\n            self.log(f\"Error in global imports: {e!s}\")\n            raise\n        else:\n            self.log(f\"Successfully imported modules: {list(global_dict.keys())}\")\n            return global_dict\n\n    def run_python_repl(self) -> Data:\n        try:\n            globals_ = self.get_globals(self.global_imports)\n            python_repl = PythonREPL(_globals=globals_)\n            result = python_repl.run(self.python_code)\n            result = result.strip() if result else \"\"\n\n            self.log(\"Code execution completed successfully\")\n            return Data(data={\"result\": result})\n\n        except ImportError as e:\n            error_message = f\"Import Error: {e!s}\"\n            self.log(error_message)\n            return Data(data={\"error\": error_message})\n\n        except SyntaxError as e:\n            error_message = f\"Syntax Error: {e!s}\"\n            self.log(error_message)\n            return Data(data={\"error\": error_message})\n\n        except (NameError, TypeError, ValueError) as e:\n            error_message = f\"Error during execution: {e!s}\"\n            self.log(error_message)\n            return Data(data={\"error\": error_message})\n\n    def build(self):\n        return self.run_python_repl\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "global_imports": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "global_imports",
        "value": "math,pandas",
        "display_name": "Global Imports",
        "advanced": false,
        "dynamic": false,
        "info": "A comma-separated list of modules to import globally, e.g. 'math,numpy,pandas'.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "python_code": {
        "tool_mode": true,
        "trace_as_input": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "python_code",
        "value": "print('Hello, World!')",
        "display_name": "Python Code",
        "advanced": false,
        "dynamic": false,
        "info": "The Python code to execute. Only modules specified in Global Imports can be used.",
        "title_case": false,
        "type": "code",
        "_input_type": "CodeInput"
      }
    },
    "description": "A Python code executor that lets you run Python code with specific imported modules. Remember to always use print() to see your results. Example: print(df.head())",
    "icon": "Python",
    "base_classes": [
      "Data"
    ],
    "display_name": "Python REPL",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "results",
        "display_name": "Results",
        "method": "run_python_repl",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "global_imports",
      "python_code"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "GoogleSerperAPICore": {
    "template": {
      "_type": "Component",
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain_community.utilities.google_serper import GoogleSerperAPIWrapper\n\nfrom langflow.custom import Component\nfrom langflow.io import IntInput, MultilineInput, Output, SecretStrInput\nfrom langflow.schema import DataFrame\nfrom langflow.schema.message import Message\n\n\nclass GoogleSerperAPICore(Component):\n    display_name = \"Google Serper API\"\n    description = \"Call the Serper.dev Google Search API.\"\n    icon = \"Serper\"\n\n    inputs = [\n        SecretStrInput(\n            name=\"serper_api_key\",\n            display_name=\"Serper API Key\",\n            required=True,\n        ),\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input\",\n            tool_mode=True,\n        ),\n        IntInput(\n            name=\"k\",\n            display_name=\"Number of results\",\n            value=4,\n            required=True,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Results\",\n            name=\"results\",\n            type_=DataFrame,\n            method=\"search_serper\",\n        ),\n    ]\n\n    def search_serper(self) -> DataFrame:\n        try:\n            wrapper = self._build_wrapper()\n            results = wrapper.results(query=self.input_value)\n            list_results = results.get(\"organic\", [])\n\n            # Convert results to DataFrame using list comprehension\n            df_data = [\n                {\n                    \"title\": result.get(\"title\", \"\"),\n                    \"link\": result.get(\"link\", \"\"),\n                    \"snippet\": result.get(\"snippet\", \"\"),\n                }\n                for result in list_results\n            ]\n\n            return DataFrame(df_data)\n        except (ValueError, KeyError, ConnectionError) as e:\n            error_message = f\"Error occurred while searching: {e!s}\"\n            self.status = error_message\n            # Return DataFrame with error as a list of dictionaries\n            return DataFrame([{\"error\": error_message}])\n\n    def text_search_serper(self) -> Message:\n        search_results = self.search_serper()\n        text_result = search_results.to_string(index=False) if not search_results.empty else \"No results found.\"\n        return Message(text=text_result)\n\n    def _build_wrapper(self):\n        return GoogleSerperAPIWrapper(serper_api_key=self.serper_api_key, k=self.k)\n\n    def build(self):\n        return self.search_serper\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "input_value": {
        "tool_mode": true,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "input_value",
        "value": "",
        "display_name": "Input",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "k": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "k",
        "value": 4,
        "display_name": "Number of results",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "serper_api_key": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "serper_api_key",
        "value": "",
        "display_name": "Serper API Key",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      }
    },
    "description": "Call the Serper.dev Google Search API.",
    "icon": "Serper",
    "base_classes": [
      "DataFrame"
    ],
    "display_name": "Google Serper API",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "results",
        "display_name": "Results",
        "method": "search_serper",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "serper_api_key",
      "input_value",
      "k"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "WikidataAPI": {
    "template": {
      "_type": "Component",
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from typing import Any\n\nimport httpx\nfrom langchain_core.tools import StructuredTool, ToolException\nfrom pydantic import BaseModel, Field\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import MultilineInput\nfrom langflow.schema import Data\n\n\nclass WikidataSearchSchema(BaseModel):\n    query: str = Field(..., description=\"The search query for Wikidata\")\n\n\nclass WikidataAPIWrapper(BaseModel):\n    \"\"\"Wrapper around Wikidata API.\"\"\"\n\n    wikidata_api_url: str = \"https://www.wikidata.org/w/api.php\"\n\n    def results(self, query: str) -> list[dict[str, Any]]:\n        # Define request parameters for Wikidata API\n        params = {\n            \"action\": \"wbsearchentities\",\n            \"format\": \"json\",\n            \"search\": query,\n            \"language\": \"en\",\n        }\n\n        # Send request to Wikidata API\n        response = httpx.get(self.wikidata_api_url, params=params)\n        response.raise_for_status()\n        response_json = response.json()\n\n        # Extract and return search results\n        return response_json.get(\"search\", [])\n\n    def run(self, query: str) -> list[dict[str, Any]]:\n        try:\n            results = self.results(query)\n            if results:\n                return results\n\n            error_message = \"No search results found for the given query.\"\n\n            raise ToolException(error_message)\n\n        except Exception as e:\n            error_message = f\"Error in Wikidata Search API: {e!s}\"\n\n            raise ToolException(error_message) from e\n\n\nclass WikidataAPIComponent(LCToolComponent):\n    display_name = \"Wikidata API [Deprecated]\"\n    description = \"Performs a search using the Wikidata API.\"\n    name = \"WikidataAPI\"\n    icon = \"Wikipedia\"\n    legacy = True\n\n    inputs = [\n        MultilineInput(\n            name=\"query\",\n            display_name=\"Query\",\n            info=\"The text query for similarity search on Wikidata.\",\n            required=True,\n        ),\n    ]\n\n    def build_tool(self) -> Tool:\n        wrapper = WikidataAPIWrapper()\n\n        # Define the tool using StructuredTool and wrapper's run method\n        tool = StructuredTool.from_function(\n            name=\"wikidata_search_api\",\n            description=\"Perform similarity search on Wikidata API\",\n            func=wrapper.run,\n            args_schema=WikidataSearchSchema,\n        )\n\n        self.status = \"Wikidata Search API Tool for Langchain\"\n\n        return tool\n\n    def run_model(self) -> list[Data]:\n        tool = self.build_tool()\n\n        results = tool.run({\"query\": self.query})\n\n        # Transform the API response into Data objects\n        data = [\n            Data(\n                text=result[\"label\"],\n                metadata=result,\n            )\n            for result in results\n        ]\n\n        self.status = data  # type: ignore[assignment]\n\n        return data\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "query": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "query",
        "value": "",
        "display_name": "Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The text query for similarity search on Wikidata.",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      }
    },
    "description": "Performs a search using the Wikidata API.",
    "icon": "Wikipedia",
    "base_classes": [
      "Data",
      "Tool"
    ],
    "display_name": "Wikidata API [Deprecated]",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "api_run_model",
        "display_name": "Data",
        "method": "run_model",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "query"
        ],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "Tool"
        ],
        "selected": "Tool",
        "name": "api_build_tool",
        "display_name": "Tool",
        "method": "build_tool",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "query"
        ],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "query"
    ],
    "beta": false,
    "legacy": true,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "SearchComponent": {
    "template": {
      "_type": "Component",
      "api_key": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "api_key",
        "value": "",
        "display_name": "SearchAPI API Key",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from typing import Any\n\nfrom langchain_community.utilities.searchapi import SearchApiAPIWrapper\n\nfrom langflow.custom import Component\nfrom langflow.inputs import DictInput, DropdownInput, IntInput, MultilineInput, SecretStrInput\nfrom langflow.io import Output\nfrom langflow.schema import Data, DataFrame\nfrom langflow.schema.message import Message\n\n\nclass SearchComponent(Component):\n    display_name: str = \"Search API\"\n    description: str = \"Call the searchapi.io API with result limiting\"\n    documentation: str = \"https://www.searchapi.io/docs/google\"\n    icon = \"SearchAPI\"\n\n    inputs = [\n        DropdownInput(name=\"engine\", display_name=\"Engine\", value=\"google\", options=[\"google\", \"bing\", \"duckduckgo\"]),\n        SecretStrInput(name=\"api_key\", display_name=\"SearchAPI API Key\", required=True),\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input\",\n            tool_mode=True,\n        ),\n        DictInput(name=\"search_params\", display_name=\"Search parameters\", advanced=True, is_list=True),\n        IntInput(name=\"max_results\", display_name=\"Max Results\", value=5, advanced=True),\n        IntInput(name=\"max_snippet_length\", display_name=\"Max Snippet Length\", value=100, advanced=True),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"fetch_content\"),\n        Output(display_name=\"Text\", name=\"text\", method=\"fetch_content_text\"),\n        Output(display_name=\"DataFrame\", name=\"dataframe\", method=\"as_dataframe\"),\n    ]\n\n    def _build_wrapper(self):\n        return SearchApiAPIWrapper(engine=self.engine, searchapi_api_key=self.api_key)\n\n    def run_model(self) -> list[Data]:\n        return self.fetch_content()\n\n    def fetch_content(self) -> list[Data]:\n        wrapper = self._build_wrapper()\n\n        def search_func(\n            query: str, params: dict[str, Any] | None = None, max_results: int = 5, max_snippet_length: int = 100\n        ) -> list[Data]:\n            params = params or {}\n            full_results = wrapper.results(query=query, **params)\n            organic_results = full_results.get(\"organic_results\", [])[:max_results]\n\n            return [\n                Data(\n                    text=result.get(\"snippet\", \"\"),\n                    data={\n                        \"title\": result.get(\"title\", \"\")[:max_snippet_length],\n                        \"link\": result.get(\"link\", \"\"),\n                        \"snippet\": result.get(\"snippet\", \"\")[:max_snippet_length],\n                    },\n                )\n                for result in organic_results\n            ]\n\n        results = search_func(\n            self.input_value,\n            self.search_params or {},\n            self.max_results,\n            self.max_snippet_length,\n        )\n        self.status = results\n        return results\n\n    def fetch_content_text(self) -> Message:\n        data = self.fetch_content()\n        result_string = \"\"\n        for item in data:\n            result_string += item.text + \"\\n\"\n        self.status = result_string\n        return Message(text=result_string)\n\n    def as_dataframe(self) -> DataFrame:\n        \"\"\"Convert the search results to a DataFrame.\n\n        Returns:\n            DataFrame: A DataFrame containing the search results.\n        \"\"\"\n        data = self.fetch_content()\n        return DataFrame(data)\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "engine": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "google",
          "bing",
          "duckduckgo"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "engine",
        "value": "google",
        "display_name": "Engine",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "input_value": {
        "tool_mode": true,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "input_value",
        "value": "",
        "display_name": "Input",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "max_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "max_results",
        "value": 5,
        "display_name": "Max Results",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "max_snippet_length": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "max_snippet_length",
        "value": 100,
        "display_name": "Max Snippet Length",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "search_params": {
        "tool_mode": false,
        "trace_as_input": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_params",
        "value": {},
        "display_name": "Search parameters",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "dict",
        "_input_type": "DictInput"
      }
    },
    "description": "Call the searchapi.io API with result limiting",
    "icon": "SearchAPI",
    "base_classes": [
      "Data",
      "DataFrame",
      "Message"
    ],
    "display_name": "Search API",
    "documentation": "https://www.searchapi.io/docs/google",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "data",
        "display_name": "Data",
        "method": "fetch_content",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "Message"
        ],
        "selected": "Message",
        "name": "text",
        "display_name": "Text",
        "method": "fetch_content_text",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "engine",
      "api_key",
      "input_value",
      "search_params",
      "max_results",
      "max_snippet_length"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "PythonREPLTool": {
    "template": {
      "_type": "Component",
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "import importlib\n\nfrom langchain.tools import StructuredTool\nfrom langchain_core.tools import ToolException\nfrom langchain_experimental.utilities import PythonREPL\nfrom loguru import logger\nfrom pydantic import BaseModel, Field\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import StrInput\nfrom langflow.schema import Data\n\n\nclass PythonREPLToolComponent(LCToolComponent):\n    display_name = \"Python REPL [DEPRECATED]\"\n    description = \"A tool for running Python code in a REPL environment.\"\n    name = \"PythonREPLTool\"\n    icon = \"Python\"\n    legacy = True\n\n    inputs = [\n        StrInput(\n            name=\"name\",\n            display_name=\"Tool Name\",\n            info=\"The name of the tool.\",\n            value=\"python_repl\",\n        ),\n        StrInput(\n            name=\"description\",\n            display_name=\"Tool Description\",\n            info=\"A description of the tool.\",\n            value=\"A Python shell. Use this to execute python commands. \"\n            \"Input should be a valid python command. \"\n            \"If you want to see the output of a value, you should print it out with `print(...)`.\",\n        ),\n        StrInput(\n            name=\"global_imports\",\n            display_name=\"Global Imports\",\n            info=\"A comma-separated list of modules to import globally, e.g. 'math,numpy'.\",\n            value=\"math\",\n        ),\n        StrInput(\n            name=\"code\",\n            display_name=\"Python Code\",\n            info=\"The Python code to execute.\",\n            value=\"print('Hello, World!')\",\n        ),\n    ]\n\n    class PythonREPLSchema(BaseModel):\n        code: str = Field(..., description=\"The Python code to execute.\")\n\n    def get_globals(self, global_imports: str | list[str]) -> dict:\n        global_dict = {}\n        if isinstance(global_imports, str):\n            modules = [module.strip() for module in global_imports.split(\",\")]\n        elif isinstance(global_imports, list):\n            modules = global_imports\n        else:\n            msg = \"global_imports must be either a string or a list\"\n            raise TypeError(msg)\n\n        for module in modules:\n            try:\n                imported_module = importlib.import_module(module)\n                global_dict[imported_module.__name__] = imported_module\n            except ImportError as e:\n                msg = f\"Could not import module {module}\"\n                raise ImportError(msg) from e\n        return global_dict\n\n    def build_tool(self) -> Tool:\n        globals_ = self.get_globals(self.global_imports)\n        python_repl = PythonREPL(_globals=globals_)\n\n        def run_python_code(code: str) -> str:\n            try:\n                return python_repl.run(code)\n            except Exception as e:\n                logger.opt(exception=True).debug(\"Error running Python code\")\n                raise ToolException(str(e)) from e\n\n        tool = StructuredTool.from_function(\n            name=self.name,\n            description=self.description,\n            func=run_python_code,\n            args_schema=self.PythonREPLSchema,\n        )\n\n        self.status = f\"Python REPL Tool created with global imports: {self.global_imports}\"\n        return tool\n\n    def run_model(self) -> list[Data]:\n        tool = self.build_tool()\n        result = tool.run(self.code)\n        return [Data(data={\"result\": result})]\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "description": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "description",
        "value": "A Python shell. Use this to execute python commands. Input should be a valid python command. If you want to see the output of a value, you should print it out with `print(...)`.",
        "display_name": "Tool Description",
        "advanced": false,
        "dynamic": false,
        "info": "A description of the tool.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "global_imports": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "global_imports",
        "value": "math",
        "display_name": "Global Imports",
        "advanced": false,
        "dynamic": false,
        "info": "A comma-separated list of modules to import globally, e.g. 'math,numpy'.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      },
      "name": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "name",
        "value": "python_repl",
        "display_name": "Tool Name",
        "advanced": false,
        "dynamic": false,
        "info": "The name of the tool.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      }
    },
    "description": "A tool for running Python code in a REPL environment.",
    "icon": "Python",
    "base_classes": [
      "Data",
      "Tool"
    ],
    "display_name": "Python REPL [DEPRECATED]",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "api_run_model",
        "display_name": "Data",
        "method": "run_model",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "Tool"
        ],
        "selected": "Tool",
        "name": "api_build_tool",
        "display_name": "Tool",
        "method": "build_tool",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "name",
      "description",
      "global_imports",
      "code"
    ],
    "beta": false,
    "legacy": true,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "WikidataComponent": {
    "template": {
      "_type": "Component",
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "import httpx\nfrom httpx import HTTPError\nfrom langchain_core.tools import ToolException\n\nfrom langflow.custom import Component\nfrom langflow.helpers.data import data_to_text\nfrom langflow.io import MultilineInput, Output\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\n\n\nclass WikidataComponent(Component):\n    display_name = \"Wikidata\"\n    description = \"Performs a search using the Wikidata API.\"\n    icon = \"Wikipedia\"\n\n    inputs = [\n        MultilineInput(\n            name=\"query\",\n            display_name=\"Query\",\n            info=\"The text query for similarity search on Wikidata.\",\n            required=True,\n            tool_mode=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"fetch_content\"),\n        Output(display_name=\"Message\", name=\"text\", method=\"fetch_content_text\"),\n    ]\n\n    def fetch_content(self) -> list[Data]:\n        try:\n            # Define request parameters for Wikidata API\n            params = {\n                \"action\": \"wbsearchentities\",\n                \"format\": \"json\",\n                \"search\": self.query,\n                \"language\": \"en\",\n            }\n\n            # Send request to Wikidata API\n            wikidata_api_url = \"https://www.wikidata.org/w/api.php\"\n            response = httpx.get(wikidata_api_url, params=params)\n            response.raise_for_status()\n            response_json = response.json()\n\n            # Extract search results\n            results = response_json.get(\"search\", [])\n\n            if not results:\n                return [Data(data={\"error\": \"No search results found for the given query.\"})]\n\n            # Transform the API response into Data objects\n            data = [\n                Data(\n                    text=f\"{result['label']}: {result.get('description', '')}\",\n                    data={\n                        \"label\": result[\"label\"],\n                        \"id\": result.get(\"id\"),\n                        \"url\": result.get(\"url\"),\n                        \"description\": result.get(\"description\", \"\"),\n                        \"concepturi\": result.get(\"concepturi\"),\n                    },\n                )\n                for result in results\n            ]\n\n            self.status = data\n        except HTTPError as e:\n            error_message = f\"HTTP Error in Wikidata Search API: {e!s}\"\n            raise ToolException(error_message) from None\n        except KeyError as e:\n            error_message = f\"Data parsing error in Wikidata API response: {e!s}\"\n            raise ToolException(error_message) from None\n        except ValueError as e:\n            error_message = f\"Value error in Wikidata API: {e!s}\"\n            raise ToolException(error_message) from None\n        else:\n            return data\n\n    def fetch_content_text(self) -> Message:\n        data = self.fetch_content()\n        result_string = data_to_text(\"{text}\", data)\n        self.status = result_string\n        return Message(text=result_string)\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "query": {
        "tool_mode": true,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "query",
        "value": "",
        "display_name": "Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The text query for similarity search on Wikidata.",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      }
    },
    "description": "Performs a search using the Wikidata API.",
    "icon": "Wikipedia",
    "base_classes": [
      "Data",
      "Message"
    ],
    "display_name": "Wikidata",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "data",
        "display_name": "Data",
        "method": "fetch_content",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "Message"
        ],
        "selected": "Message",
        "name": "text",
        "display_name": "Message",
        "method": "fetch_content_text",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "query"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "YahooFinanceTool": {
    "template": {
      "_type": "Component",
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "import ast\nimport pprint\nfrom enum import Enum\n\nimport yfinance as yf\nfrom langchain.tools import StructuredTool\nfrom langchain_core.tools import ToolException\nfrom loguru import logger\nfrom pydantic import BaseModel, Field\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import DropdownInput, IntInput, MessageTextInput\nfrom langflow.schema import Data\n\n\nclass YahooFinanceMethod(Enum):\n    GET_INFO = \"get_info\"\n    GET_NEWS = \"get_news\"\n    GET_ACTIONS = \"get_actions\"\n    GET_ANALYSIS = \"get_analysis\"\n    GET_BALANCE_SHEET = \"get_balance_sheet\"\n    GET_CALENDAR = \"get_calendar\"\n    GET_CASHFLOW = \"get_cashflow\"\n    GET_INSTITUTIONAL_HOLDERS = \"get_institutional_holders\"\n    GET_RECOMMENDATIONS = \"get_recommendations\"\n    GET_SUSTAINABILITY = \"get_sustainability\"\n    GET_MAJOR_HOLDERS = \"get_major_holders\"\n    GET_MUTUALFUND_HOLDERS = \"get_mutualfund_holders\"\n    GET_INSIDER_PURCHASES = \"get_insider_purchases\"\n    GET_INSIDER_TRANSACTIONS = \"get_insider_transactions\"\n    GET_INSIDER_ROSTER_HOLDERS = \"get_insider_roster_holders\"\n    GET_DIVIDENDS = \"get_dividends\"\n    GET_CAPITAL_GAINS = \"get_capital_gains\"\n    GET_SPLITS = \"get_splits\"\n    GET_SHARES = \"get_shares\"\n    GET_FAST_INFO = \"get_fast_info\"\n    GET_SEC_FILINGS = \"get_sec_filings\"\n    GET_RECOMMENDATIONS_SUMMARY = \"get_recommendations_summary\"\n    GET_UPGRADES_DOWNGRADES = \"get_upgrades_downgrades\"\n    GET_EARNINGS = \"get_earnings\"\n    GET_INCOME_STMT = \"get_income_stmt\"\n\n\nclass YahooFinanceSchema(BaseModel):\n    symbol: str = Field(..., description=\"The stock symbol to retrieve data for.\")\n    method: YahooFinanceMethod = Field(YahooFinanceMethod.GET_INFO, description=\"The type of data to retrieve.\")\n    num_news: int | None = Field(5, description=\"The number of news articles to retrieve.\")\n\n\nclass YfinanceToolComponent(LCToolComponent):\n    display_name = \"Yahoo Finance [DEPRECATED]\"\n    description = \"\"\"Uses [yfinance](https://pypi.org/project/yfinance/) (unofficial package) \\\nto access financial data and market information from Yahoo Finance.\"\"\"\n    icon = \"trending-up\"\n    name = \"YahooFinanceTool\"\n    legacy = True\n\n    inputs = [\n        MessageTextInput(\n            name=\"symbol\",\n            display_name=\"Stock Symbol\",\n            info=\"The stock symbol to retrieve data for (e.g., AAPL, GOOG).\",\n        ),\n        DropdownInput(\n            name=\"method\",\n            display_name=\"Data Method\",\n            info=\"The type of data to retrieve.\",\n            options=list(YahooFinanceMethod),\n            value=\"get_news\",\n        ),\n        IntInput(\n            name=\"num_news\",\n            display_name=\"Number of News\",\n            info=\"The number of news articles to retrieve (only applicable for get_news).\",\n            value=5,\n        ),\n    ]\n\n    def run_model(self) -> list[Data]:\n        return self._yahoo_finance_tool(\n            self.symbol,\n            self.method,\n            self.num_news,\n        )\n\n    def build_tool(self) -> Tool:\n        return StructuredTool.from_function(\n            name=\"yahoo_finance\",\n            description=\"Access financial data and market information from Yahoo Finance.\",\n            func=self._yahoo_finance_tool,\n            args_schema=YahooFinanceSchema,\n        )\n\n    def _yahoo_finance_tool(\n        self,\n        symbol: str,\n        method: YahooFinanceMethod,\n        num_news: int | None = 5,\n    ) -> list[Data]:\n        ticker = yf.Ticker(symbol)\n\n        try:\n            if method == YahooFinanceMethod.GET_INFO:\n                result = ticker.info\n            elif method == YahooFinanceMethod.GET_NEWS:\n                result = ticker.news[:num_news]\n            else:\n                result = getattr(ticker, method.value)()\n\n            result = pprint.pformat(result)\n\n            if method == YahooFinanceMethod.GET_NEWS:\n                data_list = [Data(data=article) for article in ast.literal_eval(result)]\n            else:\n                data_list = [Data(data={\"result\": result})]\n\n        except Exception as e:\n            error_message = f\"Error retrieving data: {e}\"\n            logger.debug(error_message)\n            self.status = error_message\n            raise ToolException(error_message) from e\n\n        return data_list\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "method": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "get_info",
          "get_news",
          "get_actions",
          "get_analysis",
          "get_balance_sheet",
          "get_calendar",
          "get_cashflow",
          "get_institutional_holders",
          "get_recommendations",
          "get_sustainability",
          "get_major_holders",
          "get_mutualfund_holders",
          "get_insider_purchases",
          "get_insider_transactions",
          "get_insider_roster_holders",
          "get_dividends",
          "get_capital_gains",
          "get_splits",
          "get_shares",
          "get_fast_info",
          "get_sec_filings",
          "get_recommendations_summary",
          "get_upgrades_downgrades",
          "get_earnings",
          "get_income_stmt"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "method",
        "value": "get_news",
        "display_name": "Data Method",
        "advanced": false,
        "dynamic": false,
        "info": "The type of data to retrieve.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "num_news": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "num_news",
        "value": 5,
        "display_name": "Number of News",
        "advanced": false,
        "dynamic": false,
        "info": "The number of news articles to retrieve (only applicable for get_news).",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "symbol": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "symbol",
        "value": "",
        "display_name": "Stock Symbol",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The stock symbol to retrieve data for (e.g., AAPL, GOOG).",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      }
    },
    "description": "Uses [yfinance](https://pypi.org/project/yfinance/) (unofficial package) to access financial data and market information from Yahoo Finance.",
    "icon": "trending-up",
    "base_classes": [
      "Data",
      "Tool"
    ],
    "display_name": "Yahoo Finance [DEPRECATED]",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "api_run_model",
        "display_name": "Data",
        "method": "run_model",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "Tool"
        ],
        "selected": "Tool",
        "name": "api_build_tool",
        "display_name": "Tool",
        "method": "build_tool",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "symbol",
      "method",
      "num_news"
    ],
    "beta": false,
    "legacy": true,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "SearchAPI": {
    "template": {
      "_type": "Component",
      "api_key": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "api_key",
        "value": "",
        "display_name": "SearchAPI API Key",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from typing import Any\n\nfrom langchain.tools import StructuredTool\nfrom langchain_community.utilities.searchapi import SearchApiAPIWrapper\nfrom pydantic import BaseModel, Field\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import DictInput, IntInput, MessageTextInput, MultilineInput, SecretStrInput\nfrom langflow.schema import Data\n\n\nclass SearchAPIComponent(LCToolComponent):\n    display_name: str = \"Search API [DEPRECATED]\"\n    description: str = \"Call the searchapi.io API with result limiting\"\n    name = \"SearchAPI\"\n    documentation: str = \"https://www.searchapi.io/docs/google\"\n    icon = \"SearchAPI\"\n    legacy = True\n\n    inputs = [\n        MessageTextInput(name=\"engine\", display_name=\"Engine\", value=\"google\"),\n        SecretStrInput(name=\"api_key\", display_name=\"SearchAPI API Key\", required=True),\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input\",\n        ),\n        DictInput(name=\"search_params\", display_name=\"Search parameters\", advanced=True, is_list=True),\n        IntInput(name=\"max_results\", display_name=\"Max Results\", value=5, advanced=True),\n        IntInput(name=\"max_snippet_length\", display_name=\"Max Snippet Length\", value=100, advanced=True),\n    ]\n\n    class SearchAPISchema(BaseModel):\n        query: str = Field(..., description=\"The search query\")\n        params: dict[str, Any] = Field(default_factory=dict, description=\"Additional search parameters\")\n        max_results: int = Field(5, description=\"Maximum number of results to return\")\n        max_snippet_length: int = Field(100, description=\"Maximum length of each result snippet\")\n\n    def _build_wrapper(self):\n        return SearchApiAPIWrapper(engine=self.engine, searchapi_api_key=self.api_key)\n\n    def build_tool(self) -> Tool:\n        wrapper = self._build_wrapper()\n\n        def search_func(\n            query: str, params: dict[str, Any] | None = None, max_results: int = 5, max_snippet_length: int = 100\n        ) -> list[dict[str, Any]]:\n            params = params or {}\n            full_results = wrapper.results(query=query, **params)\n            organic_results = full_results.get(\"organic_results\", [])[:max_results]\n\n            limited_results = []\n            for result in organic_results:\n                limited_result = {\n                    \"title\": result.get(\"title\", \"\")[:max_snippet_length],\n                    \"link\": result.get(\"link\", \"\"),\n                    \"snippet\": result.get(\"snippet\", \"\")[:max_snippet_length],\n                }\n                limited_results.append(limited_result)\n\n            return limited_results\n\n        tool = StructuredTool.from_function(\n            name=\"search_api\",\n            description=\"Search for recent results using searchapi.io with result limiting\",\n            func=search_func,\n            args_schema=self.SearchAPISchema,\n        )\n\n        self.status = f\"Search API Tool created with engine: {self.engine}\"\n        return tool\n\n    def run_model(self) -> list[Data]:\n        tool = self.build_tool()\n        results = tool.run(\n            {\n                \"query\": self.input_value,\n                \"params\": self.search_params or {},\n                \"max_results\": self.max_results,\n                \"max_snippet_length\": self.max_snippet_length,\n            }\n        )\n\n        data_list = [Data(data=result, text=result.get(\"snippet\", \"\")) for result in results]\n\n        self.status = data_list\n        return data_list\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "engine": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "engine",
        "value": "google",
        "display_name": "Engine",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "input_value": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "input_value",
        "value": "",
        "display_name": "Input",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "max_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "max_results",
        "value": 5,
        "display_name": "Max Results",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "max_snippet_length": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "max_snippet_length",
        "value": 100,
        "display_name": "Max Snippet Length",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "search_params": {
        "tool_mode": false,
        "trace_as_input": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_params",
        "value": {},
        "display_name": "Search parameters",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "dict",
        "_input_type": "DictInput"
      }
    },
    "description": "Call the searchapi.io API with result limiting",
    "icon": "SearchAPI",
    "base_classes": [
      "Data",
      "Tool"
    ],
    "display_name": "Search API [DEPRECATED]",
    "documentation": "https://www.searchapi.io/docs/google",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "api_run_model",
        "display_name": "Data",
        "method": "run_model",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "api_key"
        ],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "Tool"
        ],
        "selected": "Tool",
        "name": "api_build_tool",
        "display_name": "Tool",
        "method": "build_tool",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "api_key"
        ],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "engine",
      "api_key",
      "input_value",
      "search_params",
      "max_results",
      "max_snippet_length"
    ],
    "beta": false,
    "legacy": true,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "WikipediaComponent": {
    "template": {
      "_type": "Component",
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain_community.utilities.wikipedia import WikipediaAPIWrapper\n\nfrom langflow.custom import Component\nfrom langflow.inputs import BoolInput, IntInput, MessageTextInput, MultilineInput\nfrom langflow.io import Output\nfrom langflow.schema import Data, DataFrame\nfrom langflow.schema.message import Message\n\n\nclass WikipediaComponent(Component):\n    display_name = \"Wikipedia\"\n    description = \"Call Wikipedia API.\"\n    icon = \"Wikipedia\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input\",\n            tool_mode=True,\n        ),\n        MessageTextInput(name=\"lang\", display_name=\"Language\", value=\"en\"),\n        IntInput(name=\"k\", display_name=\"Number of results\", value=4, required=True),\n        BoolInput(name=\"load_all_available_meta\", display_name=\"Load all available meta\", value=False, advanced=True),\n        IntInput(\n            name=\"doc_content_chars_max\", display_name=\"Document content characters max\", value=4000, advanced=True\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"fetch_content\"),\n        Output(display_name=\"DataFrame\", name=\"dataframe\", method=\"as_dataframe\"),\n    ]\n\n    def fetch_content(self) -> list[Data]:\n        wrapper = self._build_wrapper()\n        docs = wrapper.load(self.input_value)\n        data = [Data.from_document(doc) for doc in docs]\n        self.status = data\n        return data\n\n    def fetch_content_text(self) -> Message:\n        data = self.fetch_content()\n        result_string = \"\"\n        for item in data:\n            result_string += item.text + \"\\n\"\n        self.status = result_string\n        return Message(text=result_string)\n\n    def _build_wrapper(self) -> WikipediaAPIWrapper:\n        return WikipediaAPIWrapper(\n            top_k_results=self.k,\n            lang=self.lang,\n            load_all_available_meta=self.load_all_available_meta,\n            doc_content_chars_max=self.doc_content_chars_max,\n        )\n\n    def as_dataframe(self) -> DataFrame:\n        \"\"\"Convert the Wikipedia results to a DataFrame.\n\n        Returns:\n            DataFrame: A DataFrame containing the Wikipedia results.\n        \"\"\"\n        data = self.fetch_content()\n        return DataFrame(data)\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "doc_content_chars_max": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "doc_content_chars_max",
        "value": 4000,
        "display_name": "Document content characters max",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "input_value": {
        "tool_mode": true,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "input_value",
        "value": "",
        "display_name": "Input",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "k": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "k",
        "value": 4,
        "display_name": "Number of results",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "lang": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "lang",
        "value": "en",
        "display_name": "Language",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "load_all_available_meta": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "load_all_available_meta",
        "value": false,
        "display_name": "Load all available meta",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      }
    },
    "description": "Call Wikipedia API.",
    "icon": "Wikipedia",
    "base_classes": [
      "Data",
      "DataFrame"
    ],
    "display_name": "Wikipedia",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "data",
        "display_name": "Data",
        "method": "fetch_content",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "input_value",
      "lang",
      "k",
      "load_all_available_meta",
      "doc_content_chars_max"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "DuckDuckGoSearchComponent": {
    "template": {
      "_type": "Component",
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain_community.tools import DuckDuckGoSearchRun\n\nfrom langflow.custom import Component\nfrom langflow.inputs import IntInput, MessageTextInput\nfrom langflow.io import Output\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\n\n\nclass DuckDuckGoSearchComponent(Component):\n    \"\"\"Component for performing web searches using DuckDuckGo.\"\"\"\n\n    display_name = \"DuckDuckGo Search\"\n    description = \"Search the web using DuckDuckGo with customizable result limits\"\n    documentation = \"https://python.langchain.com/docs/integrations/tools/ddg\"\n    icon = \"DuckDuckGo\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"input_value\",\n            display_name=\"Search Query\",\n            required=True,\n            info=\"The search query to execute with DuckDuckGo\",\n            tool_mode=True,\n        ),\n        IntInput(\n            name=\"max_results\",\n            display_name=\"Max Results\",\n            value=5,\n            required=False,\n            advanced=True,\n            info=\"Maximum number of search results to return\",\n        ),\n        IntInput(\n            name=\"max_snippet_length\",\n            display_name=\"Max Snippet Length\",\n            value=100,\n            required=False,\n            advanced=True,\n            info=\"Maximum length of each result snippet\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"fetch_content\"),\n        Output(display_name=\"Text\", name=\"text\", method=\"fetch_content_text\"),\n    ]\n\n    def _build_wrapper(self) -> DuckDuckGoSearchRun:\n        \"\"\"Build the DuckDuckGo search wrapper.\"\"\"\n        return DuckDuckGoSearchRun()\n\n    def run_model(self) -> list[Data]:\n        return self.fetch_content()\n\n    def fetch_content(self) -> list[Data]:\n        \"\"\"Execute the search and return results as Data objects.\"\"\"\n        try:\n            wrapper = self._build_wrapper()\n\n            full_results = wrapper.run(f\"{self.input_value} (site:*)\")\n\n            result_list = full_results.split(\"\\n\")[: self.max_results]\n\n            data_results = []\n            for result in result_list:\n                if result.strip():\n                    snippet = result[: self.max_snippet_length]\n                    data_results.append(\n                        Data(\n                            text=snippet,\n                            data={\n                                \"content\": result,\n                                \"snippet\": snippet,\n                            },\n                        )\n                    )\n        except (ValueError, AttributeError) as e:\n            error_data = [Data(text=str(e), data={\"error\": str(e)})]\n            self.status = error_data\n            return error_data\n        else:\n            self.status = data_results\n            return data_results\n\n    def fetch_content_text(self) -> Message:\n        \"\"\"Return search results as a single text message.\"\"\"\n        data = self.fetch_content()\n        result_string = \"\\n\".join(item.text for item in data)\n        self.status = result_string\n        return Message(text=result_string)\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "input_value": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "input_value",
        "value": "",
        "display_name": "Search Query",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The search query to execute with DuckDuckGo",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "max_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "max_results",
        "value": 5,
        "display_name": "Max Results",
        "advanced": true,
        "dynamic": false,
        "info": "Maximum number of search results to return",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "max_snippet_length": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "max_snippet_length",
        "value": 100,
        "display_name": "Max Snippet Length",
        "advanced": true,
        "dynamic": false,
        "info": "Maximum length of each result snippet",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      }
    },
    "description": "Search the web using DuckDuckGo with customizable result limits",
    "icon": "DuckDuckGo",
    "base_classes": [
      "Data",
      "Message"
    ],
    "display_name": "DuckDuckGo Search",
    "documentation": "https://python.langchain.com/docs/integrations/tools/ddg",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "data",
        "display_name": "Data",
        "method": "fetch_content",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "Message"
        ],
        "selected": "Message",
        "name": "text",
        "display_name": "Text",
        "method": "fetch_content_text",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "input_value",
      "max_results",
      "max_snippet_length"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "CalculatorComponent": {
    "template": {
      "_type": "Component",
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "import ast\nimport operator\nfrom collections.abc import Callable\n\nfrom langflow.custom import Component\nfrom langflow.inputs import MessageTextInput\nfrom langflow.io import Output\nfrom langflow.schema import Data\n\n\nclass CalculatorComponent(Component):\n    display_name = \"Calculator\"\n    description = \"Perform basic arithmetic operations on a given expression.\"\n    icon = \"calculator\"\n\n    # Cache operators dictionary as a class variable\n    OPERATORS: dict[type[ast.operator], Callable] = {\n        ast.Add: operator.add,\n        ast.Sub: operator.sub,\n        ast.Mult: operator.mul,\n        ast.Div: operator.truediv,\n        ast.Pow: operator.pow,\n    }\n\n    inputs = [\n        MessageTextInput(\n            name=\"expression\",\n            display_name=\"Expression\",\n            info=\"The arithmetic expression to evaluate (e.g., '4*4*(33/22)+12-20').\",\n            tool_mode=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"result\", type_=Data, method=\"evaluate_expression\"),\n    ]\n\n    def _eval_expr(self, node: ast.AST) -> float:\n        \"\"\"Evaluate an AST node recursively.\"\"\"\n        if isinstance(node, ast.Constant):\n            if isinstance(node.value, int | float):\n                return float(node.value)\n            error_msg = f\"Unsupported constant type: {type(node.value).__name__}\"\n            raise TypeError(error_msg)\n        if isinstance(node, ast.Num):  # For backwards compatibility\n            if isinstance(node.n, int | float):\n                return float(node.n)\n            error_msg = f\"Unsupported number type: {type(node.n).__name__}\"\n            raise TypeError(error_msg)\n\n        if isinstance(node, ast.BinOp):\n            op_type = type(node.op)\n            if op_type not in self.OPERATORS:\n                error_msg = f\"Unsupported binary operator: {op_type.__name__}\"\n                raise TypeError(error_msg)\n\n            left = self._eval_expr(node.left)\n            right = self._eval_expr(node.right)\n            return self.OPERATORS[op_type](left, right)\n\n        error_msg = f\"Unsupported operation or expression type: {type(node).__name__}\"\n        raise TypeError(error_msg)\n\n    def evaluate_expression(self) -> Data:\n        \"\"\"Evaluate the mathematical expression and return the result.\"\"\"\n        try:\n            tree = ast.parse(self.expression, mode=\"eval\")\n            result = self._eval_expr(tree.body)\n\n            formatted_result = f\"{float(result):.6f}\".rstrip(\"0\").rstrip(\".\")\n            self.log(f\"Calculation result: {formatted_result}\")\n\n            self.status = formatted_result\n            return Data(data={\"result\": formatted_result})\n\n        except ZeroDivisionError:\n            error_message = \"Error: Division by zero\"\n            self.status = error_message\n            return Data(data={\"error\": error_message, \"input\": self.expression})\n\n        except (SyntaxError, TypeError, KeyError, ValueError, AttributeError, OverflowError) as e:\n            error_message = f\"Invalid expression: {e!s}\"\n            self.status = error_message\n            return Data(data={\"error\": error_message, \"input\": self.expression})\n\n    def build(self):\n        \"\"\"Return the main evaluation function.\"\"\"\n        return self.evaluate_expression\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "expression": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "expression",
        "value": "",
        "display_name": "Expression",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The arithmetic expression to evaluate (e.g., '4*4*(33/22)+12-20').",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      }
    },
    "description": "Perform basic arithmetic operations on a given expression.",
    "icon": "calculator",
    "base_classes": [
      "Data"
    ],
    "display_name": "Calculator",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "result",
        "display_name": "Data",
        "method": "evaluate_expression",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "expression"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "SerpAPI": {
    "template": {
      "_type": "Component",
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from typing import Any\n\nfrom langchain.tools import StructuredTool\nfrom langchain_community.utilities.serpapi import SerpAPIWrapper\nfrom langchain_core.tools import ToolException\nfrom loguru import logger\nfrom pydantic import BaseModel, Field\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import DictInput, IntInput, MultilineInput, SecretStrInput\nfrom langflow.schema import Data\n\n\nclass SerpAPISchema(BaseModel):\n    \"\"\"Schema for SerpAPI search parameters.\"\"\"\n\n    query: str = Field(..., description=\"The search query\")\n    params: dict[str, Any] | None = Field(\n        default={\n            \"engine\": \"google\",\n            \"google_domain\": \"google.com\",\n            \"gl\": \"us\",\n            \"hl\": \"en\",\n        },\n        description=\"Additional search parameters\",\n    )\n    max_results: int = Field(5, description=\"Maximum number of results to return\")\n    max_snippet_length: int = Field(100, description=\"Maximum length of each result snippet\")\n\n\nclass SerpAPIComponent(LCToolComponent):\n    display_name = \"Serp Search API [DEPRECATED]\"\n    description = \"Call Serp Search API with result limiting\"\n    name = \"SerpAPI\"\n    icon = \"SerpSearch\"\n    legacy = True\n\n    inputs = [\n        SecretStrInput(name=\"serpapi_api_key\", display_name=\"SerpAPI API Key\", required=True),\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input\",\n        ),\n        DictInput(name=\"search_params\", display_name=\"Parameters\", advanced=True, is_list=True),\n        IntInput(name=\"max_results\", display_name=\"Max Results\", value=5, advanced=True),\n        IntInput(name=\"max_snippet_length\", display_name=\"Max Snippet Length\", value=100, advanced=True),\n    ]\n\n    def _build_wrapper(self, params: dict[str, Any] | None = None) -> SerpAPIWrapper:\n        \"\"\"Build a SerpAPIWrapper with the provided parameters.\"\"\"\n        params = params or {}\n        if params:\n            return SerpAPIWrapper(\n                serpapi_api_key=self.serpapi_api_key,\n                params=params,\n            )\n        return SerpAPIWrapper(serpapi_api_key=self.serpapi_api_key)\n\n    def build_tool(self) -> Tool:\n        wrapper = self._build_wrapper(self.search_params)\n\n        def search_func(\n            query: str, params: dict[str, Any] | None = None, max_results: int = 5, max_snippet_length: int = 100\n        ) -> list[dict[str, Any]]:\n            try:\n                local_wrapper = wrapper\n                if params:\n                    local_wrapper = self._build_wrapper(params)\n\n                full_results = local_wrapper.results(query)\n                organic_results = full_results.get(\"organic_results\", [])[:max_results]\n\n                limited_results = []\n                for result in organic_results:\n                    limited_result = {\n                        \"title\": result.get(\"title\", \"\")[:max_snippet_length],\n                        \"link\": result.get(\"link\", \"\"),\n                        \"snippet\": result.get(\"snippet\", \"\")[:max_snippet_length],\n                    }\n                    limited_results.append(limited_result)\n\n            except Exception as e:\n                error_message = f\"Error in SerpAPI search: {e!s}\"\n                logger.debug(error_message)\n                raise ToolException(error_message) from e\n            return limited_results\n\n        tool = StructuredTool.from_function(\n            name=\"serp_search_api\",\n            description=\"Search for recent results using SerpAPI with result limiting\",\n            func=search_func,\n            args_schema=SerpAPISchema,\n        )\n\n        self.status = \"SerpAPI Tool created\"\n        return tool\n\n    def run_model(self) -> list[Data]:\n        tool = self.build_tool()\n        try:\n            results = tool.run(\n                {\n                    \"query\": self.input_value,\n                    \"params\": self.search_params or {},\n                    \"max_results\": self.max_results,\n                    \"max_snippet_length\": self.max_snippet_length,\n                }\n            )\n\n            data_list = [Data(data=result, text=result.get(\"snippet\", \"\")) for result in results]\n\n        except Exception as e:  # noqa: BLE001\n            logger.opt(exception=True).debug(\"Error running SerpAPI\")\n            self.status = f\"Error: {e}\"\n            return [Data(data={\"error\": str(e)}, text=str(e))]\n\n        self.status = data_list  # type: ignore[assignment]\n        return data_list\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "input_value": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "input_value",
        "value": "",
        "display_name": "Input",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      },
      "max_results": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "max_results",
        "value": 5,
        "display_name": "Max Results",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "max_snippet_length": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "max_snippet_length",
        "value": 100,
        "display_name": "Max Snippet Length",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "search_params": {
        "tool_mode": false,
        "trace_as_input": true,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "search_params",
        "value": {},
        "display_name": "Parameters",
        "advanced": true,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "dict",
        "_input_type": "DictInput"
      },
      "serpapi_api_key": {
        "load_from_db": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "serpapi_api_key",
        "value": "",
        "display_name": "SerpAPI API Key",
        "advanced": false,
        "input_types": [],
        "dynamic": false,
        "info": "",
        "title_case": false,
        "password": true,
        "type": "str",
        "_input_type": "SecretStrInput"
      }
    },
    "description": "Call Serp Search API with result limiting",
    "icon": "SerpSearch",
    "base_classes": [
      "Data",
      "Tool"
    ],
    "display_name": "Serp Search API [DEPRECATED]",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "api_run_model",
        "display_name": "Data",
        "method": "run_model",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "serpapi_api_key"
        ],
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "Tool"
        ],
        "selected": "Tool",
        "name": "api_build_tool",
        "display_name": "Tool",
        "method": "build_tool",
        "value": "__UNDEFINED__",
        "cache": true,
        "required_inputs": [
          "serpapi_api_key"
        ],
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "serpapi_api_key",
      "input_value",
      "search_params",
      "max_results",
      "max_snippet_length"
    ],
    "beta": false,
    "legacy": true,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  }
}