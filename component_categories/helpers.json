{
  "StructuredOutput": {
    "template": {
      "_type": "Component",
      "llm": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "llm",
        "value": "",
        "display_name": "Language Model",
        "advanced": false,
        "input_types": [
          "LanguageModel"
        ],
        "dynamic": false,
        "info": "The language model to use to generate the structured output.",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from pydantic import BaseModel, Field, create_model\nfrom trustcall import create_extractor\n\nfrom langflow.base.models.chat_result import get_chat_result\nfrom langflow.custom import Component\nfrom langflow.helpers.base_model import build_model_from_schema\nfrom langflow.io import (\n    BoolInput,\n    HandleInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TableInput,\n)\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.table import EditMode\n\n\nclass StructuredOutputComponent(Component):\n    display_name = \"Structured Output\"\n    description = (\n        \"Transforms LLM responses into **structured data formats**. Ideal for extracting specific information \"\n        \"or creating consistent outputs.\"\n    )\n    name = \"StructuredOutput\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"llm\",\n            display_name=\"Language Model\",\n            info=\"The language model to use to generate the structured output.\",\n            input_types=[\"LanguageModel\"],\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"input_value\",\n            display_name=\"Input Message\",\n            info=\"The input message to the language model.\",\n            tool_mode=True,\n            required=True,\n        ),\n        MultilineInput(\n            name=\"system_prompt\",\n            display_name=\"Format Instructions\",\n            info=\"The instructions to the language model for formatting the output.\",\n            value=(\n                \"You are an AI system designed to extract structured information from unstructured text.\"\n                \"Given the input_text, return a JSON object with predefined keys based on the expected structure.\"\n                \"Extract values accurately and format them according to the specified type \"\n                \"(e.g., string, integer, float, date).\"\n                \"If a value is missing or cannot be determined, return a default \"\n                \"(e.g., null, 0, or 'N/A').\"\n                \"If multiple instances of the expected structure exist within the input_text, \"\n                \"stream each as a separate JSON object.\"\n            ),\n            required=True,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"schema_name\",\n            display_name=\"Schema Name\",\n            info=\"Provide a name for the output data schema.\",\n            advanced=True,\n        ),\n        TableInput(\n            name=\"output_schema\",\n            display_name=\"Output Schema\",\n            info=\"Define the structure and data types for the model's output.\",\n            required=True,\n            # TODO: remove deault value\n            table_schema=[\n                {\n                    \"name\": \"name\",\n                    \"display_name\": \"Name\",\n                    \"type\": \"str\",\n                    \"description\": \"Specify the name of the output field.\",\n                    \"default\": \"field\",\n                    \"edit_mode\": EditMode.INLINE,\n                },\n                {\n                    \"name\": \"description\",\n                    \"display_name\": \"Description\",\n                    \"type\": \"str\",\n                    \"description\": \"Describe the purpose of the output field.\",\n                    \"default\": \"description of field\",\n                    \"edit_mode\": EditMode.POPOVER,\n                },\n                {\n                    \"name\": \"type\",\n                    \"display_name\": \"Type\",\n                    \"type\": \"str\",\n                    \"edit_mode\": EditMode.INLINE,\n                    \"description\": (\n                        \"Indicate the data type of the output field (e.g., str, int, float, bool, list, dict).\"\n                    ),\n                    \"options\": [\"str\", \"int\", \"float\", \"bool\", \"list\", \"dict\"],\n                    \"default\": \"str\",\n                },\n                {\n                    \"name\": \"multiple\",\n                    \"display_name\": \"Multiple\",\n                    \"type\": \"boolean\",\n                    \"description\": \"Set to True if this output field should be a list of the specified type.\",\n                    \"default\": \"False\",\n                    \"edit_mode\": EditMode.INLINE,\n                },\n            ],\n            value=[\n                {\n                    \"name\": \"field\",\n                    \"description\": \"description of field\",\n                    \"type\": \"str\",\n                    \"multiple\": \"False\",\n                }\n            ],\n        ),\n        BoolInput(\n            name=\"multiple\",\n            advanced=True,\n            display_name=\"Generate Multiple\",\n            info=\"[Deplrecated] Always set to True\",\n            value=True,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            name=\"structured_output\",\n            display_name=\"Structured Output\",\n            method=\"build_structured_output\",\n        ),\n        Output(\n            name=\"structured_output_dataframe\",\n            display_name=\"DataFrame\",\n            method=\"as_dataframe\",\n        ),\n    ]\n\n    def build_structured_output_base(self) -> Data:\n        schema_name = self.schema_name or \"OutputModel\"\n\n        if not hasattr(self.llm, \"with_structured_output\"):\n            msg = \"Language model does not support structured output.\"\n            raise TypeError(msg)\n        if not self.output_schema:\n            msg = \"Output schema cannot be empty\"\n            raise ValueError(msg)\n\n        output_model_ = build_model_from_schema(self.output_schema)\n\n        output_model = create_model(\n            schema_name,\n            __doc__=f\"A list of {schema_name}.\",\n            objects=(list[output_model_], Field(description=f\"A list of {schema_name}.\")),  # type: ignore[valid-type]\n        )\n\n        try:\n            llm_with_structured_output = create_extractor(self.llm, tools=[output_model])\n        except NotImplementedError as exc:\n            msg = f\"{self.llm.__class__.__name__} does not support structured output.\"\n            raise TypeError(msg) from exc\n        config_dict = {\n            \"run_name\": self.display_name,\n            \"project_name\": self.get_project_name(),\n            \"callbacks\": self.get_langchain_callbacks(),\n        }\n        result = get_chat_result(\n            runnable=llm_with_structured_output,\n            system_message=self.system_prompt,\n            input_value=self.input_value,\n            config=config_dict,\n        )\n        if isinstance(result, BaseModel):\n            result = result.model_dump()\n        if responses := result.get(\"responses\"):\n            result = responses[0].model_dump()\n        if result and \"objects\" in result:\n            return result[\"objects\"]\n\n        return result\n\n    def build_structured_output(self) -> Data:\n        output = self.build_structured_output_base()\n\n        return Data(text_key=\"results\", data={\"results\": output})\n\n    def as_dataframe(self) -> DataFrame:\n        output = self.build_structured_output_base()\n        if isinstance(output, list):\n            return DataFrame(data=output)\n        return DataFrame(data=[output])\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "input_value": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "input_value",
        "value": "",
        "display_name": "Input Message",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The input message to the language model.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "multiple": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "multiple",
        "value": true,
        "display_name": "Generate Multiple",
        "advanced": true,
        "dynamic": false,
        "info": "[Deplrecated] Always set to True",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "output_schema": {
        "tool_mode": false,
        "is_list": true,
        "list_add_label": "Add More",
        "table_schema": {
          "columns": [
            {
              "name": "name",
              "display_name": "Name",
              "sortable": true,
              "filterable": true,
              "formatter": "text",
              "type": "str",
              "description": "Specify the name of the output field.",
              "default": "field",
              "disable_edit": false,
              "edit_mode": "inline",
              "hidden": false
            },
            {
              "name": "description",
              "display_name": "Description",
              "sortable": true,
              "filterable": true,
              "formatter": "text",
              "type": "str",
              "description": "Describe the purpose of the output field.",
              "default": "description of field",
              "disable_edit": false,
              "edit_mode": "popover",
              "hidden": false
            },
            {
              "name": "type",
              "display_name": "Type",
              "options": [
                "str",
                "int",
                "float",
                "bool",
                "list",
                "dict"
              ],
              "sortable": true,
              "filterable": true,
              "formatter": "text",
              "type": "str",
              "description": "Indicate the data type of the output field (e.g., str, int, float, bool, list, dict).",
              "default": "str",
              "disable_edit": false,
              "edit_mode": "inline",
              "hidden": false
            },
            {
              "name": "multiple",
              "display_name": "Multiple",
              "sortable": true,
              "filterable": true,
              "formatter": "boolean",
              "type": "boolean",
              "description": "Set to True if this output field should be a list of the specified type.",
              "default": false,
              "disable_edit": false,
              "edit_mode": "inline",
              "hidden": false
            }
          ]
        },
        "trigger_text": "Open table",
        "trigger_icon": "Table",
        "table_icon": "Table",
        "trace_as_metadata": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "output_schema",
        "value": [
          {
            "name": "field",
            "description": "description of field",
            "type": "str",
            "multiple": "False"
          }
        ],
        "display_name": "Output Schema",
        "advanced": false,
        "dynamic": false,
        "info": "Define the structure and data types for the model's output.",
        "title_case": false,
        "type": "table",
        "_input_type": "TableInput"
      },
      "schema_name": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "schema_name",
        "value": "",
        "display_name": "Schema Name",
        "advanced": true,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Provide a name for the output data schema.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "system_prompt": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "system_prompt",
        "value": "You are an AI system designed to extract structured information from unstructured text.Given the input_text, return a JSON object with predefined keys based on the expected structure.Extract values accurately and format them according to the specified type (e.g., string, integer, float, date).If a value is missing or cannot be determined, return a default (e.g., null, 0, or 'N/A').If multiple instances of the expected structure exist within the input_text, stream each as a separate JSON object.",
        "display_name": "Format Instructions",
        "advanced": true,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The instructions to the language model for formatting the output.",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      }
    },
    "description": "Transforms LLM responses into **structured data formats**. Ideal for extracting specific information or creating consistent outputs.",
    "icon": "braces",
    "base_classes": [
      "Data",
      "DataFrame"
    ],
    "display_name": "Structured Output",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "structured_output",
        "display_name": "Structured Output",
        "method": "build_structured_output",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "structured_output_dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "llm",
      "input_value",
      "system_prompt",
      "schema_name",
      "output_schema",
      "multiple"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "IDGenerator": {
    "template": {
      "_type": "Component",
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "import uuid\nfrom typing import Any\n\nfrom typing_extensions import override\n\nfrom langflow.custom import Component\nfrom langflow.io import MessageTextInput, Output\nfrom langflow.schema import dotdict\nfrom langflow.schema.message import Message\n\n\nclass IDGeneratorComponent(Component):\n    display_name = \"ID Generator\"\n    description = \"Generates a unique ID.\"\n    icon = \"fingerprint\"\n    name = \"IDGenerator\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"unique_id\",\n            display_name=\"Value\",\n            info=\"The generated unique ID.\",\n            refresh_button=True,\n            tool_mode=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"ID\", name=\"id\", method=\"generate_id\"),\n    ]\n\n    @override\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if field_name == \"unique_id\":\n            build_config[field_name][\"value\"] = str(uuid.uuid4())\n        return build_config\n\n    def generate_id(self) -> Message:\n        unique_id = self.unique_id or str(uuid.uuid4())\n        self.status = f\"Generated ID: {unique_id}\"\n        return Message(text=unique_id)\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "unique_id": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "unique_id",
        "value": "",
        "display_name": "Value",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The generated unique ID.",
        "refresh_button": true,
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      }
    },
    "description": "Generates a unique ID.",
    "icon": "fingerprint",
    "base_classes": [
      "Message"
    ],
    "display_name": "ID Generator",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Message"
        ],
        "selected": "Message",
        "name": "id",
        "display_name": "ID",
        "method": "generate_id",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "unique_id"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "CreateList": {
    "template": {
      "_type": "Component",
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langflow.custom import Component\nfrom langflow.inputs import StrInput\nfrom langflow.schema import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.template import Output\n\n\nclass CreateListComponent(Component):\n    display_name = \"Create List\"\n    description = \"Creates a list of texts.\"\n    icon = \"list\"\n    name = \"CreateList\"\n    legacy = True\n\n    inputs = [\n        StrInput(\n            name=\"texts\",\n            display_name=\"Texts\",\n            info=\"Enter one or more texts.\",\n            is_list=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data List\", name=\"list\", method=\"create_list\"),\n        Output(display_name=\"DataFrame\", name=\"dataframe\", method=\"as_dataframe\"),\n    ]\n\n    def create_list(self) -> list[Data]:\n        data = [Data(text=text) for text in self.texts]\n        self.status = data\n        return data\n\n    def as_dataframe(self) -> DataFrame:\n        \"\"\"Convert the list of Data objects into a DataFrame.\n\n        Returns:\n            DataFrame: A DataFrame containing the list data.\n        \"\"\"\n        return DataFrame(self.create_list())\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "texts": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": true,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "texts",
        "value": "",
        "display_name": "Texts",
        "advanced": false,
        "dynamic": false,
        "info": "Enter one or more texts.",
        "title_case": false,
        "type": "str",
        "_input_type": "StrInput"
      }
    },
    "description": "Creates a list of texts.",
    "icon": "list",
    "base_classes": [
      "Data",
      "DataFrame"
    ],
    "display_name": "Create List",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "list",
        "display_name": "Data List",
        "method": "create_list",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "texts"
    ],
    "beta": false,
    "legacy": true,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "Memory": {
    "template": {
      "_type": "Component",
      "memory": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "memory",
        "value": "",
        "display_name": "External Memory",
        "advanced": false,
        "input_types": [
          "Memory"
        ],
        "dynamic": false,
        "info": "Retrieve messages from an external memory. If empty, it will use the Langflow tables.",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langflow.custom import Component\nfrom langflow.helpers.data import data_to_text\nfrom langflow.inputs import HandleInput\nfrom langflow.io import DropdownInput, IntInput, MessageTextInput, MultilineInput, Output\nfrom langflow.memory import aget_messages\nfrom langflow.schema import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import MESSAGE_SENDER_AI, MESSAGE_SENDER_USER\n\n\nclass MemoryComponent(Component):\n    display_name = \"Message History\"\n    description = \"Retrieves stored chat messages from Langflow tables or an external memory.\"\n    icon = \"message-square-more\"\n    name = \"Memory\"\n\n    inputs = [\n        HandleInput(\n            name=\"memory\",\n            display_name=\"External Memory\",\n            input_types=[\"Memory\"],\n            info=\"Retrieve messages from an external memory. If empty, it will use the Langflow tables.\",\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER, \"Machine and User\"],\n            value=\"Machine and User\",\n            info=\"Filter by sender type.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Filter by sender name.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"n_messages\",\n            display_name=\"Number of Messages\",\n            value=100,\n            info=\"Number of messages to retrieve.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"order\",\n            display_name=\"Order\",\n            options=[\"Ascending\", \"Descending\"],\n            value=\"Ascending\",\n            info=\"Order of the messages.\",\n            advanced=True,\n            tool_mode=True,\n        ),\n        MultilineInput(\n            name=\"template\",\n            display_name=\"Template\",\n            info=\"The template to use for formatting the data. \"\n            \"It can contain the keys {text}, {sender} or any other key in the message data.\",\n            value=\"{sender_name}: {text}\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"messages\", method=\"retrieve_messages\"),\n        Output(display_name=\"Message\", name=\"messages_text\", method=\"retrieve_messages_as_text\"),\n        Output(display_name=\"DataFrame\", name=\"dataframe\", method=\"as_dataframe\"),\n    ]\n\n    async def retrieve_messages(self) -> Data:\n        sender = self.sender\n        sender_name = self.sender_name\n        session_id = self.session_id\n        n_messages = self.n_messages\n        order = \"DESC\" if self.order == \"Descending\" else \"ASC\"\n\n        if sender == \"Machine and User\":\n            sender = None\n\n        if self.memory and not hasattr(self.memory, \"aget_messages\"):\n            memory_name = type(self.memory).__name__\n            err_msg = f\"External Memory object ({memory_name}) must have 'aget_messages' method.\"\n            raise AttributeError(err_msg)\n\n        if self.memory:\n            # override session_id\n            self.memory.session_id = session_id\n\n            stored = await self.memory.aget_messages()\n            # langchain memories are supposed to return messages in ascending order\n            if order == \"DESC\":\n                stored = stored[::-1]\n            if n_messages:\n                stored = stored[:n_messages]\n            stored = [Message.from_lc_message(m) for m in stored]\n            if sender:\n                expected_type = MESSAGE_SENDER_AI if sender == MESSAGE_SENDER_AI else MESSAGE_SENDER_USER\n                stored = [m for m in stored if m.type == expected_type]\n        else:\n            stored = await aget_messages(\n                sender=sender,\n                sender_name=sender_name,\n                session_id=session_id,\n                limit=n_messages,\n                order=order,\n            )\n        self.status = stored\n        return stored\n\n    async def retrieve_messages_as_text(self) -> Message:\n        stored_text = data_to_text(self.template, await self.retrieve_messages())\n        self.status = stored_text\n        return Message(text=stored_text)\n\n    async def as_dataframe(self) -> DataFrame:\n        \"\"\"Convert the retrieved messages into a DataFrame.\n\n        Returns:\n            DataFrame: A DataFrame containing the message data.\n        \"\"\"\n        messages = await self.retrieve_messages()\n        return DataFrame(messages)\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "n_messages": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "n_messages",
        "value": 100,
        "display_name": "Number of Messages",
        "advanced": true,
        "dynamic": false,
        "info": "Number of messages to retrieve.",
        "title_case": false,
        "type": "int",
        "_input_type": "IntInput"
      },
      "order": {
        "tool_mode": true,
        "trace_as_metadata": true,
        "options": [
          "Ascending",
          "Descending"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "order",
        "value": "Ascending",
        "display_name": "Order",
        "advanced": true,
        "dynamic": false,
        "info": "Order of the messages.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "sender": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "Machine",
          "User",
          "Machine and User"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "sender",
        "value": "Machine and User",
        "display_name": "Sender Type",
        "advanced": true,
        "dynamic": false,
        "info": "Filter by sender type.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      },
      "sender_name": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "sender_name",
        "value": "",
        "display_name": "Sender Name",
        "advanced": true,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Filter by sender name.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "session_id": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "session_id",
        "value": "",
        "display_name": "Session ID",
        "advanced": true,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "template": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "template",
        "value": "{sender_name}: {text}",
        "display_name": "Template",
        "advanced": true,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The template to use for formatting the data. It can contain the keys {text}, {sender} or any other key in the message data.",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      }
    },
    "description": "Retrieves stored chat messages from Langflow tables or an external memory.",
    "icon": "message-square-more",
    "base_classes": [
      "Data",
      "DataFrame",
      "Message"
    ],
    "display_name": "Message History",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Data"
        ],
        "selected": "Data",
        "name": "messages",
        "display_name": "Data",
        "method": "retrieve_messages",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "Message"
        ],
        "selected": "Message",
        "name": "messages_text",
        "display_name": "Message",
        "method": "retrieve_messages_as_text",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "dataframe",
        "display_name": "DataFrame",
        "method": "as_dataframe",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "memory",
      "sender",
      "sender_name",
      "n_messages",
      "session_id",
      "order",
      "template"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "StoreMessage": {
    "template": {
      "_type": "Component",
      "memory": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "memory",
        "value": "",
        "display_name": "External Memory",
        "advanced": false,
        "input_types": [
          "Memory"
        ],
        "dynamic": false,
        "info": "The external memory to store the message. If empty, it will use the Langflow tables.",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langflow.custom import Component\nfrom langflow.inputs import HandleInput\nfrom langflow.inputs.inputs import MessageTextInput\nfrom langflow.memory import aget_messages, astore_message\nfrom langflow.schema.message import Message\nfrom langflow.template import Output\nfrom langflow.utils.constants import MESSAGE_SENDER_AI, MESSAGE_SENDER_NAME_AI\n\n\nclass MessageStoreComponent(Component):\n    display_name = \"Message Store\"\n    description = \"Stores a chat message or text into Langflow tables or an external memory.\"\n    icon = \"message-square-text\"\n    name = \"StoreMessage\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"message\", display_name=\"Message\", info=\"The chat message to be stored.\", required=True, tool_mode=True\n        ),\n        HandleInput(\n            name=\"memory\",\n            display_name=\"External Memory\",\n            input_types=[\"Memory\"],\n            info=\"The external memory to store the message. If empty, it will use the Langflow tables.\",\n        ),\n        MessageTextInput(\n            name=\"sender\",\n            display_name=\"Sender\",\n            info=\"The sender of the message. Might be Machine or User. \"\n            \"If empty, the current sender parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"The name of the sender. Might be AI or User. If empty, the current sender parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            value=\"\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Stored Messages\", name=\"stored_messages\", method=\"store_message\", hidden=True),\n    ]\n\n    async def store_message(self) -> Message:\n        message = Message(text=self.message) if isinstance(self.message, str) else self.message\n\n        message.session_id = self.session_id or message.session_id\n        message.sender = self.sender or message.sender or MESSAGE_SENDER_AI\n        message.sender_name = self.sender_name or message.sender_name or MESSAGE_SENDER_NAME_AI\n\n        stored_messages: list[Message] = []\n\n        if self.memory:\n            self.memory.session_id = message.session_id\n            lc_message = message.to_lc_message()\n            await self.memory.aadd_messages([lc_message])\n\n            stored_messages = await self.memory.aget_messages() or []\n\n            stored_messages = [Message.from_lc_message(m) for m in stored_messages] if stored_messages else []\n\n            if message.sender:\n                stored_messages = [m for m in stored_messages if m.sender == message.sender]\n        else:\n            await astore_message(message, flow_id=self.graph.flow_id)\n            stored_messages = (\n                await aget_messages(\n                    session_id=message.session_id, sender_name=message.sender_name, sender=message.sender\n                )\n                or []\n            )\n\n        if not stored_messages:\n            msg = \"No messages were stored. Please ensure that the session ID and sender are properly set.\"\n            raise ValueError(msg)\n\n        stored_message = stored_messages[0]\n        self.status = stored_message\n        return stored_message\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "message": {
        "tool_mode": true,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "message",
        "value": "",
        "display_name": "Message",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The chat message to be stored.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "sender": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "sender",
        "value": "",
        "display_name": "Sender",
        "advanced": true,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The sender of the message. Might be Machine or User. If empty, the current sender parameter will be used.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "sender_name": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "sender_name",
        "value": "",
        "display_name": "Sender Name",
        "advanced": true,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The name of the sender. Might be AI or User. If empty, the current sender parameter will be used.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "session_id": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "session_id",
        "value": "",
        "display_name": "Session ID",
        "advanced": true,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      }
    },
    "description": "Stores a chat message or text into Langflow tables or an external memory.",
    "icon": "message-square-text",
    "base_classes": [
      "Message"
    ],
    "display_name": "Message Store",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Message"
        ],
        "selected": "Message",
        "name": "stored_messages",
        "hidden": true,
        "display_name": "Stored Messages",
        "method": "store_message",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "message",
      "memory",
      "sender",
      "sender_name",
      "session_id"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "OutputParser": {
    "template": {
      "_type": "Component",
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from langchain_core.output_parsers import CommaSeparatedListOutputParser\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.field_typing.constants import OutputParser\nfrom langflow.io import DropdownInput, Output\nfrom langflow.schema.message import Message\n\n\nclass OutputParserComponent(Component):\n    display_name = \"Output Parser\"\n    description = \"Transforms the output of an LLM into a specified format.\"\n    icon = \"type\"\n    name = \"OutputParser\"\n    legacy = True\n\n    inputs = [\n        DropdownInput(\n            name=\"parser_type\",\n            display_name=\"Parser\",\n            options=[\"CSV\"],\n            value=\"CSV\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Format Instructions\",\n            name=\"format_instructions\",\n            info=\"Pass to a prompt template to include formatting instructions for LLM responses.\",\n            method=\"format_instructions\",\n        ),\n        Output(display_name=\"Output Parser\", name=\"output_parser\", method=\"build_parser\"),\n    ]\n\n    def build_parser(self) -> OutputParser:\n        if self.parser_type == \"CSV\":\n            return CommaSeparatedListOutputParser()\n        msg = \"Unsupported or missing parser\"\n        raise ValueError(msg)\n\n    def format_instructions(self) -> Message:\n        if self.parser_type == \"CSV\":\n            return Message(text=CommaSeparatedListOutputParser().get_format_instructions())\n        msg = \"Unsupported or missing parser\"\n        raise ValueError(msg)\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "parser_type": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "options": [
          "CSV"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "parser_type",
        "value": "CSV",
        "display_name": "Parser",
        "advanced": false,
        "dynamic": false,
        "info": "",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      }
    },
    "description": "Transforms the output of an LLM into a specified format.",
    "icon": "type",
    "base_classes": [
      "Message",
      "OutputParser"
    ],
    "display_name": "Output Parser",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Message"
        ],
        "selected": "Message",
        "name": "format_instructions",
        "display_name": "Format Instructions",
        "method": "format_instructions",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      },
      {
        "types": [
          "OutputParser"
        ],
        "selected": "OutputParser",
        "name": "output_parser",
        "display_name": "Output Parser",
        "method": "build_parser",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "parser_type"
    ],
    "beta": false,
    "legacy": true,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "BatchRunComponent": {
    "template": {
      "_type": "Component",
      "df": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "trace_as_input": true,
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "df",
        "value": "",
        "display_name": "DataFrame",
        "advanced": false,
        "input_types": [
          "DataFrame"
        ],
        "dynamic": false,
        "info": "The DataFrame whose column (specified by 'column_name') we'll treat as text messages.",
        "title_case": false,
        "type": "other",
        "_input_type": "DataFrameInput"
      },
      "model": {
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": true,
        "placeholder": "",
        "show": true,
        "name": "model",
        "value": "",
        "display_name": "Language Model",
        "advanced": false,
        "input_types": [
          "LanguageModel"
        ],
        "dynamic": false,
        "info": "Connect the 'Language Model' output from your LLM component here.",
        "title_case": false,
        "type": "other",
        "_input_type": "HandleInput"
      },
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Any, cast\n\nimport toml  # type: ignore[import-untyped]\nfrom loguru import logger\n\nfrom langflow.custom import Component\nfrom langflow.io import BoolInput, DataFrameInput, HandleInput, MessageTextInput, MultilineInput, Output\nfrom langflow.schema import DataFrame\n\nif TYPE_CHECKING:\n    from langchain_core.runnables import Runnable\n\n\nclass BatchRunComponent(Component):\n    display_name = \"Batch Run\"\n    description = \"Runs an LLM over each row of a DataFrame's column. If no column is set, the entire row is passed.\"\n    icon = \"List\"\n    beta = True\n\n    inputs = [\n        HandleInput(\n            name=\"model\",\n            display_name=\"Language Model\",\n            info=\"Connect the 'Language Model' output from your LLM component here.\",\n            input_types=[\"LanguageModel\"],\n            required=True,\n        ),\n        MultilineInput(\n            name=\"system_message\",\n            display_name=\"Instructions\",\n            info=\"Multi-line system instruction for all rows in the DataFrame.\",\n            required=False,\n        ),\n        DataFrameInput(\n            name=\"df\",\n            display_name=\"DataFrame\",\n            info=\"The DataFrame whose column (specified by 'column_name') we'll treat as text messages.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"column_name\",\n            display_name=\"Column Name\",\n            info=(\n                \"The name of the DataFrame column to treat as text messages. \"\n                \"If empty, all columns will be formatted in TOML.\"\n            ),\n            required=False,\n            advanced=False,\n        ),\n        MessageTextInput(\n            name=\"output_column_name\",\n            display_name=\"Output Column Name\",\n            info=\"Name of the column where the model's response will be stored.\",\n            value=\"model_response\",\n            required=False,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"enable_metadata\",\n            display_name=\"Enable Metadata\",\n            info=\"If True, add metadata to the output DataFrame.\",\n            value=False,\n            required=False,\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"batch_results\",\n            method=\"run_batch\",\n            info=\"A DataFrame with all original columns plus the model's response column.\",\n        ),\n    ]\n\n    def _format_row_as_toml(self, row: dict[str, Any]) -> str:\n        \"\"\"Convert a dictionary (row) into a TOML-formatted string.\"\"\"\n        formatted_dict = {str(col): {\"value\": str(val)} for col, val in row.items()}\n        return toml.dumps(formatted_dict)\n\n    def _create_base_row(\n        self, original_row: dict[str, Any], model_response: str = \"\", batch_index: int = -1\n    ) -> dict[str, Any]:\n        \"\"\"Create a base row with original columns and additional metadata.\"\"\"\n        row = original_row.copy()\n        row[self.output_column_name] = model_response\n        row[\"batch_index\"] = batch_index\n        return row\n\n    def _add_metadata(\n        self, row: dict[str, Any], *, success: bool = True, system_msg: str = \"\", error: str | None = None\n    ) -> None:\n        \"\"\"Add metadata to a row if enabled.\"\"\"\n        if not self.enable_metadata:\n            return\n\n        if success:\n            row[\"metadata\"] = {\n                \"has_system_message\": bool(system_msg),\n                \"input_length\": len(row.get(\"text_input\", \"\")),\n                \"response_length\": len(row[self.output_column_name]),\n                \"processing_status\": \"success\",\n            }\n        else:\n            row[\"metadata\"] = {\n                \"error\": error,\n                \"processing_status\": \"failed\",\n            }\n\n    async def run_batch(self) -> DataFrame:\n        \"\"\"Process each row in df[column_name] with the language model asynchronously.\n\n        Returns:\n            DataFrame: A new DataFrame containing:\n                - All original columns\n                - The model's response column (customizable name)\n                - 'batch_index' column for processing order\n                - 'metadata' (optional)\n\n        Raises:\n            ValueError: If the specified column is not found in the DataFrame\n            TypeError: If the model is not compatible or input types are wrong\n        \"\"\"\n        model: Runnable = self.model\n        system_msg = self.system_message or \"\"\n        df: DataFrame = self.df\n        col_name = self.column_name or \"\"\n\n        # Validate inputs first\n        if not isinstance(df, DataFrame):\n            msg = f\"Expected DataFrame input, got {type(df)}\"\n            raise TypeError(msg)\n\n        if col_name and col_name not in df.columns:\n            msg = f\"Column '{col_name}' not found in the DataFrame. Available columns: {', '.join(df.columns)}\"\n            raise ValueError(msg)\n\n        try:\n            # Determine text input for each row\n            if col_name:\n                user_texts = df[col_name].astype(str).tolist()\n            else:\n                user_texts = [\n                    self._format_row_as_toml(cast(dict[str, Any], row)) for row in df.to_dict(orient=\"records\")\n                ]\n\n            total_rows = len(user_texts)\n            logger.info(f\"Processing {total_rows} rows with batch run\")\n\n            # Prepare the batch of conversations\n            conversations = [\n                [{\"role\": \"system\", \"content\": system_msg}, {\"role\": \"user\", \"content\": text}]\n                if system_msg\n                else [{\"role\": \"user\", \"content\": text}]\n                for text in user_texts\n            ]\n\n            # Configure the model with project info and callbacks\n            model = model.with_config(\n                {\n                    \"run_name\": self.display_name,\n                    \"project_name\": self.get_project_name(),\n                    \"callbacks\": self.get_langchain_callbacks(),\n                }\n            )\n            # Process batches and track progress\n            responses_with_idx = list(\n                zip(\n                    range(len(conversations)),\n                    await model.abatch(list(conversations)),\n                    strict=True,\n                )\n            )\n\n            # Sort by index to maintain order\n            responses_with_idx.sort(key=lambda x: x[0])\n\n            # Build the final data with enhanced metadata\n            rows: list[dict[str, Any]] = []\n            for idx, (original_row, response) in enumerate(\n                zip(df.to_dict(orient=\"records\"), responses_with_idx, strict=False)\n            ):\n                response_text = response[1].content if hasattr(response[1], \"content\") else str(response[1])\n                row = self._create_base_row(\n                    cast(dict[str, Any], original_row), model_response=response_text, batch_index=idx\n                )\n                self._add_metadata(row, success=True, system_msg=system_msg)\n                rows.append(row)\n\n                # Log progress\n                if (idx + 1) % max(1, total_rows // 10) == 0:\n                    logger.info(f\"Processed {idx + 1}/{total_rows} rows\")\n\n            logger.info(\"Batch processing completed successfully\")\n            return DataFrame(rows)\n\n        except (KeyError, AttributeError) as e:\n            # Handle data structure and attribute access errors\n            logger.error(f\"Data processing error: {e!s}\")\n            error_row = self._create_base_row({col: \"\" for col in df.columns}, model_response=\"\", batch_index=-1)\n            self._add_metadata(error_row, success=False, error=str(e))\n            return DataFrame([error_row])\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "column_name": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "column_name",
        "value": "",
        "display_name": "Column Name",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "The name of the DataFrame column to treat as text messages. If empty, all columns will be formatted in TOML.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "enable_metadata": {
        "tool_mode": false,
        "trace_as_metadata": true,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "enable_metadata",
        "value": false,
        "display_name": "Enable Metadata",
        "advanced": true,
        "dynamic": false,
        "info": "If True, add metadata to the output DataFrame.",
        "title_case": false,
        "type": "bool",
        "_input_type": "BoolInput"
      },
      "output_column_name": {
        "tool_mode": false,
        "trace_as_input": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "output_column_name",
        "value": "model_response",
        "display_name": "Output Column Name",
        "advanced": true,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Name of the column where the model's response will be stored.",
        "title_case": false,
        "type": "str",
        "_input_type": "MessageTextInput"
      },
      "system_message": {
        "tool_mode": false,
        "trace_as_input": true,
        "multiline": true,
        "trace_as_metadata": true,
        "load_from_db": false,
        "list": false,
        "list_add_label": "Add More",
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "system_message",
        "value": "",
        "display_name": "Instructions",
        "advanced": false,
        "input_types": [
          "Message"
        ],
        "dynamic": false,
        "info": "Multi-line system instruction for all rows in the DataFrame.",
        "title_case": false,
        "copy_field": false,
        "type": "str",
        "_input_type": "MultilineInput"
      }
    },
    "description": "Runs an LLM over each row of a DataFrame's column. If no column is set, the entire row is passed.",
    "icon": "List",
    "base_classes": [
      "DataFrame"
    ],
    "display_name": "Batch Run",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "DataFrame"
        ],
        "selected": "DataFrame",
        "name": "batch_results",
        "display_name": "DataFrame",
        "method": "run_batch",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "model",
      "system_message",
      "df",
      "column_name",
      "output_column_name",
      "enable_metadata"
    ],
    "beta": true,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  },
  "CurrentDate": {
    "template": {
      "_type": "Component",
      "code": {
        "type": "code",
        "required": true,
        "placeholder": "",
        "list": false,
        "show": true,
        "multiline": true,
        "value": "from datetime import datetime\nfrom zoneinfo import ZoneInfo, available_timezones\n\nfrom loguru import logger\n\nfrom langflow.custom import Component\nfrom langflow.io import DropdownInput, Output\nfrom langflow.schema.message import Message\n\n\nclass CurrentDateComponent(Component):\n    display_name = \"Current Date\"\n    description = \"Returns the current date and time in the selected timezone.\"\n    icon = \"clock\"\n    name = \"CurrentDate\"\n\n    inputs = [\n        DropdownInput(\n            name=\"timezone\",\n            display_name=\"Timezone\",\n            options=list(available_timezones()),\n            value=\"UTC\",\n            info=\"Select the timezone for the current date and time.\",\n            tool_mode=True,\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Current Date\", name=\"current_date\", method=\"get_current_date\"),\n    ]\n\n    def get_current_date(self) -> Message:\n        try:\n            tz = ZoneInfo(self.timezone)\n            current_date = datetime.now(tz).strftime(\"%Y-%m-%d %H:%M:%S %Z\")\n            result = f\"Current date and time in {self.timezone}: {current_date}\"\n            self.status = result\n            return Message(text=result)\n        except Exception as e:  # noqa: BLE001\n            logger.opt(exception=True).debug(\"Error getting current date\")\n            error_message = f\"Error: {e}\"\n            self.status = error_message\n            return Message(text=error_message)\n",
        "fileTypes": [],
        "file_path": "",
        "password": false,
        "name": "code",
        "advanced": true,
        "dynamic": true,
        "info": "",
        "load_from_db": false,
        "title_case": false
      },
      "timezone": {
        "tool_mode": true,
        "trace_as_metadata": true,
        "options": [
          "Indian/Chagos",
          "CET",
          "Pacific/Johnston",
          "Asia/Tomsk",
          "Africa/Kinshasa",
          "America/Cayman",
          "America/Monterrey",
          "America/Argentina/San_Juan",
          "Etc/GMT-7",
          "America/Indiana/Vevay",
          "Asia/Yekaterinburg",
          "Asia/Yakutsk",
          "Pacific/Kanton",
          "America/Boise",
          "Africa/Casablanca",
          "Canada/Mountain",
          "Asia/Qostanay",
          "Asia/Kuching",
          "Asia/Ashgabat",
          "Pacific/Kosrae",
          "America/Santiago",
          "Jamaica",
          "America/Phoenix",
          "America/Creston",
          "Etc/GMT-8",
          "Asia/Aqtobe",
          "America/Recife",
          "Europe/Stockholm",
          "Pacific/Marquesas",
          "Asia/Urumqi",
          "Asia/Brunei",
          "Canada/Eastern",
          "Chile/EasterIsland",
          "Mexico/BajaSur",
          "Zulu",
          "Asia/Karachi",
          "Mexico/General",
          "Europe/Copenhagen",
          "Africa/Johannesburg",
          "Australia/Queensland",
          "Africa/Addis_Ababa",
          "Europe/Bratislava",
          "America/Tijuana",
          "Australia/Lord_Howe",
          "Africa/Banjul",
          "Antarctica/Syowa",
          "Europe/Belgrade",
          "Asia/Gaza",
          "America/Argentina/Rio_Gallegos",
          "America/Argentina/Tucuman",
          "Etc/GMT-1",
          "America/Juneau",
          "Etc/Zulu",
          "Asia/Qatar",
          "Asia/Kuwait",
          "Europe/Guernsey",
          "GB-Eire",
          "Pacific/Wake",
          "America/Martinique",
          "Asia/Baku",
          "Etc/GMT+10",
          "Pacific/Norfolk",
          "Etc/GMT+5",
          "Asia/Irkutsk",
          "America/Porto_Velho",
          "America/Puerto_Rico",
          "Asia/Shanghai",
          "America/Toronto",
          "Etc/GMT-13",
          "Europe/Uzhgorod",
          "Australia/Darwin",
          "America/Edmonton",
          "Africa/Mbabane",
          "America/Barbados",
          "America/Regina",
          "America/Antigua",
          "Asia/Dhaka",
          "Etc/GMT+1",
          "US/Pacific",
          "Europe/Vatican",
          "America/Santo_Domingo",
          "Australia/Tasmania",
          "Antarctica/Davis",
          "Australia/LHI",
          "America/Buenos_Aires",
          "Africa/Accra",
          "Africa/Ceuta",
          "Pacific/Chatham",
          "America/North_Dakota/Center",
          "Asia/Thimphu",
          "Europe/Simferopol",
          "America/Cordoba",
          "Africa/Algiers",
          "Hongkong",
          "Pacific/Fakaofo",
          "Africa/Blantyre",
          "Africa/Timbuktu",
          "America/Indiana/Marengo",
          "America/Santarem",
          "Asia/Srednekolymsk",
          "Australia/Perth",
          "Europe/Budapest",
          "Asia/Baghdad",
          "GMT-0",
          "Africa/Kigali",
          "Antarctica/South_Pole",
          "Europe/Skopje",
          "America/Montreal",
          "Africa/Kampala",
          "America/Campo_Grande",
          "Pacific/Samoa",
          "Europe/Warsaw",
          "GMT0",
          "America/Anchorage",
          "Europe/Zurich",
          "Asia/Kabul",
          "Asia/Muscat",
          "ROC",
          "Asia/Calcutta",
          "Asia/Vientiane",
          "Etc/GMT+3",
          "Asia/Riyadh",
          "Asia/Krasnoyarsk",
          "Etc/GMT-10",
          "US/Samoa",
          "America/Argentina/Jujuy",
          "America/Jamaica",
          "Etc/UTC",
          "America/Moncton",
          "America/Guadeloupe",
          "Antarctica/Casey",
          "Europe/San_Marino",
          "Atlantic/Faeroe",
          "Pacific/Majuro",
          "Pacific/Saipan",
          "America/Atikokan",
          "America/St_Vincent",
          "Etc/GMT-3",
          "Atlantic/St_Helena",
          "America/Santa_Isabel",
          "Asia/Macau",
          "America/Mexico_City",
          "America/Denver",
          "CST6CDT",
          "Europe/Volgograd",
          "Africa/Ouagadougou",
          "Asia/Tehran",
          "US/Hawaii",
          "Australia/Hobart",
          "America/Dawson_Creek",
          "Etc/GMT+0",
          "Etc/GMT-11",
          "America/Ciudad_Juarez",
          "America/Rio_Branco",
          "Asia/Istanbul",
          "Africa/Monrovia",
          "America/Cancun",
          "Africa/Mogadishu",
          "PST8PDT",
          "Europe/Busingen",
          "Eire",
          "Europe/Vaduz",
          "Europe/Paris",
          "Africa/Brazzaville",
          "America/Swift_Current",
          "PRC",
          "Africa/Porto-Novo",
          "America/Paramaribo",
          "Europe/Nicosia",
          "Asia/Ust-Nera",
          "Cuba",
          "America/Glace_Bay",
          "Asia/Seoul",
          "NZ-CHAT",
          "Europe/Ljubljana",
          "Canada/Central",
          "US/Alaska",
          "Pacific/Guadalcanal",
          "Antarctica/McMurdo",
          "Australia/Currie",
          "America/Montevideo",
          "Europe/Vienna",
          "Asia/Barnaul",
          "America/Pangnirtung",
          "Asia/Kolkata",
          "Europe/Athens",
          "Indian/Christmas",
          "Africa/Bujumbura",
          "Asia/Anadyr",
          "America/Goose_Bay",
          "Asia/Ashkhabad",
          "Mexico/BajaNorte",
          "America/Montserrat",
          "Asia/Pontianak",
          "Atlantic/Bermuda",
          "America/Indiana/Winamac",
          "America/Cambridge_Bay",
          "Antarctica/Vostok",
          "Europe/Minsk",
          "Iceland",
          "NZ",
          "America/Marigot",
          "America/Fortaleza",
          "America/Godthab",
          "Australia/West",
          "Africa/El_Aaiun",
          "America/Managua",
          "Europe/Podgorica",
          "Asia/Famagusta",
          "Africa/Freetown",
          "Australia/Eucla",
          "America/Fort_Nelson",
          "Africa/Conakry",
          "Asia/Jakarta",
          "Asia/Vladivostok",
          "Indian/Kerguelen",
          "Pacific/Niue",
          "GB",
          "US/Mountain",
          "Africa/Nairobi",
          "Asia/Tokyo",
          "Brazil/Acre",
          "America/St_Kitts",
          "America/Merida",
          "America/Argentina/Catamarca",
          "Asia/Manila",
          "America/Indiana/Tell_City",
          "America/Eirunepe",
          "US/Indiana-Starke",
          "Europe/Kiev",
          "America/Ojinaga",
          "Antarctica/Mawson",
          "Africa/Khartoum",
          "Europe/Berlin",
          "Indian/Mayotte",
          "Africa/Dakar",
          "Europe/Kirov",
          "America/North_Dakota/Beulah",
          "Asia/Nicosia",
          "America/Dawson",
          "Pacific/Ponape",
          "America/Cayenne",
          "America/Asuncion",
          "Pacific/Nauru",
          "America/Nuuk",
          "Asia/Dacca",
          "MET",
          "Asia/Hovd",
          "America/Indiana/Vincennes",
          "Atlantic/Reykjavik",
          "America/Mendoza",
          "Japan",
          "Asia/Katmandu",
          "Indian/Mauritius",
          "Asia/Sakhalin",
          "America/Scoresbysund",
          "Africa/Gaborone",
          "Asia/Dili",
          "Pacific/Port_Moresby",
          "Asia/Saigon",
          "America/St_Lucia",
          "America/St_Barthelemy",
          "America/Port_of_Spain",
          "America/Maceio",
          "Pacific/Gambier",
          "America/Grand_Turk",
          "America/El_Salvador",
          "Atlantic/Madeira",
          "Brazil/DeNoronha",
          "Pacific/Funafuti",
          "America/Dominica",
          "Asia/Taipei",
          "Etc/GMT-9",
          "Pacific/Pohnpei",
          "Asia/Rangoon",
          "Etc/Universal",
          "Europe/Brussels",
          "Atlantic/Stanley",
          "America/Anguilla",
          "Pacific/Guam",
          "America/Blanc-Sablon",
          "Asia/Yerevan",
          "America/Nome",
          "Asia/Pyongyang",
          "America/Aruba",
          "America/Metlakatla",
          "Asia/Samarkand",
          "Antarctica/Troll",
          "Asia/Dushanbe",
          "Africa/Douala",
          "America/Menominee",
          "Africa/Niamey",
          "Africa/Tunis",
          "Asia/Chungking",
          "Asia/Bishkek",
          "Asia/Kathmandu",
          "Canada/Saskatchewan",
          "Africa/Abidjan",
          "Asia/Macao",
          "Europe/Isle_of_Man",
          "Asia/Jerusalem",
          "Africa/Sao_Tome",
          "Europe/Rome",
          "Europe/Prague",
          "Kwajalein",
          "Etc/GMT",
          "Africa/Bangui",
          "Asia/Harbin",
          "Asia/Makassar",
          "America/Rosario",
          "America/Port-au-Prince",
          "America/Indiana/Knox",
          "Pacific/Pago_Pago",
          "America/Halifax",
          "US/East-Indiana",
          "Australia/South",
          "Asia/Kashgar",
          "Etc/GMT-6",
          "US/Arizona",
          "Iran",
          "America/Chicago",
          "Europe/Riga",
          "America/Indianapolis",
          "Asia/Chongqing",
          "Asia/Colombo",
          "Antarctica/Rothera",
          "Australia/Broken_Hill",
          "HST",
          "Australia/Melbourne",
          "Pacific/Midway",
          "EET",
          "Pacific/Truk",
          "Etc/Greenwich",
          "America/Danmarkshavn",
          "Europe/Chisinau",
          "America/Inuvik",
          "Etc/GMT+9",
          "Asia/Beirut",
          "Europe/Istanbul",
          "America/Costa_Rica",
          "America/Boa_Vista",
          "Turkey",
          "Africa/Asmera",
          "Asia/Khandyga",
          "Etc/GMT+8",
          "Pacific/Apia",
          "America/Vancouver",
          "Etc/GMT-14",
          "Africa/Libreville",
          "Africa/Tripoli",
          "Etc/GMT+2",
          "America/Matamoros",
          "America/Indiana/Petersburg",
          "Pacific/Noumea",
          "Atlantic/Cape_Verde",
          "America/Argentina/Mendoza",
          "Australia/Sydney",
          "Arctic/Longyearbyen",
          "Europe/Kyiv",
          "Pacific/Tongatapu",
          "America/Manaus",
          "Europe/Helsinki",
          "Africa/Ndjamena",
          "America/Argentina/Buenos_Aires",
          "America/Caracas",
          "Brazil/West",
          "Asia/Almaty",
          "Asia/Chita",
          "Africa/Maputo",
          "America/Sao_Paulo",
          "Pacific/Enderbury",
          "Australia/Adelaide",
          "America/Fort_Wayne",
          "America/Havana",
          "America/Belem",
          "America/Whitehorse",
          "America/Miquelon",
          "America/Knox_IN",
          "America/Bahia_Banderas",
          "America/Araguaina",
          "Asia/Dubai",
          "Africa/Luanda",
          "Europe/Astrakhan",
          "Pacific/Chuuk",
          "Europe/Monaco",
          "America/Los_Angeles",
          "Libya",
          "America/Curacao",
          "America/Kralendijk",
          "America/Catamarca",
          "America/St_Johns",
          "Africa/Harare",
          "Australia/Brisbane",
          "Etc/GMT+7",
          "Asia/Tashkent",
          "Etc/UCT",
          "W-SU",
          "Asia/Magadan",
          "America/Rainy_River",
          "Africa/Lagos",
          "Israel",
          "Antarctica/DumontDUrville",
          "America/Sitka",
          "Europe/Luxembourg",
          "Universal",
          "Pacific/Tahiti",
          "Asia/Amman",
          "Europe/Zaporozhye",
          "America/Guatemala",
          "Etc/GMT-0",
          "Asia/Omsk",
          "Asia/Aden",
          "Asia/Kamchatka",
          "Pacific/Auckland",
          "Pacific/Fiji",
          "America/Winnipeg",
          "Pacific/Pitcairn",
          "Pacific/Kiritimati",
          "America/Bogota",
          "Europe/Oslo",
          "Asia/Atyrau",
          "Asia/Yangon",
          "Africa/Juba",
          "Africa/Djibouti",
          "Asia/Aqtau",
          "Asia/Oral",
          "Europe/Samara",
          "America/Argentina/Salta",
          "Pacific/Bougainville",
          "Africa/Bamako",
          "Asia/Ujung_Pandang",
          "Europe/Sarajevo",
          "America/Argentina/San_Luis",
          "Australia/Lindeman",
          "Atlantic/Azores",
          "GMT",
          "EST5EDT",
          "Asia/Choibalsan",
          "Canada/Atlantic",
          "US/Michigan",
          "Asia/Tel_Aviv",
          "Asia/Qyzylorda",
          "Indian/Cocos",
          "Pacific/Kwajalein",
          "America/Thunder_Bay",
          "America/Guayaquil",
          "America/Resolute",
          "Antarctica/Macquarie",
          "Africa/Dar_es_Salaam",
          "Pacific/Palau",
          "America/Argentina/Ushuaia",
          "Navajo",
          "Africa/Nouakchott",
          "America/Shiprock",
          "America/Tortola",
          "America/Yakutat",
          "Asia/Jayapura",
          "Africa/Lubumbashi",
          "Asia/Ho_Chi_Minh",
          "Brazil/East",
          "UCT",
          "America/Yellowknife",
          "America/Thule",
          "America/Mazatlan",
          "America/Iqaluit",
          "Australia/Victoria",
          "MST",
          "Poland",
          "Australia/NSW",
          "Etc/GMT-4",
          "Asia/Kuala_Lumpur",
          "America/Guyana",
          "Europe/Zagreb",
          "Atlantic/South_Georgia",
          "America/Lower_Princes",
          "Africa/Lusaka",
          "America/Tegucigalpa",
          "Asia/Thimbu",
          "Pacific/Galapagos",
          "ROK",
          "Europe/Belfast",
          "WET",
          "Indian/Mahe",
          "Africa/Asmara",
          "America/Bahia",
          "America/Panama",
          "Etc/GMT-12",
          "Europe/Ulyanovsk",
          "America/Ensenada",
          "America/St_Thomas",
          "Asia/Tbilisi",
          "America/Argentina/ComodRivadavia",
          "Etc/GMT+6",
          "America/Chihuahua",
          "America/Atka",
          "Africa/Cairo",
          "US/Eastern",
          "Pacific/Easter",
          "Europe/Madrid",
          "Etc/GMT+11",
          "Atlantic/Jan_Mayen",
          "Chile/Continental",
          "Europe/Jersey",
          "Indian/Comoro",
          "Asia/Damascus",
          "Pacific/Rarotonga",
          "Asia/Phnom_Penh",
          "America/Virgin",
          "Asia/Bahrain",
          "EST",
          "Pacific/Honolulu",
          "America/Kentucky/Louisville",
          "Europe/Saratov",
          "UTC",
          "Singapore",
          "America/Jujuy",
          "Antarctica/Palmer",
          "America/Belize",
          "America/New_York",
          "Pacific/Efate",
          "Asia/Hong_Kong",
          "Asia/Hebron",
          "Australia/Canberra",
          "Asia/Ulaanbaatar",
          "Europe/Tiraspol",
          "America/Argentina/La_Rioja",
          "Greenwich",
          "Etc/GMT+12",
          "Europe/Andorra",
          "Pacific/Yap",
          "America/Kentucky/Monticello",
          "Europe/Bucharest",
          "Asia/Novosibirsk",
          "Europe/Tirane",
          "Asia/Novokuznetsk",
          "Factory",
          "Europe/Malta",
          "US/Central",
          "GMT+0",
          "Europe/London",
          "Europe/Gibraltar",
          "Australia/North",
          "Indian/Reunion",
          "Etc/GMT-5",
          "Asia/Singapore",
          "America/Hermosillo",
          "Europe/Tallinn",
          "Africa/Malabo",
          "America/Rankin_Inlet",
          "Portugal",
          "Africa/Maseru",
          "Atlantic/Faroe",
          "America/Grenada",
          "America/Punta_Arenas",
          "Europe/Mariehamn",
          "Asia/Ulan_Bator",
          "America/La_Paz",
          "Canada/Pacific",
          "America/Noronha",
          "Indian/Antananarivo",
          "Indian/Maldives",
          "Canada/Yukon",
          "Europe/Amsterdam",
          "Africa/Bissau",
          "America/Louisville",
          "America/Nipigon",
          "America/Indiana/Indianapolis",
          "America/Adak",
          "Africa/Windhoek",
          "Europe/Moscow",
          "Asia/Bangkok",
          "America/Detroit",
          "Etc/GMT-2",
          "Europe/Vilnius",
          "Canada/Newfoundland",
          "America/Porto_Acre",
          "Etc/GMT0",
          "America/Lima",
          "Europe/Sofia",
          "America/Coral_Harbour",
          "Atlantic/Canary",
          "US/Aleutian",
          "Europe/Dublin",
          "MST7MDT",
          "America/Nassau",
          "America/North_Dakota/New_Salem",
          "Egypt",
          "Australia/Yancowinna",
          "Pacific/Tarawa",
          "Pacific/Wallis",
          "Africa/Lome",
          "Etc/GMT+4",
          "Europe/Kaliningrad",
          "Europe/Lisbon",
          "America/Argentina/Cordoba",
          "Australia/ACT",
          "America/Cuiaba"
        ],
        "options_metadata": [],
        "combobox": false,
        "dialog_inputs": {},
        "toggle": false,
        "required": false,
        "placeholder": "",
        "show": true,
        "name": "timezone",
        "value": "UTC",
        "display_name": "Timezone",
        "advanced": false,
        "dynamic": false,
        "info": "Select the timezone for the current date and time.",
        "title_case": false,
        "type": "str",
        "_input_type": "DropdownInput"
      }
    },
    "description": "Returns the current date and time in the selected timezone.",
    "icon": "clock",
    "base_classes": [
      "Message"
    ],
    "display_name": "Current Date",
    "documentation": "",
    "minimized": false,
    "custom_fields": {},
    "output_types": [],
    "pinned": false,
    "conditional_paths": [],
    "frozen": false,
    "outputs": [
      {
        "types": [
          "Message"
        ],
        "selected": "Message",
        "name": "current_date",
        "display_name": "Current Date",
        "method": "get_current_date",
        "value": "__UNDEFINED__",
        "cache": true,
        "allows_loop": false,
        "tool_mode": true
      }
    ],
    "field_order": [
      "timezone"
    ],
    "beta": false,
    "legacy": false,
    "edited": false,
    "metadata": {},
    "tool_mode": false
  }
}